<!DOCTYPE html>
<html lang="en">
  <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta name="generator" content="pandoc" />
          <meta name="author" content="Thorsten Ball" />
              <meta name="date" content="2018-01-01" />
              <title>Writing A Compiler In Go</title>
      <style type="text/css">code{white-space: pre;}</style>
        <style type="text/css">
    body {
      margin: 40px auto;

      max-width:700px;

      padding: 0 10px;

      font-family: Georgia, serif;
      font-size: 18px;

      line-height: 1.45;
      color: black;
    }

    h1, h2, h3 {
      line-height:1.2;
    }

    pre {
      padding-left:15px;
    }

    .cover {
      text-align: center;
    }

    .cover img {
      max-width: 400px;
    }

    #TOC {
      margin-top: 5em;
    }

    .sourceCode {
      line-height: 1.4;
      font-size: 15px;
    }

    figure, .figure {
      text-align:center;
    }

    .caption {
      font-style:italic;
    }
    </style>
          <style type="text/css">
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
      </style>
                  </head>
<body>
<div id="header">
<div class="cover">
  <img src="./images/html_cover.png">
</div>
<h1 class="title">Writing A Compiler In Go</h1>
<h2 class="author">Thorsten Ball</h2>
</div>
<div id="TOC">
<h3>Contents</h3>
<ul>
<li><a href="#acknowledgments">Acknowledgments</a></li>
<li><a href="#introduction">Introduction</a>
<ul>
<li><a href="#evolving-monkey">Evolving Monkey</a>
<ul>
<li><a href="#the-past-and-present">The Past and Present</a></li>
<li><a href="#the-future">The Future</a></li>
</ul></li>
<li><a href="#use-this-book">Use This Book</a></li>
</ul></li>
<li><a href="#compilers-virtual-machines">Compilers &amp; Virtual Machines</a>
<ul>
<li><a href="#compilers">Compilers</a></li>
<li><a href="#virtual-and-real-machines">Virtual and Real Machines</a>
<ul>
<li><a href="#real-machines">Real Machines</a></li>
<li><a href="#what-is-a-virtual-machine">What Is a Virtual Machine?</a></li>
<li><a href="#why-build-one">Why Build One?</a></li>
<li><a href="#bytecode">Bytecode</a></li>
</ul></li>
<li><a href="#what-were-going-to-do-or-the-duality-of-vm-and-compiler">What We’re Going to Do, or: the Duality of VM and Compiler</a></li>
</ul></li>
<li><a href="#hello-bytecode">Hello Bytecode!</a>
<ul>
<li><a href="#first-instructions">First Instructions</a>
<ul>
<li><a href="#starting-with-bytes">Starting With Bytes</a></li>
<li><a href="#the-smallest-compiler">The Smallest Compiler</a></li>
<li><a href="#bytecode-disassemble">Bytecode, Disassemble!</a></li>
<li><a href="#back-to-the-task-at-hand">Back to the Task at Hand</a></li>
<li><a href="#powering-on-the-machine">Powering On the Machine</a></li>
</ul></li>
<li><a href="#adding-on-the-stack">Adding on the Stack</a></li>
<li><a href="#hooking-up-the-repl">Hooking up the REPL</a></li>
</ul></li>
<li><a href="#compiling-expressions">Compiling Expressions</a>
<ul>
<li><a href="#cleaning-up-the-stack">Cleaning Up the Stack</a></li>
<li><a href="#infix-expressions">Infix Expressions</a></li>
<li><a href="#booleans">Booleans</a></li>
<li><a href="#comparison-operators">Comparison Operators</a></li>
<li><a href="#prefix-expressions">Prefix Expressions</a></li>
</ul></li>
<li><a href="#conditionals">Conditionals</a>
<ul>
<li><a href="#jumps">Jumps</a></li>
<li><a href="#compiling-conditionals">Compiling Conditionals</a></li>
<li><a href="#executing-jumps">Executing Jumps</a></li>
<li><a href="#welcome-back-null">Welcome Back, Null!</a></li>
</ul></li>
<li><a href="#keeping-track-of-names">Keeping Track of Names</a>
<ul>
<li><a href="#the-plan">The Plan</a></li>
<li><a href="#compiling-bindings">Compiling Bindings</a>
<ul>
<li><a href="#introducing-the-symbol-table">Introducing: the Symbol Table</a></li>
<li><a href="#using-symbols-in-the-compiler">Using Symbols in the Compiler</a></li>
</ul></li>
<li><a href="#adding-globals-to-the-vm">Adding Globals to the VM</a></li>
</ul></li>
<li><a href="#string-array-and-hash">String, Array and Hash</a>
<ul>
<li><a href="#string">String</a></li>
<li><a href="#array">Array</a></li>
<li><a href="#hash">Hash</a></li>
<li><a href="#adding-the-index-operator">Adding the index operator</a></li>
</ul></li>
<li><a href="#functions">Functions</a>
<ul>
<li><a href="#dipping-our-toes-a-simple-function">Dipping Our Toes: a Simple Function</a>
<ul>
<li><a href="#representing-functions">Representing Functions</a></li>
<li><a href="#opcodes-to-execute-functions">Opcodes to Execute Functions</a></li>
<li><a href="#compiling-function-literals">Compiling Function Literals</a></li>
<li><a href="#compiling-function-calls">Compiling Function Calls</a></li>
<li><a href="#functions-in-the-vm">Functions in the VM</a></li>
<li><a href="#a-little-bonus">A Little Bonus</a></li>
</ul></li>
<li><a href="#local-bindings">Local Bindings</a>
<ul>
<li><a href="#opcodes-for-local-bindings">Opcodes for Local Bindings</a></li>
<li><a href="#compiling-locals">Compiling Locals</a></li>
<li><a href="#implementing-local-bindings-in-the-vm">Implementing Local Bindings in the VM</a></li>
</ul></li>
<li><a href="#arguments">Arguments</a>
<ul>
<li><a href="#compiling-calls-with-arguments">Compiling Calls With Arguments</a></li>
<li><a href="#resolving-references-to-arguments">Resolving References to Arguments</a></li>
<li><a href="#arguments-in-the-vm">Arguments in the VM</a></li>
</ul></li>
</ul></li>
<li><a href="#built-in-functions">Built-in Functions</a>
<ul>
<li><a href="#making-the-change-easy">Making the Change Easy</a></li>
<li><a href="#making-the-change-the-plan">Making the Change: the Plan</a></li>
<li><a href="#a-new-scope-for-built-in-functions">A New Scope for Built-in Functions</a></li>
<li><a href="#executing-built-in-functions">Executing built-in functions</a></li>
</ul></li>
<li><a href="#closures">Closures</a>
<ul>
<li><a href="#the-problem">The Problem</a></li>
<li><a href="#the-plan-1">The Plan</a></li>
<li><a href="#everythings-a-closure">Everything’s a closure</a></li>
<li><a href="#compiling-and-resolving-free-variables">Compiling and resolving free variables</a></li>
<li><a href="#creating-real-closures-at-run-time">Creating real closures at run time</a></li>
<li><a href="#recursive-closures">Recursive Closures</a></li>
</ul></li>
<li><a href="#taking-time">Taking Time</a></li>
<li><a href="#resources">Resources</a></li>
<li><a href="#feedback">Feedback</a></li>
<li><a href="#changelog">Changelog</a></li>
</ul>
</div>
<h1 class="unnumbered" id="acknowledgments">Acknowledgments</h1>
<p>I started writing this book one month after my daughter was born and finished shortly after her first birthday. Or, in other words: this book wouldn’t exist without the help of my wife. While our baby grew into the wonderful girl she is now and rightfully demanded the attention she deserves, my wife always created time and room for me to write. I couldn’t have written this book without her steady support and unwavering faith in me. Thank you!</p>
<p>Thanks to Christian for supporting me from the start again with an open ear and encouragement. Thanks to Ricardo for providing invaluable, in-depth feedback and expertise. Thanks to Yoji for his diligence and attention to detail. Thanks to all the other beta-readers for helping to make this book better!</p>
<h1 class="unnumbered" id="introduction">Introduction</h1>
<p>It might not be the most polite thing to do, but let’s start with a lie: the prequel to this book, <em>Writing An Interpreter In Go</em>, was much more successful than I ever imagined it would be. Yes, that’s a lie. Of course, I <em>imagined</em> its success. The name on the top of bestseller lists, me showered with praise and admiration, invited to fancy events, strangers walking up to me in the street, wanting to get their copy signed – who wouldn’t imagine that when writing a book about a programming language called Monkey? But, now, in all seriousness, the truth: I really didn’t <em>expect</em> the book to be as successful as it was.</p>
<p>Sure, I had a feeling that some people might enjoy it. Mainly because it’s the book I myself wanted to read, but couldn’t find. And on my fruitless search I saw other people looking for the exact same thing: a book about interpreters that is easy to understand, doesn’t take shortcuts and puts runnable and tested code front and center. If I could write a book like that, I thought, there might just be a chance that others would enjoy it, too.</p>
<p>But enough about my imagination, here’s what actually happened: readers really enjoyed what I wrote. They not only bought and read the book, but sent me emails to thank me for writing it. They wrote blog posts about how much they enjoyed it. They shared it on social networks and upvoted it. They played around with the code, tweaked it, extended it and shared it on GitHub. They even helped to fix errors in it. Imagine that! They sent me fixes for my mistakes, all the while saying sorry for finding them. Apparently, they couldn’t imagine how thankful I was for every suggestion and correction.</p>
<p>Then, after reading one email in which a reader asked for <em>more</em>, something in me clicked. What lived in the back of my mind as an idea turned into an obligation: I have to write the second part. Note that I didn’t just write “<em>a</em> second part”, but “<em>the</em> second part”. That’s because the first book was born out of a compromise.</p>
<p>When I set out to write <em>Writing An Interpreter In Go</em> the idea was not to follow it up with a sequel, but to only write a single book. That changed, though, when I realized that the final book would be too long. I never wanted to write something that scares people off with its size. And even if I did, completing the book would probably take so long that I would have most likely given up long before.</p>
<p>That led me to a compromise. Instead of writing about building a tree-walking interpreter and turning it into a virtual machine, I would <em>only</em> write about the tree-walking part. That turned into <em>Writing An Interpreter In Go</em> and what you’re reading now is the sequel I have always wanted to write.</p>
<p>But what exactly does sequel mean here? By now you know that this book doesn’t start with “Decades after the events in the first book, in another galaxy, where the name Monkey has no meaning…” No, this book is meant to seamlessly connect to its predecessor. It’s the same approach, the same programming language, the same tools and the codebase that we left at the end of the first book.</p>
<p>The idea is simple: we pick up where we left off and continue our work on Monkey. This is not only a successor to the previous book, but also a sequel to Monkey, the next step in its evolution. Before we can see what that looks like, though, we need look back, to refresh our memory of Monkey.</p>
<h2 id="evolving-monkey">Evolving Monkey</h2>
<h3 id="the-past-and-present">The Past and Present</h3>
<p>In <em>Writing An Interpreter In Go</em> we built an interpreter for the programming language Monkey. Monkey was invented with one purpose in mind: to be built from scratch in <em>Writing An Interpreter In Go</em> and by its readers. Its only official implementation is contained in <em>Writing An Interpreter In Go</em>, although many unofficial ones, built by readers in a variety of languages, are floating around the internet.</p>
<p>In case you forgot what Monkey looks like, here is a small snippet that tries to cram as much of Monkey’s features into as few lines as possible:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">let</span> name <span class="op">=</span> <span class="st">&quot;Monkey&quot;</span><span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">let</span> age <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">let</span> inspirations <span class="op">=</span> [<span class="st">&quot;Scheme&quot;</span><span class="op">,</span> <span class="st">&quot;Lisp&quot;</span><span class="op">,</span> <span class="st">&quot;JavaScript&quot;</span><span class="op">,</span> <span class="st">&quot;Clojure&quot;</span>]<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">let</span> book <span class="op">=</span> {</span>
<span id="cb1-5"><a href="#cb1-5"></a>  <span class="st">&quot;title&quot;</span><span class="op">:</span> <span class="st">&quot;Writing A Compiler In Go&quot;</span><span class="op">,</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>  <span class="st">&quot;author&quot;</span><span class="op">:</span> <span class="st">&quot;Thorsten Ball&quot;</span><span class="op">,</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>  <span class="st">&quot;prequel&quot;</span><span class="op">:</span> <span class="st">&quot;Writing An Interpreter In Go&quot;</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>}<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9"></a></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="kw">let</span> printBookName <span class="op">=</span> fn(book) {</span>
<span id="cb1-11"><a href="#cb1-11"></a>    <span class="kw">let</span> title <span class="op">=</span> book[<span class="st">&quot;title&quot;</span>]<span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    <span class="kw">let</span> author <span class="op">=</span> book[<span class="st">&quot;author&quot;</span>]<span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>    puts(author <span class="op">+</span> <span class="st">&quot; - &quot;</span> <span class="op">+</span> title)<span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14"></a>}<span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15"></a></span>
<span id="cb1-16"><a href="#cb1-16"></a>printBookName(book)<span class="op">;</span></span>
<span id="cb1-17"><a href="#cb1-17"></a><span class="co">// =&gt; prints: &quot;Thorsten Ball - Writing A Compiler In Go&quot;</span></span>
<span id="cb1-18"><a href="#cb1-18"></a></span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="kw">let</span> fibonacci <span class="op">=</span> fn(x) {</span>
<span id="cb1-20"><a href="#cb1-20"></a>  <span class="cf">if</span> (x <span class="op">==</span> <span class="dv">0</span>) {</span>
<span id="cb1-21"><a href="#cb1-21"></a>    <span class="dv">0</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>  } <span class="cf">else</span> {</span>
<span id="cb1-23"><a href="#cb1-23"></a>    <span class="cf">if</span> (x <span class="op">==</span> <span class="dv">1</span>) {</span>
<span id="cb1-24"><a href="#cb1-24"></a>      <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-25"><a href="#cb1-25"></a>    } <span class="cf">else</span> {</span>
<span id="cb1-26"><a href="#cb1-26"></a>      fibonacci(x <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> fibonacci(x <span class="op">-</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb1-27"><a href="#cb1-27"></a>    }</span>
<span id="cb1-28"><a href="#cb1-28"></a>  }</span>
<span id="cb1-29"><a href="#cb1-29"></a>}<span class="op">;</span></span>
<span id="cb1-30"><a href="#cb1-30"></a></span>
<span id="cb1-31"><a href="#cb1-31"></a><span class="kw">let</span> map <span class="op">=</span> fn(arr<span class="op">,</span> f) {</span>
<span id="cb1-32"><a href="#cb1-32"></a>  <span class="kw">let</span> iter <span class="op">=</span> fn(arr<span class="op">,</span> accumulated) {</span>
<span id="cb1-33"><a href="#cb1-33"></a>    <span class="cf">if</span> (len(arr) <span class="op">==</span> <span class="dv">0</span>) {</span>
<span id="cb1-34"><a href="#cb1-34"></a>      accumulated</span>
<span id="cb1-35"><a href="#cb1-35"></a>    } <span class="cf">else</span> {</span>
<span id="cb1-36"><a href="#cb1-36"></a>      iter(rest(arr)<span class="op">,</span> push(accumulated<span class="op">,</span> f(first(arr))))<span class="op">;</span></span>
<span id="cb1-37"><a href="#cb1-37"></a>    }</span>
<span id="cb1-38"><a href="#cb1-38"></a>  }<span class="op">;</span></span>
<span id="cb1-39"><a href="#cb1-39"></a></span>
<span id="cb1-40"><a href="#cb1-40"></a>  iter(arr<span class="op">,</span> [])<span class="op">;</span></span>
<span id="cb1-41"><a href="#cb1-41"></a>}<span class="op">;</span></span>
<span id="cb1-42"><a href="#cb1-42"></a></span>
<span id="cb1-43"><a href="#cb1-43"></a><span class="kw">let</span> numbers <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">4</span> <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span> <span class="op">*</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">12</span> <span class="op">/</span> <span class="dv">2</span>]<span class="op">;</span></span>
<span id="cb1-44"><a href="#cb1-44"></a>map(numbers<span class="op">,</span> fibonacci)<span class="op">;</span></span>
<span id="cb1-45"><a href="#cb1-45"></a><span class="co">// =&gt; returns: [1, 1, 2, 3, 5, 8]</span></span></code></pre></div>
<p>Translated into a list of features, we can say that Monkey supports:</p>
<ul>
<li>integers</li>
<li>booleans</li>
<li>strings</li>
<li>arrays</li>
<li>hashes</li>
<li>prefix-, infix- and index operators</li>
<li>conditionals</li>
<li>global and local bindings</li>
<li>first-class functions</li>
<li>return statements</li>
<li>closures</li>
</ul>
<p>Quite a list, huh? And we built all of these into our Monkey interpreter ourselves and – most importantly! – we built them from scratch, without the use of any third-party tools or libraries.</p>
<p>We started out by building the lexer that turns strings entered into the REPL into tokens. The lexer is defined in the <code>lexer</code> package and the tokens it generates can be found in the <code>token</code> package.</p>
<p>After that, we built the parser, a top-down recursive-descent parser (often called a Pratt parser) that turns the tokens into an abstract syntax tree, which is abbreviated to AST. The nodes of the AST are defined in the <code>ast</code> package and the parser itself can be found in the <code>parser</code> package.</p>
<p>After it went through the parser, a Monkey program is then represented in memory as a tree and the next step is to evaluate it. In order to do that we built an evaluator. That’s another name for a function called <code>Eval</code>, defined in the <code>evaluator</code> package. <code>Eval</code> recursively walks down the AST and evaluates it, using the object system we defined in the <code>object</code> package to produce values. It would, for example, turn an AST node representing <code>1 + 2</code> into an <code>object.Integer{Value: 3}</code>. With that, the life cycle of Monkey code would be complete and the result printed to the REPL.</p>
<p>This chain of transformations – from strings to tokens, from tokens to a tree and from a tree to <code>object.Object</code> – is visible from start to end in the main loop of the Monkey REPL we built:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">// repl/repl.go</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">package</span> repl</span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="kw">func</span> Start(in io.Reader, out io.Writer) {</span>
<span id="cb2-6"><a href="#cb2-6"></a>    scanner := bufio.NewScanner(in)</span>
<span id="cb2-7"><a href="#cb2-7"></a>    env := object.NewEnvironment()</span>
<span id="cb2-8"><a href="#cb2-8"></a></span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="kw">for</span> {</span>
<span id="cb2-10"><a href="#cb2-10"></a>        fmt.Fprintf(out, PROMPT)</span>
<span id="cb2-11"><a href="#cb2-11"></a>        scanned := scanner.Scan()</span>
<span id="cb2-12"><a href="#cb2-12"></a>        <span class="kw">if</span> !scanned {</span>
<span id="cb2-13"><a href="#cb2-13"></a>            <span class="kw">return</span></span>
<span id="cb2-14"><a href="#cb2-14"></a>        }</span>
<span id="cb2-15"><a href="#cb2-15"></a></span>
<span id="cb2-16"><a href="#cb2-16"></a>        line := scanner.Text()</span>
<span id="cb2-17"><a href="#cb2-17"></a>        l := lexer.New(line)</span>
<span id="cb2-18"><a href="#cb2-18"></a>        p := parser.New(l)</span>
<span id="cb2-19"><a href="#cb2-19"></a></span>
<span id="cb2-20"><a href="#cb2-20"></a>        program := p.ParseProgram()</span>
<span id="cb2-21"><a href="#cb2-21"></a>        <span class="kw">if</span> <span class="bu">len</span>(p.Errors()) != <span class="dv">0</span> {</span>
<span id="cb2-22"><a href="#cb2-22"></a>            printParserErrors(out, p.Errors())</span>
<span id="cb2-23"><a href="#cb2-23"></a>            <span class="kw">continue</span></span>
<span id="cb2-24"><a href="#cb2-24"></a>        }</span>
<span id="cb2-25"><a href="#cb2-25"></a></span>
<span id="cb2-26"><a href="#cb2-26"></a>        evaluated := evaluator.Eval(program, env)</span>
<span id="cb2-27"><a href="#cb2-27"></a>        <span class="kw">if</span> evaluated != <span class="ot">nil</span> {</span>
<span id="cb2-28"><a href="#cb2-28"></a>            io.WriteString(out, evaluated.Inspect())</span>
<span id="cb2-29"><a href="#cb2-29"></a>            io.WriteString(out, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb2-30"><a href="#cb2-30"></a>        }</span>
<span id="cb2-31"><a href="#cb2-31"></a>    }</span>
<span id="cb2-32"><a href="#cb2-32"></a>}</span></code></pre></div>
<p>That’s where we left Monkey at the end of the previous book.</p>
<p>And then, half a year later, the <a href="https://interpreterbook.com/lost"><em>The Lost Chapter: A Macro System For Monkey</em></a> resurfaced and told readers how to get Monkey to program itself with macros. In this book, though, <em>The Lost Chapter</em> and its macro system won’t make an appearance. In fact, it’s as if the <em>The Lost Chapter</em> was never found and we’re back at the end of <em>Writing An Interpreter In Go</em>. That’s good, though, because we did a great job implementing our interpreter.</p>
<p>Monkey worked exactly like we wanted it to and its implementation was easy to understand and to extend. So one question naturally arises at the beginning of this second book: why change any of it? Why not leave Monkey as is?</p>
<p>Because we’re here to learn and Monkey still has a lot to teach us. One of the goals of <em>Writing An Interpreter In Go</em> was to learn more about the implementation of the programming languages we’re working with on a daily basis. And we did. A lot of these “real world” languages did start out with implementations really similar to Monkey’s. And what we learned by building Monkey helps us to understand the fundamentals of their implementation and their origins.</p>
<p>But languages grow and mature. In the face of production workloads and an increased demand for performance and language features, the implementation and architecture of a language often change. One side effect of these changes is that the implementation loses its similarity to Monkey, which wasn’t built with performance and production usage in mind at all.</p>
<p>This gap between fully-grown languages and Monkey is one of the biggest drawbacks of our Monkey implementation: its architecture is as removed from the architecture of actual real-world languages as a soapbox car is from a Formula 1 car. It has four wheels and a seat, sure, it can help to learn the fundamentals of steering, yes, but the fact that it’s missing an engine is hard to ignore.</p>
<p>In this book we’re going to reduce this gap between Monkey and <em>real</em> languages. We’ll put something real under the hood of our Monkey soapbox car.</p>
<h3 id="the-future">The Future</h3>
<p>We’re going to turn our tree-walking and on-the-fly-evaluating interpreter into a bytecode compiler and a virtual machine that executes the bytecode.</p>
<p>That’s not only immensely fun to build but also one of the most common interpreter architectures out there. Ruby, Lua, Python, Perl, Guile, different JavaScript implementations and many more programming languages are built this way. Even the mighty Java Virtual Machine interprets bytecode. Bytecode compilers and virtual machines are everywhere – and for good reason.</p>
<p>Besides providing a new layer of abstraction – the bytecode that’s passed from the compiler to the virtual machine – that makes the system more modular, the main appeal of this architecture lies in its performance. Bytecode interpreters are fast.</p>
<p>Want numbers? At the end of this book we’ll have an implementation of Monkey that’s three times faster than its predecessor from the first book:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb3-1"><a href="#cb3-1"></a>$ ./monkey-fibonacci -engine=eval</span>
<span id="cb3-2"><a href="#cb3-2"></a>engine=eval, result=9227465, duration=27.204277379s</span>
<span id="cb3-3"><a href="#cb3-3"></a>$ ./monkey-fibonacci -engine=vm</span>
<span id="cb3-4"><a href="#cb3-4"></a>engine=vm, result=9227465, duration=8.876222455s</span></code></pre></div>
<p>Yes, three times faster – without low-level tweaking or extensive optimizations. Sound good? Ready to write some code? Perfect. Let’s get the practicalities out of the way and we can start.</p>
<h2 id="use-this-book">Use This Book</h2>
<p>Like the first one, this book comes with only a tiny number of instructions: you best read it from start to finish and you’ll get the most out of it if you follow along by reading, typing out and playing around with the presented code. That’s it.</p>
<p>These books are <em>practical</em> books. They are about writing code and building something. If you want to immerse yourself in the theory of programming-language construction you’re better off by choosing one of the canonical textbooks. That’s not to say that you won’t learn anything here, no. I’ll try my best to guide you along and explain what everything is and how the pieces fit together. It just won’t be as academic as a textbook on compilers. But that’s exactly how I intend it to be.</p>
<p>This book, just like its predecessor, comes with a folder called <code>code</code>. If your copy of the book came without it, you can download it here:</p>
<p><a href="https://compilerbook.com/wacig_code_1.2.zip">https://compilerbook.com/wacig_code_1.2.zip</a></p>
<p>In this folder you’ll find subfolders for each of the chapters in which we write code. Each contains the codebase as it stands at the end of the corresponding chapter, which can be helpful if you get stuck while following along.</p>
<p>The subfolder <code>00</code>, however, is special and also what differentiates this book from the first one: we don’t start with a clean slate, but build upon the codebase of the previous book. It doesn’t correspond to a chapter of <em>this</em> book, but contains the complete codebase as we left it at the end of the previous one. That also means it doesn’t include the macro system from <em>The Lost Chapter</em>, but if you’re a fan of the macros, it shouldn’t be too hard to keep the macro-expansion step around.</p>
<p>The code contained in these folders is the focus of this book. I try to show most of it, but sometimes I’ll only refer to something located in the codebase, without actually showing it. Why? Most of the time because it’s a repetition of something we’ve seen before and showing it would take up too much space.</p>
<p>So much about the content of the <code>code</code> folder. Now, let’s talk about tools because I have some good news: you don’t need many. In fact, a text editor and an installation of the Go programming language should be enough. Which version of Go? At least <strong>Go 1.10</strong>, because that’s what I’m using at the time of writing and because we will use a tiny number of features that were only introduced in Go 1.8 and 1.9.</p>
<p>If you’re <em>not</em> using <strong>Go &gt;=1.13</strong>, then I also recommend using <a href="http://direnv.net/">direnv</a> to work with the <code>code</code> folder. <em>direnv</em> can change the environment of your shell according to an <code>.envrc</code> file. Whenever you <code>cd</code> into a folder, <em>direnv</em> checks whether the folder contains an <code>.envrc</code> file and executes it. Each subfolder in <code>code</code> contains such an <code>.envrc</code> file that sets the <code>GOPATH</code> correctly for this subfolder. That allows us to just <code>cd</code> into a subfolder and execute the code really easily.</p>
<p>But if you <em>are</em> on <strong>Go &gt;=1.13</strong> you shouldn’t need to set a <code>GOPATH</code>, since the code folders contain <code>go.mod</code> files, making them work with the <code>go</code> command out of the box.</p>
<p>And that’s all there is to say about the practicalities of this book. Read it, code along and, most importantly, have fun.</p>
<h1 id="compilers-virtual-machines">Compilers &amp; Virtual Machines</h1>
<p>For most programmers the word “compiler” has an intimidating ring to it. And even if you’re not intimidated by it, you can’t deny that compilers and what they do is surrounded by an air of mystery and amazement. They produce machine code seemingly nobody mortal can read or write. They do magic optimizations that <em>somehow</em> make code run faster. They can take a long time to run – minutes or even tens of minutes. If the rumours are true they sometimes even run for hours. If it takes <em>that</em> long, what they’re doing must be extraordinary.</p>
<p>Speaking of rumours: it’s said that compilers are incredibly huge and incredibly complex. In fact, they can often be found listed among the most complex software projects to ever exist – with the claims backed up by numbers. Here’s a taste: the LLVM &amp; Clang projects currently consist of around 3 million lines of code. The GNU Compiler Collection, GCC, is even bigger. 15 million lines of code.</p>
<p>There are not a lot of people that look at these numbers, open their text editor and say “you know what? Let’s build one!” They certainly do not evoke the sense that one could write a compiler in an afternoon.</p>
<!-- ./ascii_drawings/01/compilers_virtual_machines.monopic -->
<figure>
<img src="./images/01/compilers_virtual_machines.svg" style="width:90.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>Virtual machines, too, are largely understood to be mystical creatures, roaming through the dark lower layers of software development, seldom seen in light and even less understood. They, too, attract their fair share of rumours and speculations. Some say that virtual machines have something to do with compilers. Others insist that their programming language is, in fact, such a virtual machine. Another group claims that virtual machines allow them to run an operating system inside another operating system.</p>
<p>It doesn’t help that all of it is true.</p>
<p>But here’s the thing. At their core, compilers and virtual machines are ideas – patterns – just like “interpreter” or “web server” are ideas that can have multiple implementations, ranging from tiny to massive. Being intimidated by them after looking at a project like GCC makes as much sense as giving up on building a website after looking at GitHub.</p>
<p>Sure, it’s not a small task to build a compiler for a virtual machine. But it’s also not as insurmountable as reputation suggests. And once we have a better understanding of these core ideas, of what a compiler and a virtual machine essentially are, you’ll see that you can, in fact, build a compiler in an afternoon.</p>
<p>The first step towards that is finding out what “compiling” means.</p>
<h2 id="compilers">Compilers</h2>
<p>If I’d ask you to name a compiler, you’d probably and without missing a beat would give me a name like GCC, or Clang, or the Go compiler. In any case, it would most certainly be a compiler for a programming language. Chances are that it’s a compiler that produces executables. I would, too, because that’s just what we associate with the word “compiler”.</p>
<p>But compilers come in all shapes and sizes and compile all kinds of things, not just programming languages, including regular expressions, database queries and even HTML templates. I bet you use one or two compilers every day without even realizing it. That’s because the definition of “compiler” itself is actually quite loose, much more so than one would expect. Here is <a href="https://en.wikipedia.org/wiki/Compiler">Wikipedia’s version</a>:</p>
<blockquote>
<p>A compiler is computer software that transforms computer code written in one programming language (the source language) into another computer language (the target language). Compilers are a type of translator that support digital devices, primarily computers. The name compiler is primarily used for programs that translate source code from a high-level programming language to a lower level language (e.g., assembly language, object code, or machine code) to create an executable program.</p>
</blockquote>
<p>Compilers are translators. That’s vague. And a compiler that translates high-level languages to produce executables is just one special type of compiler? Sounds counter-intuitive, doesn’t it? You’d think that producing executables <em>is just what a compiler does</em>: that’s what GCC does, that’s what Clang does, that’s what the Go compiler does. Shouldn’t that be the first line of the definition? How can this be non-essential?</p>
<p>The solution to this riddle is another one: what’s an executable if not source code in a language the computer can natively understand? Hence, “compiling to native code” is the same as compiling to machine code. Yes, really, producing executables is just one variation of “translating source code”.</p>
<p>You see, compilers are fundamentally about translation, because translation is how they <em>implement a programming language</em>.</p>
<p>Let’s make sense of that sentence by taking a step back here. Programming means giving instructions to a computer. We, the programmers, write these instructions in programming languages the computer can understand. There is no point in using any other language. Now, <em>implementing</em> a programming language means making the computer understand it. There are two ways to do that: either interpret the language for the computer on-the-fly or translate it into another language, one the computer already understands.</p>
<p>It’s exactly like we, as humans, can help a friend understand a language she doesn’t speak. We can either listen, translate in our head and repeat the translation to her, or we can write the translation down so she can read and understand it herself. We can either act as an interpreter or as a compiler.</p>
<p>This might sound like interpreters and compilers are opposites. But while their approach is different, they share a lot of things in their construction. They both have a frontend that reads in source code written in the source language and turns it into a data structure. In both, compiler and interpreter, this frontend is usually made up of a lexer and a parser that together generate a syntax tree. So here, in the front part, they have a lot of similarities. After that, when they both traverse the AST, that’s when their paths diverge.</p>
<p>Since we already built an interpreter we know what it does when traversing the AST: it evaluates it. That is, it executes the instructions encoded in the tree. If a node in the tree represents the source language’s statement <code>puts("Hello World!")</code>, then the interpreter would print “Hello World!” when evaluating the node.</p>
<p>A compiler, on the other hand, wouldn’t print anything. Instead, it would generate source code in another language, called the target language. The source code would contain the target language’s equivalent of the source language’s <code>puts("Hello World!")</code>. The resulting code could then be executed by the computer and <code>"Hello World!"</code> would appear on the screen.</p>
<p>This is where things get really interesting. In which target language does the compiler generate source code? Which language does the computer understand? And how does the compiler generate code in this language? As text, or in a binary format? In a file, or in memory? But much more importantly: what exactly does it generate in this target language? What if the target language doesn’t have an equivalent of <code>puts</code>? What should the compiler generate instead?</p>
<p>Generally speaking, we have to give the same answer to every one of these questions. Software development’s number one answer, the only hard, capital-T Truth in programming: “it depends.”</p>
<p>Sorry to let you down there, but the answers to these questions depend on a multitude of variables and requirements: the source language, the architecture of the machine that executes the target language, how the output is going to be used (is it executed directly? compiled again? interpreted?), how fast the output needs to run, how fast the compiler itself needs to run, how big the generated source code can be, how much memory the compiler is allowed to use, how much memory the resulting program can use, and how…</p>
<p>The variety between compilers is so high that we can’t make a lot of universal statements about their architecture. That being said, we can ignore the details for a minute now and sketch out the architecture of something like the archetype of a compiler:</p>
<!-- ./ascii_drawings/01/compiler_archetype.monopic -->
<figure>
<img src="./images/01/compiler_archetype.svg" style="width:40.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>This shows the life cycle of source code that’s being translated to machine code. Here’s what happens.</p>
<p>First, the source code is tokenized and parsed by the lexer and the parser. We’re familiar with this part from our interpreter. It’s called the frontend. The source code is turned from text into an AST.</p>
<p>After that a component called the “optimizer” (or sometimes also called “compiler” – I know, I know, …) might translate the AST into another internal representation (IR). This additional IR might just be another syntax tree, or maybe a binary format, or even a textual format. The reasons for this additional translation into another IR are manifold, but the major one is that the IR might lend itself better to optimizations and translation into the target language than the AST would.</p>
<p>This new IR then goes through an optimization phase: dead code is eliminated, simple arithmetic is pre-calculated, code that doesn’t need to be in the body of a loop is moved out of it, … A ton of possible optimizations exists.</p>
<p>Finally, the code generator, also called the backend, generates the code in the target language. This is where the compilation happens. Here’s where the code hits the file system, so to say. After that, we can execute the result and see the computer perform what we instructed it to in the original source code.</p>
<p>This is how the <em>simplest</em> compilers work. And even here a thousand variations are possible. For example, the optimizer could do multiple “passes” over the IR, meaning that it traverses the IR multiple times and each time does a different optimization: removing dead code in one pass, inlining function calls in another one, for example. Or maybe the compiler doesn’t do optimizations on the IR at all, but only on the source code in the target language. Or only on the AST, or on both. Or it doesn’t do any optimizations ever. Or maybe it doesn’t even have another IR besides the AST. And maybe it doesn’t output machine code, but assembly language, or another high-level language. Or it has multiple backends that can generate machine code for multiple architectures. It all depends on the specific use case.</p>
<p>And then again, a compiler doesn’t even have to be a tool you run on the command line, that reads in source code and outputs code in a file, like <code>gcc</code> or <code>go</code>. It can just as well be a single function that takes in an AST and returns a string. That’s also a compiler. A compiler can be written in a few hundred lines of code or have millions of them.</p>
<p>But underlying all of these lines of code is the fundamental idea of translation. Compilers take in source code in one language and generate source code in another one. The rest – again – “depends”, with the majority on the target language. What the target language is capable of and by which machine it can be executed shapes the design of a compiler like nothing else.</p>
<p>Now, what if we didn’t have to <em>choose</em> a target language, but could invent our own? And what if we don’t leave it at that and also dream up the machine that executes this language?</p>
<h2 id="virtual-and-real-machines">Virtual and Real Machines</h2>
<p>You probably associate “virtual machine” with software like VMWare or Virtualbox. These are programs that emulate a computer, including a disk drive, hard drive, graphics card, etc. They allow you to, for example, run a different operating system inside this emulated computer. Yes, these are virtual machines. But that’s not what we’re here to talk about. That’s the <em>other</em> type of virtual machine.</p>
<p>What we are going to talk about (and later build) are virtual machines that are used to implement programming languages. Sometimes they consist of just a few functions, other times they make up a few modules and on occasion they’re a collection of classes and objects. It’s hard to pin their shape down. But that doesn’t matter. What’s important is this: they don’t emulate an existing machine. They <em>are</em> the machine.</p>
<p>The “virtual” is due to the fact they only exist in software, not in hardware, and are thus purely abstract constructs. The “machine” describes their behaviour. These software constructs act like a machine. And not just any machine, no. They mimic the behaviour of their hardware equivalent: computers.</p>
<p>That means, in order to understand and build a virtual machine, we need to learn how a real machine works.</p>
<h3 id="real-machines">Real Machines</h3>
<p>“So, how does a computer work?”</p>
<p>What might sound like an intimidating question can actually be answered in five minutes and with a piece of paper. I don’t know how fast you can read and I’m certain I can’t show you what I draw on a scrap of paper, but let me try anyway.</p>
<p>Nearly every computer in your life is built according to the <a href="https://en.wikipedia.org/wiki/Von_Neumann_architecture">Von Neumann architecture</a>, which describes a way to build a fully-functioning computer with a surprisingly tiny number of parts.</p>
<p>In Von Neumann’s model a computer has two central parts: a processing unit, which contains an arithmetic logic unit (ALU) and multiple processor registers, and a control unit with an instruction register and a program counter. Together they’re called the central processing unit, often shortened to CPU. Besides that, the computer also contains memory (RAM), mass storage (think: hard drive) and input/output devices (keyboard and display).</p>
<p>CPU, memory, mass storage and I/O. Here’s a rough sketch of such a computer:</p>
<!-- ./ascii_drawings/01/VonNeumannArchitecture.monopic -->
<figure>
<img src="./images/01/von_neumann_architecture.svg" style="width:80.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>As soon as the computer is turned on, the CPU:</p>
<ol type="1">
<li><strong>Fetches an instruction from memory</strong>. The program counter tells the CPU where in memory it can find the next instruction.</li>
<li><strong>Decodes the instruction</strong>. To identify which operation should be executed.</li>
<li><strong>Executes the instruction</strong>. This can mean either modifying the contents of its registers, or transferring data from the registers to memory, or moving data around in memory, or generating output, or reading input…</li>
</ol>
<p>… and then <em>goto 1</em> again.</p>
<p>These three steps are called the <strong>fetch-decode-execute cycle</strong>, or instruction cycle. Yes, that’s the cycle known from sentences like “the clock speed of a computer is expressed in cycles per second, e.g. 500 MHz” or “we’re wasting CPU cycles here”.</p>
<p>That was a brief and easy to understand description of how a computer works. But we can make it even easier for us. In this book we don’t care about mass storage components and only tangentially about the I/O mechanisms. What we’re interested in is the interplay between CPU and memory. That means we can make that our focus and safely ignore hard drives and displays.</p>
<p>We start our investigation with this question: how does the CPU address different parts of memory? Or, in other words: how does the CPU know where to store and retrieve things that are located in memory?</p>
<p>We’re given a first hint by how the CPU fetches instructions. The program counter, a part of the CPU, keeps track of where to fetch the next instruction. And “counter” is to be taken quite literally here: the computer simply uses numbers to address different parts of memory. Yes, numbers.</p>
<p>At this point I’m tempted to write “just think of memory as a huge array”, but I’m scared of someone hitting me over the head with a heavy, leather-bound tome called “Things about memory that are <em>absolutely and without any doubt not like an array, you doofus</em>”, so I won’t. But, yes, just like we, as programmers, use numbers as indexes to access single elements in an array, the CPU uses numbers as addresses when accessing data in memory.</p>
<p>Instead of “array elements” computer memory is segmented into <a href="https://en.wikipedia.org/wiki/Word_(computer_architecture)">“words”</a>. Now what’s a “word”? It’s the smallest addressable region of memory. It’s the base unit when accessing memory. The size of a word varies and depends on the CPU type among other things. In the computers you and I use, however, 32 and 64 bits word sizes are the standard.</p>
<p>Let’s say we have a fictional computer with a word size of 8 bits and 13 bytes of memory. One word in memory can hold one ASCII character and if we store the string <code>Hello, World!</code> to memory it looks like this:</p>
<!-- ./ascii_drawings/01/Memory.monopic -->
<figure>
<img src="./images/01/memory.svg" alt="" /><figcaption> </figcaption>
</figure>
<p>The letter “H” has the memory address 0, “e” has 1, the first “l” has 2, “W” has 7 and so on. We could access every single letter of the string <code>Hello, World!</code> by using the memory addresses 0 to 12. “Hey CPU, fetch the word at memory address 4” would result in the CPU fetching the letter “o”. Straightforward, right? I know what you’re thinking right now and, yes, if we take such a number – a memory address – and save it to another place in memory, we create a pointer.</p>
<p>That’s the <em>basic</em> idea behind addressing data in memory and how the CPU knows where to fetch and store data. As always, though, the real world is a mess.</p>
<p>As I already mentioned, the size of a word differs between different computers. Sometimes it’s 8 bits, sometimes 16, 24, 32, or 64 bits. Sometimes the word size used by the CPU is independent of the address size. And if that’s not enough to deal with: some computers do something entirely different and use <a href="https://en.wikipedia.org/wiki/Byte_addressing">byte-addressing</a> instead of the just described word-addressing.</p>
<p>And if you’re using word-addressing and want to address a single byte (which is not that uncommon) you not only have to deal with different word sizes but also work with offsets. That in turn is expensive and has to be optimized.</p>
<p>On top of that: the idea that we can simply tell the CPU where to store and retrieve data in memory is something like a fairytale. It’s correct on a conceptual level and helpful when learning, but memory access today is abstracted away and sits behind layers and layers of security and performance optimizations. Memory is not the wild west anymore – we can’t just go around and access any memory location we want. Security rules and a mechanism called virtual memory try their best to stop that from happening.</p>
<p>Let me stop right here, though, before we take a huge detour and end up talking about the inner workings of virtual memory. That’s not why we’re here. What you can take from this excursion is that there’s more to memory access today than passing a number to the CPU. Not only are there security rules in place, but in the last few decades of computing emerged a set of less strict conventions around the use of memory.</p>
<p>One novel aspect of the Von Neumann architecture was that a computer’s memory contains not only data, but also <em>programs</em>, which are the CPU instructions that make up a program. To our programmer ears the idea of mixing data and code sounds like a recipe for tears. And to the ears of programmers a few generations ago, it probably sounded like that, too. Because what they did was to establish conventions around the use of memory that stopped that from happening.</p>
<p>While programs are stored in the same memory as any other data, they’re most often not stored in the same locations. Specific areas of memory are used to store specific things. That’s not only by convention, but also dictated by the operating system, the CPU and the rest of the computer architecture.</p>
<p>“Dumb” data, as in “the contents of a text file” or “the response of a HTTP request”, goes in one region of memory. The instructions that make up a program are stored and accessed in another region, where the CPU can easily fetch them. Another region holds the static data that’s used by a program and yet another region is empty and uninitialized, but reserved so that it can be used by a program once it’s running. The instructions belonging to the operating system kernel have their own special region in memory.</p>
<p>By the way: while programs and “dumb data” may reside in different memory locations, again, the important thing here is that they <em>are</em> both stored in the same memory. Saying “data and programs are both stored in memory” makes it sound as if they’re distinct, when in fact programs – made up of instructions – are just data too. Instructions only become instructions once the CPU fetches them from memory, decodes them, and finds out that they are, in fact, proper instructions and then executes them. If the CPU attempts to decode data that’s not a valid instruction, well, then the consequences will depend on how the CPU was designed. It could trigger an event and give the program a chance to recover or it could just stop.</p>
<p>For us, the most interesting thing about this is one particular memory region. It’s the memory region that holds the stack. Yes, <em>the</em> stack. Drum roll, fanfare, spot light, deep voice: <em>The Stack</em>. You might have heard of him. “Stack overflow” is probably his most famous work, followed by the less popular but equally respected “stack trace”.</p>
<p>So, what is it? It’s a region in memory where data is managed in a last-in-first-out (LIFO) manner. The data in it grows and shrinks, you push elements on to the stack and later pop them off. Just like the stack data structure. But unlike this generic data structure, <em>the stack</em> is focused on one purpose: it’s used to implement the <a href="https://en.wikipedia.org/wiki/Call_stack"><em>call stack</em></a>.</p>
<p>Yes, let’s stop right there; it <em>is</em> confusing. “Stack”, “the stack”, “stack data structure”, “call stack” – not really self-explanatory, is it? It doesn’t help that these names are often used interchangeably and thrown around and mixed together. But, thankfully, if we are careful with the names and pay attention to the “why” behind them, things become much clearer. So let’s try this again and do this step by step.</p>
<p>We have a memory region where the CPU accesses and stores data in a LIFO manner. It does this in order to implement a specialized version of <em>a stack</em>, called <em>a call stack</em>.</p>
<p>Why does it need <em>a call stack</em>? Because the CPU (or maybe: the programmer that wants the CPU to work as intended) needs to keep track of certain information in order to execute a program. The <em>call stack</em> helps with that. What information? First and foremost: which function is currently being executed and which instruction to execute next, once the current function is fully executed. This piece of information, which instruction to fetch after the current function, is called the <em>return address</em>. It’s where the CPU <em>returns to</em> after executing the current function. Without this the CPU would just increment the program counter and execute the instruction at the next higher address in memory. And that might be the absolute opposite of what should happen. Instructions are not laid out in memory in the order of execution, next to each other. Imagine what would happen if all the return statements in your Go code would vanish – <em>that</em>’s why the CPU needs to keep track of the return addresses. The <em>call stack</em> also helps to save execution-relevant data that’s local to functions: the arguments of the function call and the local variables only used in the function.</p>
<p>The return address, arguments and local variables – we could theoretically save this information in any other accessible part of memory, in any way we see fit. But, as it turns out, using <em>a stack</em> for this is perfect, because function calls are often nested. When entering a function, the data is pushed on to the stack. And while executing the current function, there is no need to access the local data of the outer, calling function. It’s enough to just access the top part of the stack, so to say. And once the current function returns, the local data is simply popped off – there’s no need for it anymore. That leaves us with the local data of the outer function on the top of the stack. Neat, right?</p>
<p>So that’s why we need the <em>call stack</em> and why it’s implemented as <em>a stack</em>. The only question now is: why the notorious name? Why is it <em>the Stack</em> and not just “well, I guess, yeah, it’s a stack, huh”? Because using this region of memory to implement <em>a call stack</em> is a convention so strongly held and widespread that by now it’s been cast into hardware. Certain CPUs support instructions solely for pushing and popping things on the stack. Every program that’s running on them makes use of <em>this memory region</em> in <em>this way</em> to implement <em>this mechanism</em>. There is no way around it. That’s why it’s <em>the stack</em> and not just any stack.</p>
<p>But keep in mind that the concept of <em>a call stack</em> is just that, a concept. It’s not bound to a specific implementation with a specific memory region. One could implement a call stack in any other place in memory – but without hardware or operating-system support then. In fact, that’s what we’re going to do. We’re going to implement our own call stack, a virtual call stack. But before we do that and switch over from the physical to the virtual, we need to look at one more concept to be fully prepared.</p>
<p>Now that you know how <em>the stack</em> works, you can imagine how often the CPU needs to access this region of memory while executing a program. It’s a lot. That means that the speed with which the CPU can access memory puts a limit on how fast it can execute programs. And while memory access <em>is</em> fast (a CPU can access main memory around a million times while you blink an eye) it’s not instant and still has a cost.</p>
<p>That’s why computers have another place where they can store data: processor registers. Registers are part of the CPU and accessing them is <em>much</em> faster than accessing the main memory. Naturally, one might ask, why not store everything in registers? Because there are only a few of them and they can’t hold as much data as main memory, typically only one word per register. A CPU of the x86-64 architecture, for example, has 16 general purpose registers, each holding 64 bits of data.</p>
<p>Registers are used to store data that’s small but frequently accessed. The memory address pointing to the top of <em>the stack</em>, for example, is commonly stored in a register – “commonly” being an understatement here. This specific usage of a register is so prevalent that most CPUs have a single, designated register just for storing this pointer, the so called <em>stack pointer</em>. The operands and the results of certain CPU instructions may also be stored in registers. If a CPU would need to add two numbers, both of them would be stored in registers and the result of the addition would end up in one too. That’s not all, though. There are many more use cases for registers. Here’s another one: if there’s a large piece of data frequently being accessed in a program it makes sense to store the address of it to a register so it can be accessed by the CPU really fast. The most important one for us, though, is the <em>stack pointer</em>. We’ll meet that one again soon.</p>
<p>And now… take a deep breath, lean back and relax, because: that’s it! Now that we’ve mentioned registers and know what a stack pointer is, we’ve covered everything we need to know about how real machines work. It’s time for us to go abstract, from the physical to the virtual.</p>
<h3 id="what-is-a-virtual-machine">What Is a Virtual Machine?</h3>
<p>Let me get straight to the point: a virtual machine is a computer built with software. It’s a software entity that mimics how a computer works. I’ll admit, “software entity” doesn’t say much, but I used this phrase on purpose, to drive home one point: a virtual machine can be anything. A function, a struct, an object, a module, or even a whole program. What matters is what it does.</p>
<p>A virtual machine has a run loop that goes through the fetch-decode-execute cycle, just like a computer. It has a program counter; it fetches instructions; it decodes and executes them. It also has a stack, just like a real computer. Sometimes it has a call stack and sometimes even registers. All built in software.</p>
<p>Let me put code where my mouth is. Here is a virtual machine in 50 lines of JavaScript:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">let</span> virtualMachine <span class="op">=</span> <span class="kw">function</span>(program) {</span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span class="kw">let</span> programCounter <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>  <span class="kw">let</span> stack <span class="op">=</span> []<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>  <span class="kw">let</span> stackPointer <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a>  <span class="cf">while</span> (programCounter <span class="op">&lt;</span> program<span class="op">.</span><span class="at">length</span>) {</span>
<span id="cb4-7"><a href="#cb4-7"></a>    <span class="kw">let</span> currentInstruction <span class="op">=</span> program[programCounter]<span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8"></a></span>
<span id="cb4-9"><a href="#cb4-9"></a>    <span class="cf">switch</span> (currentInstruction) {</span>
<span id="cb4-10"><a href="#cb4-10"></a>      <span class="cf">case</span> <span class="dt">PUSH</span><span class="op">:</span></span>
<span id="cb4-11"><a href="#cb4-11"></a>        stack[stackPointer] <span class="op">=</span> program[programCounter<span class="op">+</span><span class="dv">1</span>]<span class="op">;</span></span>
<span id="cb4-12"><a href="#cb4-12"></a>        stackPointer<span class="op">++;</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>        programCounter<span class="op">++;</span></span>
<span id="cb4-14"><a href="#cb4-14"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb4-15"><a href="#cb4-15"></a></span>
<span id="cb4-16"><a href="#cb4-16"></a>      <span class="cf">case</span> <span class="dt">ADD</span><span class="op">:</span></span>
<span id="cb4-17"><a href="#cb4-17"></a>        right <span class="op">=</span> stack[stackPointer<span class="dv">-1</span>]</span>
<span id="cb4-18"><a href="#cb4-18"></a>        stackPointer<span class="op">--;</span></span>
<span id="cb4-19"><a href="#cb4-19"></a>        left <span class="op">=</span> stack[stackPointer<span class="dv">-1</span>]</span>
<span id="cb4-20"><a href="#cb4-20"></a>        stackPointer<span class="op">--;</span></span>
<span id="cb4-21"><a href="#cb4-21"></a></span>
<span id="cb4-22"><a href="#cb4-22"></a>        stack[stackPointer] <span class="op">=</span> left <span class="op">+</span> right<span class="op">;</span></span>
<span id="cb4-23"><a href="#cb4-23"></a>        stackPointer<span class="op">++;</span></span>
<span id="cb4-24"><a href="#cb4-24"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb4-25"><a href="#cb4-25"></a></span>
<span id="cb4-26"><a href="#cb4-26"></a>      <span class="cf">case</span> <span class="dt">MINUS</span><span class="op">:</span></span>
<span id="cb4-27"><a href="#cb4-27"></a>        right <span class="op">=</span> stack[stackPointer<span class="dv">-1</span>]</span>
<span id="cb4-28"><a href="#cb4-28"></a>        stackPointer<span class="op">--;</span></span>
<span id="cb4-29"><a href="#cb4-29"></a>        left <span class="op">=</span> stack[stackPointer<span class="dv">-1</span>]</span>
<span id="cb4-30"><a href="#cb4-30"></a>        stackPointer<span class="op">--;</span></span>
<span id="cb4-31"><a href="#cb4-31"></a></span>
<span id="cb4-32"><a href="#cb4-32"></a>        stack[stackPointer] <span class="op">=</span> left <span class="op">-</span> right<span class="op">;</span></span>
<span id="cb4-33"><a href="#cb4-33"></a>        stackPointer<span class="op">++;</span></span>
<span id="cb4-34"><a href="#cb4-34"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb4-35"><a href="#cb4-35"></a>    }</span>
<span id="cb4-36"><a href="#cb4-36"></a></span>
<span id="cb4-37"><a href="#cb4-37"></a>    programCounter<span class="op">++;</span></span>
<span id="cb4-38"><a href="#cb4-38"></a>  }</span>
<span id="cb4-39"><a href="#cb4-39"></a></span>
<span id="cb4-40"><a href="#cb4-40"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;stacktop: &quot;</span><span class="op">,</span> stack[stackPointer<span class="dv">-1</span>])<span class="op">;</span></span>
<span id="cb4-41"><a href="#cb4-41"></a>}</span></code></pre></div>
<p>It has a <code>programCounter</code>, it has a <code>stack</code> and a <code>stackPointer</code>. It has a run loop that executes as long as there are instructions in the program left to execute. It fetches the current instruction pointed to by the <code>programCounter</code>, decodes it and executes it. One iteration of this loop is one “cycle” of this virtual machine.</p>
<p>We can build a program for it and execute it like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">let</span> program <span class="op">=</span> [</span>
<span id="cb5-2"><a href="#cb5-2"></a>  PUSH<span class="op">,</span> <span class="dv">3</span><span class="op">,</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>  PUSH<span class="op">,</span> <span class="dv">4</span><span class="op">,</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>  ADD<span class="op">,</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>  PUSH<span class="op">,</span> <span class="dv">5</span><span class="op">,</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>  MINUS</span>
<span id="cb5-7"><a href="#cb5-7"></a>]<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8"></a></span>
<span id="cb5-9"><a href="#cb5-9"></a>virtualMachine(program)<span class="op">;</span></span></code></pre></div>
<p>Can you already recognize the expression encoded in these instructions? It’s this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1"></a>(<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>) <span class="op">-</span> <span class="dv">5</span></span></code></pre></div>
<p>If you didn’t, that’s fine. You’ll be able to soon enough. The <code>program</code> is not that hard to read once you get used to doing arithmetic on a stack: first <code>PUSH</code> <code>3</code> and <code>4</code>, then <code>ADD</code> the two topmost elements by popping them off the stack, adding them and pushing the result back on to the stack; finally, <code>PUSH</code> <code>5</code> to get the <code>5</code> on to the stack, then <code>MINUS</code> it with the second element from the top and leave the result on to the stack.</p>
<p>The result that ends up on top of the <code>virtualMachine</code>’s stack is printed once the machine finishes its run loop:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb7-1"><a href="#cb7-1"></a>$ node virtual_machine.js</span>
<span id="cb7-2"><a href="#cb7-2"></a>stacktop:  2</span></code></pre></div>
<p>Boom.</p>
<p>Now, while that’s an actual working virtual machine, it’s also a rather simple one. As you can imagine, it’s not a showcase for what the whole spectrum of virtual-machine implementations is capable of and looks like. You can write a virtual machine in around 50 lines of code, like we just did, but also in 50 thousand lines or more. And going from <em>here</em> to <em>there</em> means making all kinds of choices regarding functionality and performance.</p>
<p>One of the most significant design decisions is whether the machine will be a <em>stack machine</em> or a <em>register machine</em>. It’s so significant that virtual machines are grouped based on this architectural choice, just like programming languages are sorted into “compiled” or “interpreted” buckets. The difference between a stack and a register machine is – put in the most simple terms – whether the machine uses a stack to do its computations (like we did in our example above) or registers (virtual ones!). The debate’s still open on what’s the better (read: faster) choice, since it’s mostly about trade-offs and which ones you’re prepared to make.</p>
<p>A stack machine and a matching compiler are said to be easier to build. The machine needs fewer parts and the instructions it executes are simpler, since they “only” make use of <em>the stack</em>. The problem is that you need to execute a lot of instructions, because you need to push and pop everything on and off the stack in order to get anything done. This puts a limit on how far one can take the cardinal rule of performance optimization: instead of trying to do a lot faster, first try to do less.</p>
<p>Building a register machine is more work, because the registers are <em>an addition</em>; it still has a stack. It’s not as prominent as in a stack machine, but it’s still necessary to implement a call stack. The advantage of a register machine is that its instructions can make use of the registers and are thus much denser compared to their stack counterparts. Instead of putting things on the stack, pushing and popping them to get them in the correct order, instructions can refer to the registers directly. Generally speaking, a program needs less instructions on a register machine than on a stack machine. That in turn results in better performance. But then again, writing the compiler that produces such dense instructions takes more effort. As I said: it’s about making trade-offs.</p>
<p>Besides this main architectural choice there’s a myriad of other decisions that go into building a virtual machine. There are the big questions regarding how to use memory and how to represent values internally (a topic which we already touched upon when we built the Monkey object system for our evaluator). But then there are seemingly tiny things that turn out to be endless, twisted rabbit holes you can get lost in. Let’s take a peek into one.</p>
<p>In our example above we used a <code>switch</code> statement do the <em>dispatching</em> in the run loop of our machine. <em>Dispatching</em> in a virtual machine means selecting an implementation for an instruction before executing it. In our <code>switch</code> statement the implementation of these instructions can be found right next to the <code>case</code>, inline. In <code>case MINUS</code> we subtract two values, in <code>case ADD</code> we add them, and so on. That’s dispatching. And while a <code>switch</code> statement looks like the obvious and <em>only</em> choice it’s far from that.</p>
<p>A <code>switch</code> statement is just the opening of the rabbit hole. And when you’re looking for maximum performance, you have to go in all the way. In there, you’ll find dispatching done with <a href="https://github.com/Shopify/go-lua/blob/88a6f168eee0ba102d7d20c5281056a5dd3d7550/vm.go#L306">jump tables</a>, with <a href="https://eli.thegreenplace.net/2012/07/12/computed-goto-for-efficient-dispatch-tables">computed GOTO statements</a>, with <a href="https://www.complang.tuwien.ac.at/forth/threaded-code.html">indirect and direct threaded code</a>. Because, believe it or not, with a sufficient number of <code>case</code> branches (a few hundred or more) a <code>switch</code> might be the slowest of these solutions. The goal is to reduce the overhead of dispatching so much that from a performance perspective the <code>fetch-decode</code> part of a <code>fetch-decode-execute</code> cycle disappears. That should give you a taste of how deep the rabbit holes are.</p>
<p>We now have a rough overview of what a virtual machine is and what goes into building one. Don’t worry if you’re still missing some details. Since we’re going to build our own, we’re going to revisit a lot of the topics, ideas and, yes, the rabbit holes.</p>
<h3 id="why-build-one">Why Build One?</h3>
<p>Let’s put what we just learned into perspective. <em>Why</em> would you build a virtual machine to implement a programming language? I have to admit that this is the question I’ve carried around with me the longest. Even after I had built a few tiny virtual machines and had read through the source code of larger ones, I still asked myself: why?</p>
<p>When we implement a programming language we want it to be universal. It should be able to execute all possible programs and not just – as one example of many – functions we built into it. Universal computation is what we’re after and computers offer a solid model for it. If we construct a programming language based on that model, it’s going to have the same computational capabilities as the computer. It’s also one of the fastest ways to execute programs.</p>
<p>But if executing programs like a computer is the best and fastest way, why not, you know, just let the computer execute the programs? Portability. We could write a compiler for our programming language that allows us to execute the translated programs natively on a computer. These programs would be really fast. But we would also have to write a new compiler for every computer architecture we want to run our programs on. That’s a lot of work. Instead, we can translate our programs into instructions for a virtual machine. And the virtual machine itself runs on as many architectures as its implementation language. In the case of the Go programming language that’s <em>pretty</em> portable.</p>
<p>And there’s another reason for implementing a programming language with a virtual machine, which I think is the most fascinating one. It’s this: virtual machines are domain specific. That’s what makes them different from their non-virtual counterparts. Computers offer us a universal solution to all of our computational needs and are decidedly <em>not</em> domain specific. And that’s okay, that’s exactly what we need from a computer on which we want to run all sorts of programs. But what if we don’t need a machine to be <em>that</em> universal? What if we only need a subset of the features a computer has to offer to its programmers?</p>
<p>As programmers we know that no feature comes without cost. Increased complexity and degraded performance are just two of the prices we regularly pay for them. Computers today have a lot of features. A CPU of the x86-64 family supports between <a href="https://stefanheule.com/blog/how-many-x86-64-instructions-are-there-anyway/">900 and 4000 instructions, depending on how you count them.</a> That includes at least six different ways to do a bitwise XOR on two operands. This is handy and what makes computers so versatile. But it’s not free. The versatility has a cost, just like every other feature. Think back to the <code>switch</code> statement in our tiny VM and take a second to ponder the performance implications of adding 3997 more <code>case</code> branches. If you’re not sure whether it will actually be slower, ask yourself how easy it is to maintain the code or to program for this VM. The good news is that we can turn this around. If we get rid of the features we don’t need, we can go faster. Less complexity, less maintenance, less mass. This is where virtual machines come into play.</p>
<p>A virtual machine is like a custom-built computer. It has custom parts and a custom machine language. It’s tuned to a single programming language. All the unneeded features are stripped off and what’s left is highly specialized. Since you don’t need to be as universal as a general-purpose computer, you can focus. You can concentrate your efforts into making this highly-specialized and custom-made machine work as best and go as fast as possible. This – the specialization, the domain specificity – is as important as getting rid of the unneeded mass.</p>
<p>Why this is so important becomes even clearer when we take a look at the instructions a virtual machine executes, something which we steered clear of up until now. Remember what we fed our tiny virtual machine? Here it is again:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">let</span> program <span class="op">=</span> [</span>
<span id="cb8-2"><a href="#cb8-2"></a>  PUSH<span class="op">,</span> <span class="dv">3</span><span class="op">,</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>  PUSH<span class="op">,</span> <span class="dv">4</span><span class="op">,</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>  ADD<span class="op">,</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>  PUSH<span class="op">,</span> <span class="dv">5</span><span class="op">,</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>  MINUS</span>
<span id="cb8-7"><a href="#cb8-7"></a>]<span class="op">;</span></span>
<span id="cb8-8"><a href="#cb8-8"></a></span>
<span id="cb8-9"><a href="#cb8-9"></a>virtualMachine(program)<span class="op">;</span></span></code></pre></div>
<p>Now, what <em>is</em> that? What’s <code>PUSH</code>, what’s <code>ADD</code>, what’s <code>MINUS</code>? Here are their definitions:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">const</span> PUSH <span class="op">=</span> <span class="st">&#39;PUSH&#39;</span><span class="op">;</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">const</span> ADD <span class="op">=</span> <span class="st">&#39;ADD&#39;</span><span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="kw">const</span> MINUS <span class="op">=</span> <span class="st">&#39;MINUS&#39;</span><span class="op">;</span></span></code></pre></div>
<p><code>PUSH</code>, <code>ADD</code> and <code>MINUS</code> are just constants referring to strings. There’s no magic sauce. What a letdown. Boo! The silver lining of this revelation is that these definitions are as toy like and for illustration purposes only as the rest of the VM. They don’t answer the larger, more interesting question looming here: what <em>exactly</em> do virtual machines execute?</p>
<h3 id="bytecode">Bytecode</h3>
<p>Virtual machines execute bytecode. Like the machine code that computers execute, bytecode is made up of instructions that tell the machine what to do. Push this, pop that, add these, call this function. It’s called bytecode because the opcodes contained in each instruction are one byte in size.</p>
<p>An “opcode” is the “operator” part of an instruction, sometimes also called “op”. The <code>PUSH</code> we’ve seen earlier is such an opcode, except that in our toy example it was a multi-byte string and not just one byte. In a proper implementation <code>PUSH</code> would just be the name that refers to an opcode, which itself is one byte wide. These names, like <code>PUSH</code> or <code>POP</code>, are called mnemonics. They help us programmers remember and talk about opcodes.</p>
<p>The operands (also called arguments or parameters) to these opcodes are also contained in the bytecode. They’re placed alongside each other, with the operands following the opcodes. The operands, though, aren’t necessarily one byte wide. For example, if an operand is an integer and greater than 255, it would take multiple bytes to represent it. Some opcodes have multiple operands, some just one and some don’t have any at all. Whether the bytecode is designed for a register or a stack machine has a huge influence here.</p>
<p>You can imagine bytecode as a sequence of opcodes and operands, laid out in memory next to each other:</p>
<!-- ./ascii_drawings/01/bytecode.monopic -->
<figure>
<img src="./images/01/bytecode.svg" style="width:60.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>This helps to illustrate the general idea, but bytecode is a binary format and not nearly as readable. Meaning that you can’t read it like a text file. The mnemonics, like <code>PUSH</code>, don’t show up in the actual bytecode. They are replaced by the opcodes they refer to, and those are just numbers – bytes. Which numbers exactly is up to the person defining the bytecode. The <code>PUSH</code> mnemonic might stand for the number <code>0</code> and <code>POP</code> might refer to the number <code>23</code>.</p>
<p>The operands are also encoded and, again, it depends on its value into how many bytes. In case an operand needs multiple bytes to be accurately represented, the order in which it’s encoded plays a big role. There are two possible orders, called <em>little endian</em> and <em>big endian</em>. Little endian means that the <em>least</em> significant byte of the original data comes first and is stored in the lowest memory address. Big endian is the opposite: the <em>most</em> significant byte comes first.</p>
<p>If we, as bytecode designers, were to declare that <code>PUSH</code> refers to <code>1</code>, <code>ADD</code> to <code>2</code> and integers are stored in big endian, we could encode the example from above and lay it out in memory like this:</p>
<!-- ./ascii_drawings/01/bytecode_in_memory.monopic -->
<figure>
<img src="./images/01/bytecode_in_memory.svg" style="width:65.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>What we just did – taking a human-readable representation of bytecode and turning it into binary data – is done by programs called assemblers. You’ve probably heard of them in the context of non-virtual machine code. Same thing here. Assembly language is the readable version of the bytecode, containing mnemonics and readable operands, and an assembler turns it into binary bytecode. The reverse, transforming the binary representation into a readable representation, is done by disassemblers.</p>
<p>Alright! So much for the purely technical aspects of bytecode. Any further exploration would get too specific too fast. Bytecode formats are just too diverse and specialized to allow us to make more general statements here. Just like the virtual machine that executes it, bytecode is created with a very specific goal in mind.</p>
<p>Bytecode is a domain-specific language for a domain-specific machine. It’s the bespoke machine language for the custom-built virtual machine. That’s where its power lies. Instead of being universal and supporting every conceivable use case, bytecode can be specialized. It only has to support the features needed by the source language, the language being compiled to bytecode.</p>
<p>And not only that. On top of only allowing a narrow set of instructions, it can contain domain-specific instructions that only make sense in the context of the domain-specific virtual machine. The bytecode for the Java Virtual Machine (JVM), for example, contains these instructions: <code>invokeinterface</code> to invoke an interface method, <code>getstatic</code> to get a static field of a class, <code>new</code> to create a new object of the specified class. Ruby’s bytecode has the <code>putself</code> instruction to load <code>self</code> on the stack, <code>send</code> to send a message to an object, <code>putobject</code> to load any object on to the stack. And Lua’s bytecode has dedicated instructions for accessing and manipulating tables and tuples. You won’t find any of that in the instruction set of a general-purpose x86-64 CPU.</p>
<p>This ability to specialize by using a custom bytecode format is one of the biggest reasons for building a virtual machine in the first place. Not only do compilation, maintenance and debugging get easier but the resulting code is also denser, because it takes less instructions to express something. That in turn makes the code faster to execute.</p>
<p>Now, if all that talk about custom virtual machines, tailor-made machine code, hand-built compilers didn’t wet your appetite, this is your last chance to turn around. We’re about to get our hands dirty.</p>
<h2 id="what-were-going-to-do-or-the-duality-of-vm-and-compiler">What We’re Going to Do, or: the Duality of VM and Compiler</h2>
<p>Building a virtual machine and a matching compiler requires us first to solve a variation of the chicken-and-egg problem: which one do we build first? The compiler, that outputs bytecode for a machine that doesn’t exist yet? Or the virtual machine, that no one produces any code for?</p>
<p>Here’s the answer I choose for this book: we are going to build both – at the same time.</p>
<p>Building one completely before the other (and it doesn’t matter which one) is frustrating. It’s hard to understand what’s going on and what is the purpose of what you’re doing. If you’re building the compiler and defining the bytecode first, it’s tough to make sense of why things are the way they are without knowing how the virtual machine will later execute it. Building the virtual machine before the compiler comes with its own challenges, because the bytecode needs to be defined first. That’s hard to do without closely looking at the source-language constructs the bytecode aims to represent, which means you’re going to spell out the compiler anyway.</p>
<p>Of course, if you already have experience with building one or the other, you know where you want to end up and can thus choose either option. For us, though, the goal is to learn how to build both from the ground up.</p>
<p>That’s why we’re going to start small. We’re going to build a tiny virtual machine that only supports a tiny number of instructions and a matching tiny compiler that only knows how to output these instructions. That allows us to immediately see why we’re building what we’re building and how all the pieces fit together. We’ll also have a running system right from the start. That gives us fast feedback cycles and allows us to tune, experiment and gradually build up our virtual machine and compiler. It also makes the whole journey a lot of fun.</p>
<p>Now you know what the plan is. And you also know enough about compilers and virtual machines that we don’t get lost along the way. Let’s get to it.</p>
<h1 id="hello-bytecode">Hello Bytecode!</h1>
<p>Our goal for this chapter is to compile and execute this Monkey expression:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1"></a><span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span></span></code></pre></div>
<p>That doesn’t sound like an ambitious goal, but in order to reach it, we will have to learn many new things and build up a lot of the infrastructure we’re going to use in the upcoming chapters. And by choosing the simple expression <code>1 + 2</code> we won’t be distracted by the Monkey code itself and how it should work. We can concentrate on our compiler and virtual machine.</p>
<p>At the end of this chapter we want to be able to:</p>
<ul>
<li>take the Monkey expression <code>1 + 2</code></li>
<li>tokenize and parse it using our existing <code>lexer</code>, <code>token</code> and <code>parser</code> packages</li>
<li>take the resulting AST, whose nodes are defined in our <code>ast</code> package</li>
<li>pass it to the newly-built compiler, which compiles it to bytecode</li>
<li>take the bytecode and hand it over to the also newly-built virtual machine which will execute it</li>
<li>make sure that the virtual machine turned it into <code>3</code>.</li>
</ul>
<p>The <code>1 + 2</code> expression will travel through all the major parts of our new interpreter:</p>
<!-- ./ascii_drawings/02/goal_hello_bytecode.monopic -->
<figure>
<img src="./images/02/expression_through_components.svg" style="width:80.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>In terms of data structures, you can see that there will be quite a few transformations until we end up with the <code>3</code> as our result:</p>
<!-- ./ascii_drawings/02/goal_hello_bytecode.monopic -->
<figure>
<img src="./images/02/expression_through_data_structures.svg" style="width:80.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>Since we’ll be using a lot of the packages we built in the previous book, we can already handle everything up to the AST. After that we’re entering unchartered territory. We need to define bytecode instructions, build a compiler and construct a virtual machine – just to turn <code>1 + 2</code> into <code>3</code>. Sounds daunting? Worry not, we’ll do this step by step and build from the ground up, as always, and start with the bytecode.</p>
<h2 id="first-instructions">First Instructions</h2>
<p>As I mentioned in the previous chapter, the architecture of the virtual machine is the single-biggest influence on what the bytecode looks like. That means we need to decide what type of machine we’re going to build before we can start to specify bytecode.</p>
<p>So without further ado, let’s pull back the curtain: we’re going to build a <strong>stack machine</strong>! Why? Because stack machines are far easier to understand and to build for beginners than register machines. Less concepts, less moving parts. And all the performance considerations – <em>is a register machine faster?</em> – do not play a huge role for us. Our priorities are learning and understanding.</p>
<p>Later on we’ll see more of the implications this decision has, but the immediate and most practical one is that we now have to do stack arithmetic. That means, in order to reach our declared goal of compiling and executing the Monkey expression <code>1 + 2</code>, we have to translate it to bytecode instructions that make use of a stack. The stack is where a stack machine does its work – we can’t just tell it to add two numbers, without making use of the stack.</p>
<p>Thankfully, we saw a similar example before and already know how to do arithmetic with a stack. We first get the operands <code>1</code> and <code>2</code> on to the stack and then tell the VM: “add these!”. This “add these!” instruction should then cause the VM to take the two topmost elements from the stack, add them together and push the result back on to the stack. Here’s what stack should look like before and after the instruction:</p>
<!-- ./ascii_drawings/02/stack_arithmetic.monopic -->
<figure>
<img src="./images/02/stack_arithmetic.svg" style="width:60.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>So in order to fully implement this we need to tell the VM:</p>
<ul>
<li>Push <code>1</code> on to the stack</li>
<li>Push <code>2</code> on to the stack</li>
<li>Add the two topmost elements together</li>
</ul>
<p>We need to create three instructions. As programmers, though, we know that we only need to define two separate instruction types, since pushing <code>2</code> on to the stack should be the same as pushing <code>1</code>, except that the “argument” is different. So, two instruction types in total: one for pushing something on to the stack and one for adding things that are already on the stack.</p>
<p>We’ll implement both in the same way. First we define their opcodes and how they are encoded in bytecode. Then we extend the compiler so it can produce these instructions. As soon as the compiler knows how to do that, we can create the VM that decodes and executes them. And we start with the instructions that tell the VM to push something on to the stack.</p>
<h3 id="starting-with-bytes">Starting With Bytes</h3>
<p>Here we are. We need to define our first bytecode instruction. How do we do that? Well, since creating definitions while programming is not much more than telling the computer what we know, let’s ask ourselves: what do we know about bytecode?</p>
<p>We know that it’s made up of instructions. And we also know that the instructions themselves are a series of bytes and a single instruction consists of an opcode and an optional number of operands. An opcode is exactly one byte wide, has an arbitrary but unique value and is the first byte in the instruction. Looks like we know quite a lot and the best thing is, that this is precise enough to be turned into code – literally.</p>
<p>As our first official practical act of coding in this book, we create a new package, called <code>code</code>, where we start to define our Monkey bytecode format:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb11-1"><a href="#cb11-1"></a><span class="co">// code/code.go</span></span>
<span id="cb11-2"><a href="#cb11-2"></a></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="kw">package</span> code</span>
<span id="cb11-4"><a href="#cb11-4"></a></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="kw">type</span> Instructions []<span class="dt">byte</span></span>
<span id="cb11-6"><a href="#cb11-6"></a></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="kw">type</span> Opcode <span class="dt">byte</span></span></code></pre></div>
<p><code>Instructions</code> is a slice of bytes and an <code>Opcode</code> is a byte. Perfect, they match our descriptions in prose pretty well. But there are two definitions missing here.</p>
<p>The first one is <code>Instruction</code> – singular. Why didn’t we define it here as <code>[]byte</code>? Because it’s far more handy to pass around and work with a <code>[]byte</code> and treat it <em>implicitly</em> as an instruction than to encode this definition in Go’s type system. You’ll see soon enough how often we’re going to use <code>[]byte</code> and how cumbersome type assertions and type casting from and to an <code>Instruction</code> type would be there.</p>
<p>The other missing definition is one for <code>Bytecode</code>. There should at least be some definition of bytecode that tells us it’s made up of instructions, right? The reason for its absence is we’d run into a nasty import-cycle if we were to define <code>Bytecode</code> here in the <code>code</code> package. But it won’t be missing for too long. Once we get to the compiler, we’ll define it there – in the compiler’s package.</p>
<p>Now that we have definitions for <code>Opcode</code> and <code>Instructions</code>, we can define our first opcode, the one that tells the VM to push something on the stack. And here’s a surprise: the opcode won’t have “push” in its name. In fact, it won’t be solely about pushing things. Allow me to explain.</p>
<p>We said earlier that when we compile the Monkey expression <code>1 + 2</code>, we want to generate three different instructions; two of which tell the VM to push <code>1</code> and <code>2</code> on to the stack. A first instinct might tell us to implement these by defining a “push”-instruction with an integer as its operand with the idea being that the VM then takes the integer operand and pushes it on to the stack. And for integers that would work fine, because we could easily encode them and put them directly into the bytecode. But what if later on we wanted to push other things contained in Monkey code? String literals, for example. Putting those into the bytecode is also possible, true, since it’s just made of bytes after all, but it would also be a lot of bloat and would sooner or later become unwieldy.</p>
<p>That’s where the idea of <em>constants</em> come into play. In this context, “constant” is short for “constant expression” and refers to expressions whose value doesn’t change, is <em>constant</em>, and can be determined at <em>compile time</em>:</p>
<!-- ./ascii_drawings/02/goal_hello_bytecode.monopic -->
<figure>
<img src="./images/02/expression_through_components_annotated.svg" style="width:80.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>That means we don’t need to run the program to know what these expressions evaluate to. A compiler can find them in the code and store the value they evaluate to. After that, it can reference the constants in the instructions it generates, instead of embedding the values directly in them. And while “reference” sounds like a special data type, it’s far easier than that. A plain integer does the job just fine and can serve as an index into a data structure that holds all constants, often called a constant pool.</p>
<p>And that’s exactly what our compiler is going to do. When we come across an integer literal (a constant expression) while compiling, we’ll evaluate it and keep track of resulting <code>*object.Integer</code> by storing it in memory and assigning it a number. In the bytecode instructions we’ll refer to the <code>*object.Integer</code> by this number. After we’re done compiling and pass the instructions to the VM for execution, we’ll also hand over all the constants we’ve found by putting them in a data structure – our constant pool – where the number that has been assigned to each constant can be used as an index to retrieve it.</p>
<p>Back to our first opcode. It’s called <code>OpConstant</code> and it has one operand: the number we previously assigned to the constant. When the VM executes <code>OpConstant</code> it retrieves the constant using the operand as an index and pushes it on to the stack. Here’s out first opcode definition:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb12-1"><a href="#cb12-1"></a><span class="co">// code/code.go</span></span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="co">// [...]</span></span>
<span id="cb12-4"><a href="#cb12-4"></a></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="kw">const</span> (</span>
<span id="cb12-6"><a href="#cb12-6"></a>    OpConstant Opcode = <span class="ot">iota</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>)</span></code></pre></div>
<p>While this looks exactly like the meager three lines of code that they are, this addition is the groundwork for all future <code>Opcode</code> definitions. Each definition will have an <code>Op</code> prefix and the value it refers to will be determined by <code>iota</code>. We let <code>iota</code> generate increasing <code>byte</code> values for us, because we just don’t care about the actual values our opcodes represent. They only need to be distinct from each other and fit in one byte. <code>iota</code> makes sure of that for us.</p>
<p>What’s missing from this definition is the part that says <code>OpConstant</code> has one operand. There’s no technical reason for writing this down, since we could share this piece of knowledge implicitly between compiler and VM. For debugging and testing purposes, though, it’s handy being able to lookup how many operands an opcode has and what its human-readable name is. In order to achieve that, we’ll add proper definitions and some tooling to the <code>code</code> package:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb13-1"><a href="#cb13-1"></a><span class="co">// code/code.go</span></span>
<span id="cb13-2"><a href="#cb13-2"></a></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="kw">import</span> <span class="st">&quot;fmt&quot;</span></span>
<span id="cb13-4"><a href="#cb13-4"></a></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="kw">type</span> Definition <span class="kw">struct</span> {</span>
<span id="cb13-6"><a href="#cb13-6"></a>    Name          <span class="dt">string</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>    OperandWidths []<span class="dt">int</span></span>
<span id="cb13-8"><a href="#cb13-8"></a>}</span>
<span id="cb13-9"><a href="#cb13-9"></a></span>
<span id="cb13-10"><a href="#cb13-10"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb13-11"><a href="#cb13-11"></a>    OpConstant: {<span class="st">&quot;OpConstant&quot;</span>, []<span class="dt">int</span>{<span class="dv">2</span>}},</span>
<span id="cb13-12"><a href="#cb13-12"></a>}</span>
<span id="cb13-13"><a href="#cb13-13"></a></span>
<span id="cb13-14"><a href="#cb13-14"></a><span class="kw">func</span> Lookup(op <span class="dt">byte</span>) (*Definition, <span class="dt">error</span>) {</span>
<span id="cb13-15"><a href="#cb13-15"></a>    def, ok := definitions[Opcode(op)]</span>
<span id="cb13-16"><a href="#cb13-16"></a>    <span class="kw">if</span> !ok {</span>
<span id="cb13-17"><a href="#cb13-17"></a>        <span class="kw">return</span> <span class="ot">nil</span>, fmt.Errorf(<span class="st">&quot;opcode %d undefined&quot;</span>, op)</span>
<span id="cb13-18"><a href="#cb13-18"></a>    }</span>
<span id="cb13-19"><a href="#cb13-19"></a></span>
<span id="cb13-20"><a href="#cb13-20"></a>    <span class="kw">return</span> def, <span class="ot">nil</span></span>
<span id="cb13-21"><a href="#cb13-21"></a>}</span></code></pre></div>
<p>The <code>Definition</code> for an <code>Opcode</code> has two fields: <code>Name</code> and <code>OperandWidths</code>. <code>Name</code> helps to make an <code>Opcode</code> readable and <code>OperandWidths</code> contains the number of bytes each operand takes up.</p>
<p>The definition for <code>OpConstant</code> says that its only operand is two bytes wide, which makes it an <code>uint16</code> and limits its maximum value to <code>65535</code>. If we include <code>0</code> the number of representable values is then <code>65536</code>. That should be enough for us, because I don’t think we’re going to reference more than <code>65536</code> constants in our Monkey programs. And using an <code>uint16</code> instead of, say, an <code>uint32</code>, helps to keep the resulting instructions smaller, because there are less unused bytes.</p>
<p>With this definition in place we can now create our first bytecode instruction. Without any operands involved that would be as simple as adding an <code>Opcode</code> to an <code>Instructions</code> slice. But in the case of <code>OpConstant</code> we need to correctly encode the two-byte operand.</p>
<p>For that we’ll now create a function that allows us to easily create a single bytecode instruction that’s made up of an <code>Opcode</code> and an optional number of operands. We’ll call it <code>Make</code>, which gives us the pretty great identifier <code>code.Make</code> in other packages.</p>
<p>And here’s what we’ve been waiting for, the first test of this book, showing what we want <code>Make</code> to do:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb14-1"><a href="#cb14-1"></a><span class="co">// code/code_test.go</span></span>
<span id="cb14-2"><a href="#cb14-2"></a></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="kw">package</span> code</span>
<span id="cb14-4"><a href="#cb14-4"></a></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="kw">import</span> <span class="st">&quot;testing&quot;</span></span>
<span id="cb14-6"><a href="#cb14-6"></a></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="kw">func</span> TestMake(t *testing.T) {</span>
<span id="cb14-8"><a href="#cb14-8"></a>    tests := []<span class="kw">struct</span> {</span>
<span id="cb14-9"><a href="#cb14-9"></a>        op       Opcode</span>
<span id="cb14-10"><a href="#cb14-10"></a>        operands []<span class="dt">int</span></span>
<span id="cb14-11"><a href="#cb14-11"></a>        expected []<span class="dt">byte</span></span>
<span id="cb14-12"><a href="#cb14-12"></a>    }{</span>
<span id="cb14-13"><a href="#cb14-13"></a>        {OpConstant, []<span class="dt">int</span>{<span class="dv">65534</span>}, []<span class="dt">byte</span>{<span class="dt">byte</span>(OpConstant), <span class="dv">255</span>, <span class="dv">254</span>}},</span>
<span id="cb14-14"><a href="#cb14-14"></a>    }</span>
<span id="cb14-15"><a href="#cb14-15"></a></span>
<span id="cb14-16"><a href="#cb14-16"></a>    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</span>
<span id="cb14-17"><a href="#cb14-17"></a>        instruction := Make(tt.op, tt.operands...)</span>
<span id="cb14-18"><a href="#cb14-18"></a></span>
<span id="cb14-19"><a href="#cb14-19"></a>        <span class="kw">if</span> <span class="bu">len</span>(instruction) != <span class="bu">len</span>(tt.expected) {</span>
<span id="cb14-20"><a href="#cb14-20"></a>            t.Errorf(<span class="st">&quot;instruction has wrong length. want=%d, got=%d&quot;</span>,</span>
<span id="cb14-21"><a href="#cb14-21"></a>                <span class="bu">len</span>(tt.expected), <span class="bu">len</span>(instruction))</span>
<span id="cb14-22"><a href="#cb14-22"></a>        }</span>
<span id="cb14-23"><a href="#cb14-23"></a></span>
<span id="cb14-24"><a href="#cb14-24"></a>        <span class="kw">for</span> i, b := <span class="kw">range</span> tt.expected {</span>
<span id="cb14-25"><a href="#cb14-25"></a>            <span class="kw">if</span> instruction[i] != tt.expected[i] {</span>
<span id="cb14-26"><a href="#cb14-26"></a>                t.Errorf(<span class="st">&quot;wrong byte at pos %d. want=%d, got=%d&quot;</span>,</span>
<span id="cb14-27"><a href="#cb14-27"></a>                    i, b, instruction[i])</span>
<span id="cb14-28"><a href="#cb14-28"></a>            }</span>
<span id="cb14-29"><a href="#cb14-29"></a>        }</span>
<span id="cb14-30"><a href="#cb14-30"></a>    }</span>
<span id="cb14-31"><a href="#cb14-31"></a>}</span></code></pre></div>
<p>Don’t be put off by <code>tests</code> only containing one test case. We’ll extend it later on when we add more <code>Opcode</code>s to our <code>code</code> vocabulary.</p>
<p>For now, we only pass <code>OpConstant</code> and the operand <code>65534</code> to <code>Make</code>. We then expect to get back a <code>[]byte</code> holding three bytes. Of these three, the first one has to be the opcode, <code>OpConstant</code>, and the other two should be the big-endian encoding of <code>65534</code>. That’s also why we used <code>65534</code> and not the maximum value <code>65535</code>: this way we can check that the most significant byte comes first. <code>65534</code> will be encoded in big endian as the byte sequence <code>0xFF 0xFE</code> and <code>65535</code> would be encoded as <code>0xFF 0xFF</code> – hard to recognize an order.</p>
<p>Since <code>Make</code> doesn’t exist yet, the test does not fail, but fails to compile, so here’s the first version of <code>Make</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb15-1"><a href="#cb15-1"></a><span class="co">// code/code.go</span></span>
<span id="cb15-2"><a href="#cb15-2"></a></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="kw">import</span> (</span>
<span id="cb15-4"><a href="#cb15-4"></a>    <span class="st">&quot;encoding/binary&quot;</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>    <span class="st">&quot;fmt&quot;</span></span>
<span id="cb15-6"><a href="#cb15-6"></a>)</span>
<span id="cb15-7"><a href="#cb15-7"></a></span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="kw">func</span> Make(op Opcode, operands ...<span class="dt">int</span>) []<span class="dt">byte</span> {</span>
<span id="cb15-9"><a href="#cb15-9"></a>    def, ok := definitions[op]</span>
<span id="cb15-10"><a href="#cb15-10"></a>    <span class="kw">if</span> !ok {</span>
<span id="cb15-11"><a href="#cb15-11"></a>        <span class="kw">return</span> []<span class="dt">byte</span>{}</span>
<span id="cb15-12"><a href="#cb15-12"></a>    }</span>
<span id="cb15-13"><a href="#cb15-13"></a></span>
<span id="cb15-14"><a href="#cb15-14"></a>    instructionLen := <span class="dv">1</span></span>
<span id="cb15-15"><a href="#cb15-15"></a>    <span class="kw">for</span> _, w := <span class="kw">range</span> def.OperandWidths {</span>
<span id="cb15-16"><a href="#cb15-16"></a>        instructionLen += w</span>
<span id="cb15-17"><a href="#cb15-17"></a>    }</span>
<span id="cb15-18"><a href="#cb15-18"></a></span>
<span id="cb15-19"><a href="#cb15-19"></a>    instruction := <span class="bu">make</span>([]<span class="dt">byte</span>, instructionLen)</span>
<span id="cb15-20"><a href="#cb15-20"></a>    instruction[<span class="dv">0</span>] = <span class="dt">byte</span>(op)</span>
<span id="cb15-21"><a href="#cb15-21"></a></span>
<span id="cb15-22"><a href="#cb15-22"></a>    offset := <span class="dv">1</span></span>
<span id="cb15-23"><a href="#cb15-23"></a>    <span class="kw">for</span> i, o := <span class="kw">range</span> operands {</span>
<span id="cb15-24"><a href="#cb15-24"></a>        width := def.OperandWidths[i]</span>
<span id="cb15-25"><a href="#cb15-25"></a>        <span class="kw">switch</span> width {</span>
<span id="cb15-26"><a href="#cb15-26"></a>        <span class="kw">case</span> <span class="dv">2</span>:</span>
<span id="cb15-27"><a href="#cb15-27"></a>            binary.BigEndian.PutUint16(instruction[offset:], <span class="dt">uint16</span>(o))</span>
<span id="cb15-28"><a href="#cb15-28"></a>        }</span>
<span id="cb15-29"><a href="#cb15-29"></a>        offset += width</span>
<span id="cb15-30"><a href="#cb15-30"></a>    }</span>
<span id="cb15-31"><a href="#cb15-31"></a></span>
<span id="cb15-32"><a href="#cb15-32"></a>    <span class="kw">return</span> instruction</span>
<span id="cb15-33"><a href="#cb15-33"></a>}</span></code></pre></div>
<p>And that’s how you make bytecode.</p>
<p>The first thing we’re doing here is to find out how long the resulting instruction is going to be. That allows us to allocate a <code>byte</code> slice with the proper length. Note that we don’t use the <code>Lookup</code> function to get to the definition, which gives us a much more usable function signature for <code>Make</code> in the tests later on. By circumventing <code>Lookup</code> and not having to return possible errors, we can use <code>Make</code> to easily build up bytecode instructions without having to check for errors after every call. The risk of producing empty byte slices by using an unknown opcode is one we’re willing to take, since we’re on the producing side here and know what we’re doing when creating instructions.</p>
<p>As soon as we have the final value of <code>instructionLen</code>, we allocate the instruction <code>[]byte</code> and add the <code>Opcode</code> as its first byte – by casting it into one. Then comes the tricky part: we iterate over the defined <code>OperandWidths</code>, take the matching element from <code>operands</code> and put it in the instruction. We do that by using a <code>switch</code> statement with a different method for each operand, depending on how wide the operand is.</p>
<p>As we define additional <code>Opcodes</code>, we soon have to extend this <code>switch</code> statement. For now, we only make sure that a two-byte operand is encoded in big endian. And while it’s not hard to do that by hand, we use <code>binary.BigEndian.PutUint16</code> from the standard library for this, with the benefit of having the name of the encoding immediately visible.</p>
<p>After encoding the operand, we increment <code>offset</code> by its <code>width</code> and the next iteration of the loop. Since the <code>OpConstant</code> opcode in our test case has only one operand, the loop performs only one iteration before <code>Make</code> returns <code>instruction</code>.</p>
<p>And, would you look at that, our fist test is compiling and passing:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb16-1"><a href="#cb16-1"></a>$ go test ./code</span>
<span id="cb16-2"><a href="#cb16-2"></a>ok      monkey/code 0.007s</span></code></pre></div>
<p>We successfully turned <code>OpConstant</code> and the operand <code>65534</code> into three bytes. That means we created our first bytecode instruction!</p>
<h3 id="the-smallest-compiler">The Smallest Compiler</h3>
<p>Now that we have a toolbox called <code>code</code>, we can start working on the compiler. Since we want a system that works from end to end as soon as possible, and not a system that can only be turned on once it’s feature-complete, our goal in this section is to build the smallest possible compiler. It should only do one thing for now: produce two <code>OpConstant</code> instructions that later cause the VM to correctly load the integers <code>1</code> and <code>2</code> on to the stack.</p>
<p>In order to achieve that, this minimal compiler has to do the following: traverse the AST we pass in, find the <code>*ast.IntegerLiteral</code> nodes, evaluate them by turning them into <code>*object.Integer</code> objects, add the objects to the constant pool, and finally emit <code>OpConstant</code> instructions that reference the constants in said pool.</p>
<p>Sounds good? Perfect! Let’s start by defining <code>Compiler</code> and its interface in a new <code>compiler</code> package:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb17-1"><a href="#cb17-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb17-2"><a href="#cb17-2"></a></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="kw">package</span> compiler</span>
<span id="cb17-4"><a href="#cb17-4"></a></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="kw">import</span> (</span>
<span id="cb17-6"><a href="#cb17-6"></a>    <span class="st">&quot;monkey/ast&quot;</span></span>
<span id="cb17-7"><a href="#cb17-7"></a>    <span class="st">&quot;monkey/code&quot;</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>    <span class="st">&quot;monkey/object&quot;</span></span>
<span id="cb17-9"><a href="#cb17-9"></a>)</span>
<span id="cb17-10"><a href="#cb17-10"></a></span>
<span id="cb17-11"><a href="#cb17-11"></a><span class="kw">type</span> Compiler <span class="kw">struct</span> {</span>
<span id="cb17-12"><a href="#cb17-12"></a>    instructions code.Instructions</span>
<span id="cb17-13"><a href="#cb17-13"></a>    constants    []object.Object</span>
<span id="cb17-14"><a href="#cb17-14"></a>}</span>
<span id="cb17-15"><a href="#cb17-15"></a></span>
<span id="cb17-16"><a href="#cb17-16"></a><span class="kw">func</span> New() *Compiler {</span>
<span id="cb17-17"><a href="#cb17-17"></a>    <span class="kw">return</span> &amp;Compiler{</span>
<span id="cb17-18"><a href="#cb17-18"></a>        instructions: code.Instructions{},</span>
<span id="cb17-19"><a href="#cb17-19"></a>        constants:    []object.Object{},</span>
<span id="cb17-20"><a href="#cb17-20"></a>    }</span>
<span id="cb17-21"><a href="#cb17-21"></a>}</span>
<span id="cb17-22"><a href="#cb17-22"></a></span>
<span id="cb17-23"><a href="#cb17-23"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb17-24"><a href="#cb17-24"></a>    <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb17-25"><a href="#cb17-25"></a>}</span>
<span id="cb17-26"><a href="#cb17-26"></a></span>
<span id="cb17-27"><a href="#cb17-27"></a><span class="kw">func</span> (c *Compiler) Bytecode() *Bytecode {</span>
<span id="cb17-28"><a href="#cb17-28"></a>    <span class="kw">return</span> &amp;Bytecode{</span>
<span id="cb17-29"><a href="#cb17-29"></a>        Instructions: c.instructions,</span>
<span id="cb17-30"><a href="#cb17-30"></a>        Constants:    c.constants,</span>
<span id="cb17-31"><a href="#cb17-31"></a>    }</span>
<span id="cb17-32"><a href="#cb17-32"></a>}</span>
<span id="cb17-33"><a href="#cb17-33"></a></span>
<span id="cb17-34"><a href="#cb17-34"></a><span class="kw">type</span> Bytecode <span class="kw">struct</span> {</span>
<span id="cb17-35"><a href="#cb17-35"></a>    Instructions code.Instructions</span>
<span id="cb17-36"><a href="#cb17-36"></a>    Constants    []object.Object</span>
<span id="cb17-37"><a href="#cb17-37"></a>}</span></code></pre></div>
<p>It really is minimal, isn’t it? The <code>Compiler</code> is a small <code>struct</code> with only two fields: <code>instructions</code> and <code>constants</code>. Both are internal fields and will later be modified by the <code>Compile</code> method. <code>instructions</code> will hold the generated bytecode and <code>constants</code> is a slice that serves as our constant pool.</p>
<p>But I bet the thing that caught your eye immediately is the definition we’ve been looking for earlier, in the <code>code</code> package: <code>Bytecode</code>! There it is and it doesn’t need a lot of explanation. It contains the <code>Instructions</code> the compiler generated and the <code>Constants</code> the compiler evaluated.</p>
<p><code>Bytecode</code> is what we’ll pass to the VM and make assertions about in our compiler tests. Speaking of which, the <code>Compile</code> method is empty and we’re now going to write our first compiler test that tells us what it should do.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb18-1"><a href="#cb18-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb18-2"><a href="#cb18-2"></a></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="kw">package</span> compiler</span>
<span id="cb18-4"><a href="#cb18-4"></a></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="kw">import</span> (</span>
<span id="cb18-6"><a href="#cb18-6"></a>    <span class="st">&quot;monkey/code&quot;</span></span>
<span id="cb18-7"><a href="#cb18-7"></a>    <span class="st">&quot;testing&quot;</span></span>
<span id="cb18-8"><a href="#cb18-8"></a>)</span>
<span id="cb18-9"><a href="#cb18-9"></a></span>
<span id="cb18-10"><a href="#cb18-10"></a><span class="kw">type</span> compilerTestCase <span class="kw">struct</span> {</span>
<span id="cb18-11"><a href="#cb18-11"></a>    input                <span class="dt">string</span></span>
<span id="cb18-12"><a href="#cb18-12"></a>    expectedConstants    []<span class="kw">interface</span>{}</span>
<span id="cb18-13"><a href="#cb18-13"></a>    expectedInstructions []code.Instructions</span>
<span id="cb18-14"><a href="#cb18-14"></a>}</span>
<span id="cb18-15"><a href="#cb18-15"></a></span>
<span id="cb18-16"><a href="#cb18-16"></a><span class="kw">func</span> TestIntegerArithmetic(t *testing.T) {</span>
<span id="cb18-17"><a href="#cb18-17"></a>    tests := []compilerTestCase{</span>
<span id="cb18-18"><a href="#cb18-18"></a>        {</span>
<span id="cb18-19"><a href="#cb18-19"></a>            input:             <span class="st">&quot;1 + 2&quot;</span>,</span>
<span id="cb18-20"><a href="#cb18-20"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">1</span>, <span class="dv">2</span>},</span>
<span id="cb18-21"><a href="#cb18-21"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb18-22"><a href="#cb18-22"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb18-23"><a href="#cb18-23"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb18-24"><a href="#cb18-24"></a>            },</span>
<span id="cb18-25"><a href="#cb18-25"></a>        },</span>
<span id="cb18-26"><a href="#cb18-26"></a>    }</span>
<span id="cb18-27"><a href="#cb18-27"></a></span>
<span id="cb18-28"><a href="#cb18-28"></a>    runCompilerTests(t, tests)</span>
<span id="cb18-29"><a href="#cb18-29"></a>}</span>
<span id="cb18-30"><a href="#cb18-30"></a></span>
<span id="cb18-31"><a href="#cb18-31"></a><span class="kw">func</span> runCompilerTests(t *testing.T, tests []compilerTestCase) {</span>
<span id="cb18-32"><a href="#cb18-32"></a>    t.Helper()</span>
<span id="cb18-33"><a href="#cb18-33"></a></span>
<span id="cb18-34"><a href="#cb18-34"></a>    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</span>
<span id="cb18-35"><a href="#cb18-35"></a>        program := parse(tt.input)</span>
<span id="cb18-36"><a href="#cb18-36"></a></span>
<span id="cb18-37"><a href="#cb18-37"></a>        compiler := New()</span>
<span id="cb18-38"><a href="#cb18-38"></a>        err := compiler.Compile(program)</span>
<span id="cb18-39"><a href="#cb18-39"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb18-40"><a href="#cb18-40"></a>            t.Fatalf(<span class="st">&quot;compiler error: %s&quot;</span>, err)</span>
<span id="cb18-41"><a href="#cb18-41"></a>        }</span>
<span id="cb18-42"><a href="#cb18-42"></a></span>
<span id="cb18-43"><a href="#cb18-43"></a>        bytecode := compiler.Bytecode()</span>
<span id="cb18-44"><a href="#cb18-44"></a></span>
<span id="cb18-45"><a href="#cb18-45"></a>        err = testInstructions(tt.expectedInstructions, bytecode.Instructions)</span>
<span id="cb18-46"><a href="#cb18-46"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb18-47"><a href="#cb18-47"></a>            t.Fatalf(<span class="st">&quot;testInstructions failed: %s&quot;</span>, err)</span>
<span id="cb18-48"><a href="#cb18-48"></a>        }</span>
<span id="cb18-49"><a href="#cb18-49"></a></span>
<span id="cb18-50"><a href="#cb18-50"></a>        err = testConstants(t, tt.expectedConstants, bytecode.Constants)</span>
<span id="cb18-51"><a href="#cb18-51"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb18-52"><a href="#cb18-52"></a>            t.Fatalf(<span class="st">&quot;testConstants failed: %s&quot;</span>, err)</span>
<span id="cb18-53"><a href="#cb18-53"></a>        }</span>
<span id="cb18-54"><a href="#cb18-54"></a>    }</span>
<span id="cb18-55"><a href="#cb18-55"></a>}</span></code></pre></div>
<p>What’s happening here doesn’t take long to explain: we take Monkey code as input, we parse it, produce an AST, hand it to the compiler and then make assertions about the bytecode the compiler produced.</p>
<p>We do that by constructing a <code>compilerTestCase</code> in which we define the input, which constants we expect in the constant pool and which instructions we expect the compiler to generate. Then we hand the <code>tests</code> slice with the <code>compilerTestCase</code>s to <code>runCompilerTests</code> to run them.</p>
<p>That’s a slightly different approach to constructing tests compared to the first book. The reason for that is Go 1.9, which introduced the wonderful <code>t.Helper</code> method. <code>t.Helper</code>, which we call in <code>runCompilerTests</code>, allows us to remove duplicated logic in test functions by defining test helpers. Think of it as inlining <code>runCompilerTests</code> into <code>TestIntegerArithmetic</code>. That in turn allows to abstract away the common behaviour shared by every compiler test we’re going to write, which greatly reduces the noise in every test function and the page count of this book.</p>
<p>Now, let’s talk about the helpers used in <code>runCompilerTests</code>.</p>
<p>The <code>parse</code> function contains some of the things we built in the first book: the lexer and the parser. We hand it a <code>string</code> and get back an AST:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb19-1"><a href="#cb19-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb19-2"><a href="#cb19-2"></a></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="kw">import</span> (</span>
<span id="cb19-4"><a href="#cb19-4"></a>    <span class="st">&quot;monkey/ast&quot;</span></span>
<span id="cb19-5"><a href="#cb19-5"></a>    <span class="st">&quot;monkey/code&quot;</span></span>
<span id="cb19-6"><a href="#cb19-6"></a>    <span class="st">&quot;monkey/lexer&quot;</span></span>
<span id="cb19-7"><a href="#cb19-7"></a>    <span class="st">&quot;monkey/parser&quot;</span></span>
<span id="cb19-8"><a href="#cb19-8"></a>    <span class="st">&quot;testing&quot;</span></span>
<span id="cb19-9"><a href="#cb19-9"></a>)</span>
<span id="cb19-10"><a href="#cb19-10"></a></span>
<span id="cb19-11"><a href="#cb19-11"></a><span class="kw">func</span> parse(input <span class="dt">string</span>) *ast.Program {</span>
<span id="cb19-12"><a href="#cb19-12"></a>    l := lexer.New(input)</span>
<span id="cb19-13"><a href="#cb19-13"></a>    p := parser.New(l)</span>
<span id="cb19-14"><a href="#cb19-14"></a>    <span class="kw">return</span> p.ParseProgram()</span>
<span id="cb19-15"><a href="#cb19-15"></a>}</span></code></pre></div>
<p>That’s the prelude. The main part of <code>runCompilerTests</code> revolves around the two fields of the <code>Bytecode</code> the compiler produced. First, we want to make sure that the <code>bytecode.Instructions</code> are correct. For that we have the <code>testInstructions</code> helper function:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb20-1"><a href="#cb20-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb20-2"><a href="#cb20-2"></a></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="kw">import</span> (</span>
<span id="cb20-4"><a href="#cb20-4"></a>    <span class="st">&quot;fmt&quot;</span></span>
<span id="cb20-5"><a href="#cb20-5"></a>    <span class="co">// [...]</span></span>
<span id="cb20-6"><a href="#cb20-6"></a>)</span>
<span id="cb20-7"><a href="#cb20-7"></a></span>
<span id="cb20-8"><a href="#cb20-8"></a><span class="kw">func</span> testInstructions(</span>
<span id="cb20-9"><a href="#cb20-9"></a>    expected []code.Instructions,</span>
<span id="cb20-10"><a href="#cb20-10"></a>    actual code.Instructions,</span>
<span id="cb20-11"><a href="#cb20-11"></a>) <span class="dt">error</span> {</span>
<span id="cb20-12"><a href="#cb20-12"></a>    concatted := concatInstructions(expected)</span>
<span id="cb20-13"><a href="#cb20-13"></a></span>
<span id="cb20-14"><a href="#cb20-14"></a>    <span class="kw">if</span> <span class="bu">len</span>(actual) != <span class="bu">len</span>(concatted) {</span>
<span id="cb20-15"><a href="#cb20-15"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;wrong instructions length.</span><span class="ch">\n</span><span class="st">want=%q</span><span class="ch">\n</span><span class="st">got =%q&quot;</span>,</span>
<span id="cb20-16"><a href="#cb20-16"></a>            concatted, actual)</span>
<span id="cb20-17"><a href="#cb20-17"></a>    }</span>
<span id="cb20-18"><a href="#cb20-18"></a></span>
<span id="cb20-19"><a href="#cb20-19"></a>    <span class="kw">for</span> i, ins := <span class="kw">range</span> concatted {</span>
<span id="cb20-20"><a href="#cb20-20"></a>        <span class="kw">if</span> actual[i] != ins {</span>
<span id="cb20-21"><a href="#cb20-21"></a>            <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;wrong instruction at %d.</span><span class="ch">\n</span><span class="st">want=%q</span><span class="ch">\n</span><span class="st">got =%q&quot;</span>,</span>
<span id="cb20-22"><a href="#cb20-22"></a>                i, concatted, actual)</span>
<span id="cb20-23"><a href="#cb20-23"></a>        }</span>
<span id="cb20-24"><a href="#cb20-24"></a>    }</span>
<span id="cb20-25"><a href="#cb20-25"></a></span>
<span id="cb20-26"><a href="#cb20-26"></a>    <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb20-27"><a href="#cb20-27"></a>}</span></code></pre></div>
<p>As you can see, it uses another helper called <code>concatInstructions</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb21-1"><a href="#cb21-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb21-2"><a href="#cb21-2"></a></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="kw">func</span> concatInstructions(s []code.Instructions) code.Instructions {</span>
<span id="cb21-4"><a href="#cb21-4"></a>    out := code.Instructions{}</span>
<span id="cb21-5"><a href="#cb21-5"></a></span>
<span id="cb21-6"><a href="#cb21-6"></a>    <span class="kw">for</span> _, ins := <span class="kw">range</span> s {</span>
<span id="cb21-7"><a href="#cb21-7"></a>        out = <span class="bu">append</span>(out, ins...)</span>
<span id="cb21-8"><a href="#cb21-8"></a>    }</span>
<span id="cb21-9"><a href="#cb21-9"></a></span>
<span id="cb21-10"><a href="#cb21-10"></a>    <span class="kw">return</span> out</span>
<span id="cb21-11"><a href="#cb21-11"></a>}</span></code></pre></div>
<p>We need <code>concatInstructions</code> because the <code>expectedInstructions</code> field in <code>compilerTestCase</code> is not just a slice of bytes, but a slice of <em>slices</em> of bytes. And that’s because we use <code>code.Make</code> to generate the <code>expectedInstructions</code>, which produces a <code>[]byte</code>. So in order to compare the <code>expectedInstructions</code> with the actual instructions, we need to turn the slice of slices into a flattened slice by concatenating the instructions.</p>
<p>The other helper used by <code>runCompilerTests</code> is <code>testConstants</code>, which resembles a lot of the test helpers we used in our <code>evaluator</code> package back in the first book:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb22-1"><a href="#cb22-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb22-2"><a href="#cb22-2"></a></span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="kw">import</span> (</span>
<span id="cb22-4"><a href="#cb22-4"></a>    <span class="co">// [...]</span></span>
<span id="cb22-5"><a href="#cb22-5"></a>    <span class="st">&quot;monkey/object&quot;</span></span>
<span id="cb22-6"><a href="#cb22-6"></a>    <span class="co">// [...]</span></span>
<span id="cb22-7"><a href="#cb22-7"></a>)</span>
<span id="cb22-8"><a href="#cb22-8"></a></span>
<span id="cb22-9"><a href="#cb22-9"></a><span class="kw">func</span> testConstants(</span>
<span id="cb22-10"><a href="#cb22-10"></a>    t *testing.T,</span>
<span id="cb22-11"><a href="#cb22-11"></a>    expected []<span class="kw">interface</span>{},</span>
<span id="cb22-12"><a href="#cb22-12"></a>    actual []object.Object,</span>
<span id="cb22-13"><a href="#cb22-13"></a>) <span class="dt">error</span> {</span>
<span id="cb22-14"><a href="#cb22-14"></a>    <span class="kw">if</span> <span class="bu">len</span>(expected) != <span class="bu">len</span>(actual) {</span>
<span id="cb22-15"><a href="#cb22-15"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;wrong number of constants. got=%d, want=%d&quot;</span>,</span>
<span id="cb22-16"><a href="#cb22-16"></a>            <span class="bu">len</span>(actual), <span class="bu">len</span>(expected))</span>
<span id="cb22-17"><a href="#cb22-17"></a>    }</span>
<span id="cb22-18"><a href="#cb22-18"></a></span>
<span id="cb22-19"><a href="#cb22-19"></a>    <span class="kw">for</span> i, constant := <span class="kw">range</span> expected {</span>
<span id="cb22-20"><a href="#cb22-20"></a>        <span class="kw">switch</span> constant := constant.(<span class="kw">type</span>) {</span>
<span id="cb22-21"><a href="#cb22-21"></a>        <span class="kw">case</span> <span class="dt">int</span>:</span>
<span id="cb22-22"><a href="#cb22-22"></a>            err := testIntegerObject(<span class="dt">int64</span>(constant), actual[i])</span>
<span id="cb22-23"><a href="#cb22-23"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb22-24"><a href="#cb22-24"></a>                <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;constant %d - testIntegerObject failed: %s&quot;</span>,</span>
<span id="cb22-25"><a href="#cb22-25"></a>                    i, err)</span>
<span id="cb22-26"><a href="#cb22-26"></a>            }</span>
<span id="cb22-27"><a href="#cb22-27"></a>        }</span>
<span id="cb22-28"><a href="#cb22-28"></a>    }</span>
<span id="cb22-29"><a href="#cb22-29"></a></span>
<span id="cb22-30"><a href="#cb22-30"></a>    <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb22-31"><a href="#cb22-31"></a>}</span></code></pre></div>
<p>There’s a lot of noise here, but what’s happening here is not complicated. <code>testConstants</code> iterates through the <code>expected</code> constants and compares them with the <code>actual</code> constants the compiler produced. The <code>switch</code> statement is a sign of things to come. We will extend it with new <code>case</code> branches as soon as we expect more than integers to end up in the constant pool. For now it only uses one other helper, <code>testIntegerObject</code>, which is a nearly-identical replica of the <code>testIntegerObject</code> we used in our evaluator tests:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb23-1"><a href="#cb23-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb23-2"><a href="#cb23-2"></a></span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="kw">func</span> testIntegerObject(expected <span class="dt">int64</span>, actual object.Object) <span class="dt">error</span> {</span>
<span id="cb23-4"><a href="#cb23-4"></a>    result, ok := actual.(*object.Integer)</span>
<span id="cb23-5"><a href="#cb23-5"></a>    <span class="kw">if</span> !ok {</span>
<span id="cb23-6"><a href="#cb23-6"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;object is not Integer. got=%T (%+v)&quot;</span>,</span>
<span id="cb23-7"><a href="#cb23-7"></a>            actual, actual)</span>
<span id="cb23-8"><a href="#cb23-8"></a>    }</span>
<span id="cb23-9"><a href="#cb23-9"></a></span>
<span id="cb23-10"><a href="#cb23-10"></a>    <span class="kw">if</span> result.Value != expected {</span>
<span id="cb23-11"><a href="#cb23-11"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;object has wrong value. got=%d, want=%d&quot;</span>,</span>
<span id="cb23-12"><a href="#cb23-12"></a>            result.Value, expected)</span>
<span id="cb23-13"><a href="#cb23-13"></a>    }</span>
<span id="cb23-14"><a href="#cb23-14"></a></span>
<span id="cb23-15"><a href="#cb23-15"></a>    <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb23-16"><a href="#cb23-16"></a>}</span></code></pre></div>
<p>That’s all there is to <code>TestIntegerArithmetic</code>. The test itself is not complex, but establishes how we will write compiler tests in the future by bringing with it a lot of different test helpers. It looks like a lot of code for such a small test, but I promise you that we’ll get a lot of mileage out of this test setup.</p>
<p>Now, how does the test itself do? Well, not so good:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb24-1"><a href="#cb24-1"></a>$ go test ./compiler</span>
<span id="cb24-2"><a href="#cb24-2"></a>--- FAIL: TestIntegerArithmetic (0.00s)</span>
<span id="cb24-3"><a href="#cb24-3"></a> compiler_test.go:31: testInstructions failed: wrong instructions length.</span>
<span id="cb24-4"><a href="#cb24-4"></a>  want=&quot;\x00\x00\x00\x00\x00\x01&quot;</span>
<span id="cb24-5"><a href="#cb24-5"></a>  got =&quot;&quot;</span>
<span id="cb24-6"><a href="#cb24-6"></a>FAIL</span>
<span id="cb24-7"><a href="#cb24-7"></a>FAIL    monkey/compiler 0.008s</span></code></pre></div>
<p>But considering that we didn’t write any code for the compiler yet, except defining its interface, that’s not so bad, is it? What’s bad though is the output:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb25-1"><a href="#cb25-1"></a>want=&quot;\x00\x00\x00\x00\x00\x01&quot;</span></code></pre></div>
<p>No one looks at that and goes “Ah, I see…” I know that you’re anxious to get that compiler running and humming, but I can’t let this unreadable gibberish stand. I mean, it’s correct, those <em>are</em> the bytes we want, printed in hexadecimal, but it’s just not helpful. And believe me, soon enough this output would drive us nuts. So before we start filling out the compiler’s <code>Compile()</code> method, we’re going to invest in our developer happiness and teach our <code>code.Instructions</code> how to properly print themselves.</p>
<h3 id="bytecode-disassemble">Bytecode, Disassemble!</h3>
<p>You can teach types to print themselves in Go by giving them a <code>String()</code> method. That also holds true for bytecode instructions. It’s pretty easy to do, actually, but, as you already know, we wouldn’t print anything without writing a test for it, right?</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb26-1"><a href="#cb26-1"></a><span class="co">// code/code_test.go</span></span>
<span id="cb26-2"><a href="#cb26-2"></a></span>
<span id="cb26-3"><a href="#cb26-3"></a><span class="kw">func</span> TestInstructionsString(t *testing.T) {</span>
<span id="cb26-4"><a href="#cb26-4"></a>    instructions := []Instructions{</span>
<span id="cb26-5"><a href="#cb26-5"></a>        Make(OpConstant, <span class="dv">1</span>),</span>
<span id="cb26-6"><a href="#cb26-6"></a>        Make(OpConstant, <span class="dv">2</span>),</span>
<span id="cb26-7"><a href="#cb26-7"></a>        Make(OpConstant, <span class="dv">65535</span>),</span>
<span id="cb26-8"><a href="#cb26-8"></a>    }</span>
<span id="cb26-9"><a href="#cb26-9"></a></span>
<span id="cb26-10"><a href="#cb26-10"></a>    expected := <span class="st">`0000 OpConstant 1</span></span>
<span id="cb26-11"><a href="#cb26-11"></a><span class="st">0003 OpConstant 2</span></span>
<span id="cb26-12"><a href="#cb26-12"></a><span class="st">0006 OpConstant 65535</span></span>
<span id="cb26-13"><a href="#cb26-13"></a><span class="st">`</span></span>
<span id="cb26-14"><a href="#cb26-14"></a></span>
<span id="cb26-15"><a href="#cb26-15"></a>    concatted := Instructions{}</span>
<span id="cb26-16"><a href="#cb26-16"></a>    <span class="kw">for</span> _, ins := <span class="kw">range</span> instructions {</span>
<span id="cb26-17"><a href="#cb26-17"></a>        concatted = <span class="bu">append</span>(concatted, ins...)</span>
<span id="cb26-18"><a href="#cb26-18"></a>    }</span>
<span id="cb26-19"><a href="#cb26-19"></a></span>
<span id="cb26-20"><a href="#cb26-20"></a>    <span class="kw">if</span> concatted.String() != expected {</span>
<span id="cb26-21"><a href="#cb26-21"></a>        t.Errorf(<span class="st">&quot;instructions wrongly formatted.</span><span class="ch">\n</span><span class="st">want=%q</span><span class="ch">\n</span><span class="st">got=%q&quot;</span>,</span>
<span id="cb26-22"><a href="#cb26-22"></a>            expected, concatted.String())</span>
<span id="cb26-23"><a href="#cb26-23"></a>    }</span>
<span id="cb26-24"><a href="#cb26-24"></a>}</span></code></pre></div>
<p>That’s what we expect from the to-be-implemented <code>Instructions.String</code> method: nicely-formatted multi-line output that tells us everything we need to know. There’s a counter at the start of each line, telling us which bytes we’re looking at, there are the opcodes in their human-readable form, and then there are the decoded operands. A lot more pleasant to look at than <code>\x00\x00\x00\x00\x00\x01</code>, right? We could also name the method <code>MiniDisassembler</code> instead of <code>String</code> because that’s what it is.</p>
<p>The test won’t compile, because the <code>String</code> method is undefined. So here’s the first piece of code we need to add:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb27-1"><a href="#cb27-1"></a><span class="co">// code/code.go</span></span>
<span id="cb27-2"><a href="#cb27-2"></a></span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="kw">func</span> (ins Instructions) String() <span class="dt">string</span> {</span>
<span id="cb27-4"><a href="#cb27-4"></a>    <span class="kw">return</span> <span class="st">&quot;&quot;</span></span>
<span id="cb27-5"><a href="#cb27-5"></a>}</span></code></pre></div>
<p>Correct, we return a blank string. Why? Because that gives the compiler something to chew on and us the ability to run tests again:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb28-1"><a href="#cb28-1"></a>$ go test ./code</span>
<span id="cb28-2"><a href="#cb28-2"></a>--- FAIL: TestInstructionsString (0.00s)</span>
<span id="cb28-3"><a href="#cb28-3"></a> code_test.go:49: instructions wrongly formatted.</span>
<span id="cb28-4"><a href="#cb28-4"></a>  want=&quot;0000 OpConstant 1\n0003 OpConstant 2\n0006 OpConstant 65535\n&quot;</span>
<span id="cb28-5"><a href="#cb28-5"></a>  got=&quot;&quot;</span>
<span id="cb28-6"><a href="#cb28-6"></a>FAIL</span>
<span id="cb28-7"><a href="#cb28-7"></a>FAIL    monkey/code 0.008s</span></code></pre></div>
<p>Perfect, it fails. That’s a lot more useful to us than an <code>undefined: String</code> compiler error that stops us from running the tests, because we now need to write <em>another</em> test and run it.</p>
<p>This other test is for a function that will be the heart of <code>Instructions.String</code>. Its name is <code>ReadOperands</code> and here’s what we want it to do:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb29-1"><a href="#cb29-1"></a><span class="co">// code/code_test.go</span></span>
<span id="cb29-2"><a href="#cb29-2"></a></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="kw">func</span> TestReadOperands(t *testing.T) {</span>
<span id="cb29-4"><a href="#cb29-4"></a>    tests := []<span class="kw">struct</span> {</span>
<span id="cb29-5"><a href="#cb29-5"></a>        op        Opcode</span>
<span id="cb29-6"><a href="#cb29-6"></a>        operands  []<span class="dt">int</span></span>
<span id="cb29-7"><a href="#cb29-7"></a>        bytesRead <span class="dt">int</span></span>
<span id="cb29-8"><a href="#cb29-8"></a>    }{</span>
<span id="cb29-9"><a href="#cb29-9"></a>        {OpConstant, []<span class="dt">int</span>{<span class="dv">65535</span>}, <span class="dv">2</span>},</span>
<span id="cb29-10"><a href="#cb29-10"></a>    }</span>
<span id="cb29-11"><a href="#cb29-11"></a></span>
<span id="cb29-12"><a href="#cb29-12"></a>    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</span>
<span id="cb29-13"><a href="#cb29-13"></a>        instruction := Make(tt.op, tt.operands...)</span>
<span id="cb29-14"><a href="#cb29-14"></a></span>
<span id="cb29-15"><a href="#cb29-15"></a>        def, err := Lookup(<span class="dt">byte</span>(tt.op))</span>
<span id="cb29-16"><a href="#cb29-16"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb29-17"><a href="#cb29-17"></a>            t.Fatalf(<span class="st">&quot;definition not found: %q</span><span class="ch">\n</span><span class="st">&quot;</span>, err)</span>
<span id="cb29-18"><a href="#cb29-18"></a>        }</span>
<span id="cb29-19"><a href="#cb29-19"></a></span>
<span id="cb29-20"><a href="#cb29-20"></a>        operandsRead, n := ReadOperands(def, instruction[<span class="dv">1</span>:])</span>
<span id="cb29-21"><a href="#cb29-21"></a>        <span class="kw">if</span> n != tt.bytesRead {</span>
<span id="cb29-22"><a href="#cb29-22"></a>            t.Fatalf(<span class="st">&quot;n wrong. want=%d, got=%d&quot;</span>, tt.bytesRead, n)</span>
<span id="cb29-23"><a href="#cb29-23"></a>        }</span>
<span id="cb29-24"><a href="#cb29-24"></a></span>
<span id="cb29-25"><a href="#cb29-25"></a>        <span class="kw">for</span> i, want := <span class="kw">range</span> tt.operands {</span>
<span id="cb29-26"><a href="#cb29-26"></a>            <span class="kw">if</span> operandsRead[i] != want {</span>
<span id="cb29-27"><a href="#cb29-27"></a>                t.Errorf(<span class="st">&quot;operand wrong. want=%d, got=%d&quot;</span>, want, operandsRead[i])</span>
<span id="cb29-28"><a href="#cb29-28"></a>            }</span>
<span id="cb29-29"><a href="#cb29-29"></a>        }</span>
<span id="cb29-30"><a href="#cb29-30"></a>    }</span>
<span id="cb29-31"><a href="#cb29-31"></a>}</span></code></pre></div>
<p>As you can see, <code>ReadOperands</code> is supposed to be <code>Make</code>’s counterpart. Whereas <code>Make</code> encodes the operands of a bytecode instruction, it’s the job of <code>ReadOperands</code> to decode them.</p>
<p>In <code>TestReadOperands</code> we <code>Make</code> a fully-encoded instruction and pass its definition to <code>ReadOperands</code>, along with the subslice of the instruction containing the operands. <code>ReadOperands</code> should then return the decoded operands and tell us how many bytes it read to do that. As you can probably imagine by now, we’re going to extend the <code>tests</code> table as soon as we have more opcodes and different instruction types.</p>
<p>The test fails because <code>ReadOperands</code> is not defined:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb30-1"><a href="#cb30-1"></a>$ go test ./code</span>
<span id="cb30-2"><a href="#cb30-2"></a># monkey/code</span>
<span id="cb30-3"><a href="#cb30-3"></a>code/code_test.go:71:22: undefined: ReadOperands</span>
<span id="cb30-4"><a href="#cb30-4"></a>FAIL    monkey/code [build failed]</span></code></pre></div>
<p>In order to get it to pass we have to implement a <code>ReadOperands</code> function that reverses everything <code>Make</code> did:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb31-1"><a href="#cb31-1"></a><span class="co">// code/code.go</span></span>
<span id="cb31-2"><a href="#cb31-2"></a></span>
<span id="cb31-3"><a href="#cb31-3"></a><span class="kw">func</span> ReadOperands(def *Definition, ins Instructions) ([]<span class="dt">int</span>, <span class="dt">int</span>) {</span>
<span id="cb31-4"><a href="#cb31-4"></a>    operands := <span class="bu">make</span>([]<span class="dt">int</span>, <span class="bu">len</span>(def.OperandWidths))</span>
<span id="cb31-5"><a href="#cb31-5"></a>    offset := <span class="dv">0</span></span>
<span id="cb31-6"><a href="#cb31-6"></a></span>
<span id="cb31-7"><a href="#cb31-7"></a>    <span class="kw">for</span> i, width := <span class="kw">range</span> def.OperandWidths {</span>
<span id="cb31-8"><a href="#cb31-8"></a>        <span class="kw">switch</span> width {</span>
<span id="cb31-9"><a href="#cb31-9"></a>        <span class="kw">case</span> <span class="dv">2</span>:</span>
<span id="cb31-10"><a href="#cb31-10"></a>            operands[i] = <span class="dt">int</span>(ReadUint16(ins[offset:]))</span>
<span id="cb31-11"><a href="#cb31-11"></a>        }</span>
<span id="cb31-12"><a href="#cb31-12"></a></span>
<span id="cb31-13"><a href="#cb31-13"></a>        offset += width</span>
<span id="cb31-14"><a href="#cb31-14"></a>    }</span>
<span id="cb31-15"><a href="#cb31-15"></a></span>
<span id="cb31-16"><a href="#cb31-16"></a>    <span class="kw">return</span> operands, offset</span>
<span id="cb31-17"><a href="#cb31-17"></a>}</span>
<span id="cb31-18"><a href="#cb31-18"></a></span>
<span id="cb31-19"><a href="#cb31-19"></a><span class="kw">func</span> ReadUint16(ins Instructions) <span class="dt">uint16</span> {</span>
<span id="cb31-20"><a href="#cb31-20"></a>    <span class="kw">return</span> binary.BigEndian.Uint16(ins)</span>
<span id="cb31-21"><a href="#cb31-21"></a>}</span></code></pre></div>
<p>Just like in <code>Make</code>, we use the <code>*Definition</code> of an opcode to find out how wide the operands are and allocate a slice with enough space to hold them. We then go through the <code>Instructions</code> slice and read in and convert as many bytes as defined in the definition. And again: the <code>switch</code> statement will be extended soon.</p>
<p>Let me explain why <code>ReadUint16</code> is a separate, public function. In <code>Make</code> we did the encoding of operands to bytes inline. Here, though, we want to expose the function so it can be used directly by the VM, allowing us to skip the definition lookup required by <code>ReadOperands</code>.</p>
<p>We now have one less failing test and can start to unwind and go back to the failing tests that brought us here. The first one is <code>TestInstructionString</code>, which is still chewing on the blank string:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb32-1"><a href="#cb32-1"></a>$ go test ./code</span>
<span id="cb32-2"><a href="#cb32-2"></a>--- FAIL: TestInstructionsString (0.00s)</span>
<span id="cb32-3"><a href="#cb32-3"></a> code_test.go:49: instructions wrongly formatted.</span>
<span id="cb32-4"><a href="#cb32-4"></a>  want=&quot;0000 OpConstant 1\n0003 OpConstant 2\n0006 OpConstant 65535\n&quot;</span>
<span id="cb32-5"><a href="#cb32-5"></a>  got=&quot;&quot;</span>
<span id="cb32-6"><a href="#cb32-6"></a>FAIL</span>
<span id="cb32-7"><a href="#cb32-7"></a>FAIL    monkey/code 0.008s</span></code></pre></div>
<p>Now that we have <code>ReadOperands</code>, we can get rid of the blank string and properly print instructions:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb33-1"><a href="#cb33-1"></a><span class="co">// code/code.go</span></span>
<span id="cb33-2"><a href="#cb33-2"></a></span>
<span id="cb33-3"><a href="#cb33-3"></a><span class="kw">import</span> (</span>
<span id="cb33-4"><a href="#cb33-4"></a>    <span class="st">&quot;bytes&quot;</span></span>
<span id="cb33-5"><a href="#cb33-5"></a>    <span class="co">// [...]</span></span>
<span id="cb33-6"><a href="#cb33-6"></a>)</span>
<span id="cb33-7"><a href="#cb33-7"></a></span>
<span id="cb33-8"><a href="#cb33-8"></a><span class="kw">func</span> (ins Instructions) String() <span class="dt">string</span> {</span>
<span id="cb33-9"><a href="#cb33-9"></a>    <span class="kw">var</span> out bytes.Buffer</span>
<span id="cb33-10"><a href="#cb33-10"></a></span>
<span id="cb33-11"><a href="#cb33-11"></a>    i := <span class="dv">0</span></span>
<span id="cb33-12"><a href="#cb33-12"></a>    <span class="kw">for</span> i &lt; <span class="bu">len</span>(ins) {</span>
<span id="cb33-13"><a href="#cb33-13"></a>        def, err := Lookup(ins[i])</span>
<span id="cb33-14"><a href="#cb33-14"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb33-15"><a href="#cb33-15"></a>            fmt.Fprintf(&amp;out, <span class="st">&quot;ERROR: %s</span><span class="ch">\n</span><span class="st">&quot;</span>, err)</span>
<span id="cb33-16"><a href="#cb33-16"></a>            <span class="kw">continue</span></span>
<span id="cb33-17"><a href="#cb33-17"></a>        }</span>
<span id="cb33-18"><a href="#cb33-18"></a></span>
<span id="cb33-19"><a href="#cb33-19"></a>        operands, read := ReadOperands(def, ins[i+<span class="dv">1</span>:])</span>
<span id="cb33-20"><a href="#cb33-20"></a></span>
<span id="cb33-21"><a href="#cb33-21"></a>        fmt.Fprintf(&amp;out, <span class="st">&quot;%04d %s</span><span class="ch">\n</span><span class="st">&quot;</span>, i, ins.fmtInstruction(def, operands))</span>
<span id="cb33-22"><a href="#cb33-22"></a></span>
<span id="cb33-23"><a href="#cb33-23"></a>        i += <span class="dv">1</span> + read</span>
<span id="cb33-24"><a href="#cb33-24"></a>    }</span>
<span id="cb33-25"><a href="#cb33-25"></a></span>
<span id="cb33-26"><a href="#cb33-26"></a>    <span class="kw">return</span> out.String()</span>
<span id="cb33-27"><a href="#cb33-27"></a>}</span>
<span id="cb33-28"><a href="#cb33-28"></a></span>
<span id="cb33-29"><a href="#cb33-29"></a><span class="kw">func</span> (ins Instructions) fmtInstruction(def *Definition, operands []<span class="dt">int</span>) <span class="dt">string</span> {</span>
<span id="cb33-30"><a href="#cb33-30"></a>    operandCount := <span class="bu">len</span>(def.OperandWidths)</span>
<span id="cb33-31"><a href="#cb33-31"></a></span>
<span id="cb33-32"><a href="#cb33-32"></a>    <span class="kw">if</span> <span class="bu">len</span>(operands) != operandCount {</span>
<span id="cb33-33"><a href="#cb33-33"></a>        <span class="kw">return</span> fmt.Sprintf(<span class="st">&quot;ERROR: operand len %d does not match defined %d</span><span class="ch">\n</span><span class="st">&quot;</span>,</span>
<span id="cb33-34"><a href="#cb33-34"></a>            <span class="bu">len</span>(operands), operandCount)</span>
<span id="cb33-35"><a href="#cb33-35"></a>    }</span>
<span id="cb33-36"><a href="#cb33-36"></a></span>
<span id="cb33-37"><a href="#cb33-37"></a>    <span class="kw">switch</span> operandCount {</span>
<span id="cb33-38"><a href="#cb33-38"></a>    <span class="kw">case</span> <span class="dv">1</span>:</span>
<span id="cb33-39"><a href="#cb33-39"></a>        <span class="kw">return</span> fmt.Sprintf(<span class="st">&quot;%s %d&quot;</span>, def.Name, operands[<span class="dv">0</span>])</span>
<span id="cb33-40"><a href="#cb33-40"></a>    }</span>
<span id="cb33-41"><a href="#cb33-41"></a></span>
<span id="cb33-42"><a href="#cb33-42"></a>    <span class="kw">return</span> fmt.Sprintf(<span class="st">&quot;ERROR: unhandled operandCount for %s</span><span class="ch">\n</span><span class="st">&quot;</span>, def.Name)</span>
<span id="cb33-43"><a href="#cb33-43"></a>}</span></code></pre></div>
<p>I don’t think I have to explain to you how this works because we’ve seen variations of this going-through-a-byte-slice mechanism a few times now. The rest is string formatting. But here’s something worth looking at:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb34-1"><a href="#cb34-1"></a>$ go test ./code</span>
<span id="cb34-2"><a href="#cb34-2"></a>ok      monkey/code 0.008s</span></code></pre></div>
<p>The tests in the <code>code</code> package now pass. Our mini-disassembler works. We can unwind even further and rerun the failing compiler test that kicked off this ride through the <code>code</code> package:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb35-1"><a href="#cb35-1"></a>$ go test ./compiler</span>
<span id="cb35-2"><a href="#cb35-2"></a>--- FAIL: TestIntegerArithmetic (0.00s)</span>
<span id="cb35-3"><a href="#cb35-3"></a> compiler_test.go:31: testInstructions failed: wrong instructions length.</span>
<span id="cb35-4"><a href="#cb35-4"></a>  want=&quot;0000 OpConstant 0\n0003 OpConstant 1\n&quot;</span>
<span id="cb35-5"><a href="#cb35-5"></a>  got =&quot;&quot;</span>
<span id="cb35-6"><a href="#cb35-6"></a>FAIL</span>
<span id="cb35-7"><a href="#cb35-7"></a>FAIL    monkey/compiler 0.008s</span></code></pre></div>
<p>Isn’t that beautiful? Alright, granted, beautiful may be a tad too much, but it sure isn’t the eyesore that was <code>want="\x00\x00\x00\x00\x00\x01"</code>.</p>
<p>We just leveled up. With such debuggable output, working on our compiler went from “fumbling in the dark” to “here, let me get that for you”.</p>
<h3 id="back-to-the-task-at-hand">Back to the Task at Hand</h3>
<p>Let’s take inventory. We have a lexer, a parser, the dotted outline of a compiler and a failing test that tells us that we need to generate two bytecode instructions. In our toolbox are the definition of an opcode and its operand, the <code>Make</code> function that lets us create bytecode instructions, our <code>object</code> system that we can use to pass Monkey values around, and readable and stunning <code>Instructions</code>.</p>
<p>And here’s a reminder of what our compiler needs to do: walk the AST recursively, find <code>*ast.IntegerLiterals</code>, evaluate them and turn them into <code>*object.Integer</code>s, add those to the <code>constants</code> field, and add <code>OpConstant</code> instructions to its internal <code>instructions</code> slice.</p>
<p>Can you say “walk in the park”?</p>
<p>Let’s start by walking the AST. That’s something we already did in the <code>Eval</code> function we wrote in the previous book and there is no reason to change the approach. Here is how we get to our <code>*ast.IntegerLiteral</code>s:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb36-1"><a href="#cb36-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb36-2"><a href="#cb36-2"></a></span>
<span id="cb36-3"><a href="#cb36-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb36-4"><a href="#cb36-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb36-5"><a href="#cb36-5"></a>    <span class="kw">case</span> *ast.Program:</span>
<span id="cb36-6"><a href="#cb36-6"></a>        <span class="kw">for</span> _, s := <span class="kw">range</span> node.Statements {</span>
<span id="cb36-7"><a href="#cb36-7"></a>            err := c.Compile(s)</span>
<span id="cb36-8"><a href="#cb36-8"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb36-9"><a href="#cb36-9"></a>                <span class="kw">return</span> err</span>
<span id="cb36-10"><a href="#cb36-10"></a>            }</span>
<span id="cb36-11"><a href="#cb36-11"></a>        }</span>
<span id="cb36-12"><a href="#cb36-12"></a></span>
<span id="cb36-13"><a href="#cb36-13"></a>    <span class="kw">case</span> *ast.ExpressionStatement:</span>
<span id="cb36-14"><a href="#cb36-14"></a>        err := c.Compile(node.Expression)</span>
<span id="cb36-15"><a href="#cb36-15"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb36-16"><a href="#cb36-16"></a>            <span class="kw">return</span> err</span>
<span id="cb36-17"><a href="#cb36-17"></a>        }</span>
<span id="cb36-18"><a href="#cb36-18"></a></span>
<span id="cb36-19"><a href="#cb36-19"></a>    <span class="kw">case</span> *ast.InfixExpression:</span>
<span id="cb36-20"><a href="#cb36-20"></a>        err := c.Compile(node.Left)</span>
<span id="cb36-21"><a href="#cb36-21"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb36-22"><a href="#cb36-22"></a>            <span class="kw">return</span> err</span>
<span id="cb36-23"><a href="#cb36-23"></a>        }</span>
<span id="cb36-24"><a href="#cb36-24"></a></span>
<span id="cb36-25"><a href="#cb36-25"></a>        err = c.Compile(node.Right)</span>
<span id="cb36-26"><a href="#cb36-26"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb36-27"><a href="#cb36-27"></a>            <span class="kw">return</span> err</span>
<span id="cb36-28"><a href="#cb36-28"></a>        }</span>
<span id="cb36-29"><a href="#cb36-29"></a></span>
<span id="cb36-30"><a href="#cb36-30"></a>    <span class="kw">case</span> *ast.IntegerLiteral:</span>
<span id="cb36-31"><a href="#cb36-31"></a>  <span class="co">// </span><span class="al">TODO</span><span class="co">: What now?!</span></span>
<span id="cb36-32"><a href="#cb36-32"></a>    }</span>
<span id="cb36-33"><a href="#cb36-33"></a></span>
<span id="cb36-34"><a href="#cb36-34"></a>    <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb36-35"><a href="#cb36-35"></a>}</span></code></pre></div>
<p>We first go through all the <code>node.Statements</code> in our <code>*ast.Program</code> and call <code>c.Compile</code> with each of them. That gets us one level deeper in the AST, where we find an <code>*ast.ExpressionStatement</code>. That’s what represents the <code>1 + 2</code> in our test. We then compile the <code>node.Expression</code> of that <code>*ast.ExpressionStatement</code> and end up with an <code>*ast.InfixExpression</code> of which we have to compile the <code>node.Left</code> and the <code>node.Right</code> sides.</p>
<p>So far, so recursive. But the <code>TODO</code> is right, what do we do with the <code>*ast.IntegerLiteral</code>s?</p>
<p>We need to evaluate them. That’s safe to do, remember, because literals are constant expressions and their value does not change. A <code>2</code> will always evaluate to <code>2</code>. And even though “evaluate” sounds sophisticated, it means creating an <code>*object.Integer</code>:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb37-1"><a href="#cb37-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb37-2"><a href="#cb37-2"></a></span>
<span id="cb37-3"><a href="#cb37-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb37-4"><a href="#cb37-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb37-5"><a href="#cb37-5"></a>    <span class="co">// [...]</span></span>
<span id="cb37-6"><a href="#cb37-6"></a></span>
<span id="cb37-7"><a href="#cb37-7"></a>    <span class="kw">case</span> *ast.IntegerLiteral:</span>
<span id="cb37-8"><a href="#cb37-8"></a>        integer := &amp;object.Integer{Value: node.Value}</span>
<span id="cb37-9"><a href="#cb37-9"></a></span>
<span id="cb37-10"><a href="#cb37-10"></a>    <span class="co">// [...]</span></span>
<span id="cb37-11"><a href="#cb37-11"></a>    }</span>
<span id="cb37-12"><a href="#cb37-12"></a></span>
<span id="cb37-13"><a href="#cb37-13"></a>    <span class="co">// [...]</span></span>
<span id="cb37-14"><a href="#cb37-14"></a>}</span></code></pre></div>
<p>Okay, so now we have the result of the evaluation – <code>integer</code> – at hand and can add it to our constant pool. To do that, we’ll add another helper to our compiler, called <code>addConstant</code>:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb38-1"><a href="#cb38-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb38-2"><a href="#cb38-2"></a></span>
<span id="cb38-3"><a href="#cb38-3"></a><span class="kw">func</span> (c *Compiler) addConstant(obj object.Object) <span class="dt">int</span> {</span>
<span id="cb38-4"><a href="#cb38-4"></a>    c.constants = <span class="bu">append</span>(c.constants, obj)</span>
<span id="cb38-5"><a href="#cb38-5"></a>    <span class="kw">return</span> <span class="bu">len</span>(c.constants) - <span class="dv">1</span></span>
<span id="cb38-6"><a href="#cb38-6"></a>}</span></code></pre></div>
<p>We append the <code>obj</code> to the end of the compilers <code>constants</code> slice and give it its very own identifier by returning its index in the <code>constants</code> slice. This identifier will now be used as the operand for the <code>OpConstant</code> instruction that should cause the <code>VM</code> to load this constant from the <code>constants</code> pool on to the stack.</p>
<p>We’re now able to add constants and to remember their identifier; time to emit a first instruction. Don’t be put off by the term: “emit” is compiler-speak for “generate” and “output”. It translates to: generate an instruction and add it to the results, either by printing it, writing it to a file or by adding it to a collection in memory. We’re going to do the last one:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb39-1"><a href="#cb39-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb39-2"><a href="#cb39-2"></a></span>
<span id="cb39-3"><a href="#cb39-3"></a><span class="kw">func</span> (c *Compiler) emit(op code.Opcode, operands ...<span class="dt">int</span>) <span class="dt">int</span> {</span>
<span id="cb39-4"><a href="#cb39-4"></a>    ins := code.Make(op, operands...)</span>
<span id="cb39-5"><a href="#cb39-5"></a>    pos := c.addInstruction(ins)</span>
<span id="cb39-6"><a href="#cb39-6"></a>    <span class="kw">return</span> pos</span>
<span id="cb39-7"><a href="#cb39-7"></a>}</span>
<span id="cb39-8"><a href="#cb39-8"></a></span>
<span id="cb39-9"><a href="#cb39-9"></a><span class="kw">func</span> (c *Compiler) addInstruction(ins []<span class="dt">byte</span>) <span class="dt">int</span> {</span>
<span id="cb39-10"><a href="#cb39-10"></a>    posNewInstruction := <span class="bu">len</span>(c.instructions)</span>
<span id="cb39-11"><a href="#cb39-11"></a>    c.instructions = <span class="bu">append</span>(c.instructions, ins...)</span>
<span id="cb39-12"><a href="#cb39-12"></a>    <span class="kw">return</span> posNewInstruction</span>
<span id="cb39-13"><a href="#cb39-13"></a>}</span></code></pre></div>
<p>I’m sure that you understand all of it but I want you to make a mental note of the fact that <code>emit</code> returns the starting position of the just-emitted instruction. Add to this note that we’ll use the return value later on when we need to <em>go back</em> in <code>c.instructions</code> and modify it…</p>
<p>In the <code>Compile</code> method we can now use <code>addConstant</code> and <code>emit</code> to make one delicate change:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb40-1"><a href="#cb40-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb40-2"><a href="#cb40-2"></a></span>
<span id="cb40-3"><a href="#cb40-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb40-4"><a href="#cb40-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb40-5"><a href="#cb40-5"></a>    <span class="co">// [...]</span></span>
<span id="cb40-6"><a href="#cb40-6"></a></span>
<span id="cb40-7"><a href="#cb40-7"></a>    <span class="kw">case</span> *ast.IntegerLiteral:</span>
<span id="cb40-8"><a href="#cb40-8"></a>        integer := &amp;object.Integer{Value: node.Value}</span>
<span id="cb40-9"><a href="#cb40-9"></a>        c.emit(code.OpConstant, c.addConstant(integer))</span>
<span id="cb40-10"><a href="#cb40-10"></a></span>
<span id="cb40-11"><a href="#cb40-11"></a>    <span class="co">// [...]</span></span>
<span id="cb40-12"><a href="#cb40-12"></a>    }</span>
<span id="cb40-13"><a href="#cb40-13"></a></span>
<span id="cb40-14"><a href="#cb40-14"></a>    <span class="co">// [...]</span></span>
<span id="cb40-15"><a href="#cb40-15"></a>}</span></code></pre></div>
<p>One new line, emitting the <code>OpConstant</code> instruction. It’s enough:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb41-1"><a href="#cb41-1"></a>$ go test ./compiler</span>
<span id="cb41-2"><a href="#cb41-2"></a>ok      monkey/compiler 0.008s</span></code></pre></div>
<p>It’s strange that it says <code>ok</code> here, because we just turned the status of our first compiler test from <code>FAIL</code> to <code>woah-what-?-we-did-it-!-we-have-a-compiler-!</code>.</p>
<h3 id="powering-on-the-machine">Powering On the Machine</h3>
<p>Let’s do another inventory check. Here’s where we stand. We have one opcode defined, <code>OpConstant</code>. We have a tiny compiler that knows how to walk an AST and emit such an <code>OpConstant</code> instruction. Our tiny compiler also knows how to evaluate constant integer literal expressions and how to add them to its constant pool. And the compiler’s interface allows us to pass around the result of the compilation, including the emitted instructions and the constant pool.</p>
<p>While the instruction set of our bytecode may currently only be able to express “push this constant on to the stack” and not “do something with it”, it’s enough for us to get to work on our VM. Yes, really, it’s time for us to build our machine.</p>
<p>The goal for this section is to build up a VM that we can initialize with the <code>Bytecode</code> produced by the compiler, start and have it fetch, decode, and execute <code>OpConstant</code> instructions. The result of all that should be numbers being pushed on to the VM’s stack.</p>
<p>Sounds like a test? Well, it’s not hard to turn it into one. But before we can do that, we need to prepare by doing something unorthodox. We’ll now copy and paste our <code>parse</code> and <code>testIntegerObject</code> test helpers from our compiler tests to a new <code>vm_test.go</code> file:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb42-1"><a href="#cb42-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb42-2"><a href="#cb42-2"></a></span>
<span id="cb42-3"><a href="#cb42-3"></a><span class="kw">package</span> vm</span>
<span id="cb42-4"><a href="#cb42-4"></a></span>
<span id="cb42-5"><a href="#cb42-5"></a><span class="kw">import</span> (</span>
<span id="cb42-6"><a href="#cb42-6"></a>    <span class="st">&quot;fmt&quot;</span></span>
<span id="cb42-7"><a href="#cb42-7"></a>    <span class="st">&quot;monkey/ast&quot;</span></span>
<span id="cb42-8"><a href="#cb42-8"></a>    <span class="st">&quot;monkey/lexer&quot;</span></span>
<span id="cb42-9"><a href="#cb42-9"></a>    <span class="st">&quot;monkey/object&quot;</span></span>
<span id="cb42-10"><a href="#cb42-10"></a>    <span class="st">&quot;monkey/parser&quot;</span></span>
<span id="cb42-11"><a href="#cb42-11"></a>)</span>
<span id="cb42-12"><a href="#cb42-12"></a></span>
<span id="cb42-13"><a href="#cb42-13"></a><span class="kw">func</span> parse(input <span class="dt">string</span>) *ast.Program {</span>
<span id="cb42-14"><a href="#cb42-14"></a>    l := lexer.New(input)</span>
<span id="cb42-15"><a href="#cb42-15"></a>    p := parser.New(l)</span>
<span id="cb42-16"><a href="#cb42-16"></a>    <span class="kw">return</span> p.ParseProgram()</span>
<span id="cb42-17"><a href="#cb42-17"></a>}</span>
<span id="cb42-18"><a href="#cb42-18"></a></span>
<span id="cb42-19"><a href="#cb42-19"></a><span class="kw">func</span> testIntegerObject(expected <span class="dt">int64</span>, actual object.Object) <span class="dt">error</span> {</span>
<span id="cb42-20"><a href="#cb42-20"></a>    result, ok := actual.(*object.Integer)</span>
<span id="cb42-21"><a href="#cb42-21"></a>    <span class="kw">if</span> !ok {</span>
<span id="cb42-22"><a href="#cb42-22"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;object is not Integer. got=%T (%+v)&quot;</span>,</span>
<span id="cb42-23"><a href="#cb42-23"></a>            actual, actual)</span>
<span id="cb42-24"><a href="#cb42-24"></a>    }</span>
<span id="cb42-25"><a href="#cb42-25"></a></span>
<span id="cb42-26"><a href="#cb42-26"></a>    <span class="kw">if</span> result.Value != expected {</span>
<span id="cb42-27"><a href="#cb42-27"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;object has wrong value. got=%d, want=%d&quot;</span>,</span>
<span id="cb42-28"><a href="#cb42-28"></a>            result.Value, expected)</span>
<span id="cb42-29"><a href="#cb42-29"></a>    }</span>
<span id="cb42-30"><a href="#cb42-30"></a></span>
<span id="cb42-31"><a href="#cb42-31"></a>    <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb42-32"><a href="#cb42-32"></a>}</span></code></pre></div>
<p>Yes, <em>yes</em>, I hear you, duplication is bad, you’re right. But for now, the duplication is the most affordable solution while being easy to understand. It also won’t fall on our feet – trust me, I’ve read this book before.</p>
<p>Then we lay the groundwork for all future VM tests by copying the approach of the compiler tests and making it easy to define and run new test cases with the help of <code>t.Helper</code>:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb43-1"><a href="#cb43-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb43-2"><a href="#cb43-2"></a></span>
<span id="cb43-3"><a href="#cb43-3"></a><span class="kw">import</span> (</span>
<span id="cb43-4"><a href="#cb43-4"></a>    <span class="co">// [...]</span></span>
<span id="cb43-5"><a href="#cb43-5"></a>    <span class="st">&quot;monkey/compiler&quot;</span></span>
<span id="cb43-6"><a href="#cb43-6"></a>    <span class="co">// [...]</span></span>
<span id="cb43-7"><a href="#cb43-7"></a>    <span class="st">&quot;testing&quot;</span></span>
<span id="cb43-8"><a href="#cb43-8"></a>)</span>
<span id="cb43-9"><a href="#cb43-9"></a></span>
<span id="cb43-10"><a href="#cb43-10"></a><span class="kw">type</span> vmTestCase <span class="kw">struct</span> {</span>
<span id="cb43-11"><a href="#cb43-11"></a>    input    <span class="dt">string</span></span>
<span id="cb43-12"><a href="#cb43-12"></a>    expected <span class="kw">interface</span>{}</span>
<span id="cb43-13"><a href="#cb43-13"></a>}</span>
<span id="cb43-14"><a href="#cb43-14"></a></span>
<span id="cb43-15"><a href="#cb43-15"></a><span class="kw">func</span> runVmTests(t *testing.T, tests []vmTestCase) {</span>
<span id="cb43-16"><a href="#cb43-16"></a>    t.Helper()</span>
<span id="cb43-17"><a href="#cb43-17"></a></span>
<span id="cb43-18"><a href="#cb43-18"></a>    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</span>
<span id="cb43-19"><a href="#cb43-19"></a>        program := parse(tt.input)</span>
<span id="cb43-20"><a href="#cb43-20"></a></span>
<span id="cb43-21"><a href="#cb43-21"></a>        comp := compiler.New()</span>
<span id="cb43-22"><a href="#cb43-22"></a>        err := comp.Compile(program)</span>
<span id="cb43-23"><a href="#cb43-23"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb43-24"><a href="#cb43-24"></a>            t.Fatalf(<span class="st">&quot;compiler error: %s&quot;</span>, err)</span>
<span id="cb43-25"><a href="#cb43-25"></a>        }</span>
<span id="cb43-26"><a href="#cb43-26"></a></span>
<span id="cb43-27"><a href="#cb43-27"></a>        vm := New(comp.Bytecode())</span>
<span id="cb43-28"><a href="#cb43-28"></a>        err = vm.Run()</span>
<span id="cb43-29"><a href="#cb43-29"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb43-30"><a href="#cb43-30"></a>            t.Fatalf(<span class="st">&quot;vm error: %s&quot;</span>, err)</span>
<span id="cb43-31"><a href="#cb43-31"></a>        }</span>
<span id="cb43-32"><a href="#cb43-32"></a></span>
<span id="cb43-33"><a href="#cb43-33"></a>        stackElem := vm.StackTop()</span>
<span id="cb43-34"><a href="#cb43-34"></a></span>
<span id="cb43-35"><a href="#cb43-35"></a>        testExpectedObject(t, tt.expected, stackElem)</span>
<span id="cb43-36"><a href="#cb43-36"></a>    }</span>
<span id="cb43-37"><a href="#cb43-37"></a>}</span>
<span id="cb43-38"><a href="#cb43-38"></a></span>
<span id="cb43-39"><a href="#cb43-39"></a><span class="kw">func</span> testExpectedObject(</span>
<span id="cb43-40"><a href="#cb43-40"></a>    t *testing.T,</span>
<span id="cb43-41"><a href="#cb43-41"></a>    expected <span class="kw">interface</span>{},</span>
<span id="cb43-42"><a href="#cb43-42"></a>    actual object.Object,</span>
<span id="cb43-43"><a href="#cb43-43"></a>) {</span>
<span id="cb43-44"><a href="#cb43-44"></a>    t.Helper()</span>
<span id="cb43-45"><a href="#cb43-45"></a></span>
<span id="cb43-46"><a href="#cb43-46"></a>    <span class="kw">switch</span> expected := expected.(<span class="kw">type</span>) {</span>
<span id="cb43-47"><a href="#cb43-47"></a>    <span class="kw">case</span> <span class="dt">int</span>:</span>
<span id="cb43-48"><a href="#cb43-48"></a>        err := testIntegerObject(<span class="dt">int64</span>(expected), actual)</span>
<span id="cb43-49"><a href="#cb43-49"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb43-50"><a href="#cb43-50"></a>            t.Errorf(<span class="st">&quot;testIntegerObject failed: %s&quot;</span>, err)</span>
<span id="cb43-51"><a href="#cb43-51"></a>        }</span>
<span id="cb43-52"><a href="#cb43-52"></a>    }</span>
<span id="cb43-53"><a href="#cb43-53"></a>}</span></code></pre></div>
<p>The <code>runVmTests</code> function takes care of setting up and running each <code>vmTestCase</code>: lex and parse the input, take the AST, pass it to the <code>compiler</code>, check the compiler for errors and then hand the <code>*compiler.Bytecode</code> over to the <code>New</code> function.</p>
<p>The <code>New</code> function should return a new instance of the virtual machine, assigned to <code>vm</code>. This is where we get to the heart of each test case. We start the <code>vm</code> with a call to <code>vm.Run</code> and after making sure it ran without an error, we use a method called <code>StackTop</code> to get the object that’s left sitting on top of the VM’s stack. We then pass that to <code>testExpectedObject</code> to make sure that this object matches what we expected in the <code>vmTestCase.expected</code> field.</p>
<p>Whew! Quite a lot of preparation and setup. But, trust me, this is going to make it so easy to write VM tests in the future. I mean, take a look at this, our first test:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb44-1"><a href="#cb44-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb44-2"><a href="#cb44-2"></a></span>
<span id="cb44-3"><a href="#cb44-3"></a><span class="kw">func</span> TestIntegerArithmetic(t *testing.T) {</span>
<span id="cb44-4"><a href="#cb44-4"></a>    tests := []vmTestCase{</span>
<span id="cb44-5"><a href="#cb44-5"></a>        {<span class="st">&quot;1&quot;</span>, <span class="dv">1</span>},</span>
<span id="cb44-6"><a href="#cb44-6"></a>        {<span class="st">&quot;2&quot;</span>, <span class="dv">2</span>},</span>
<span id="cb44-7"><a href="#cb44-7"></a>        {<span class="st">&quot;1 + 2&quot;</span>, <span class="dv">2</span>}, <span class="co">// </span><span class="al">FIXME</span></span>
<span id="cb44-8"><a href="#cb44-8"></a>    }</span>
<span id="cb44-9"><a href="#cb44-9"></a></span>
<span id="cb44-10"><a href="#cb44-10"></a>    runVmTests(t, tests)</span>
<span id="cb44-11"><a href="#cb44-11"></a>}</span></code></pre></div>
<p>Isn’t that wonderful? No noise, no boilerplate. We just write down the Monkey code and what we expect to end up on the stack when the VM executes it.</p>
<p>Please note that we do <em>not</em> expect <code>3</code> but <code>2</code> to be sitting on top of the stack after compiling and executing <code>1 + 2</code>. Sounds wrong, right? Well, it <em>is</em> wrong. At the end of this chapter executing <code>1 + 2</code> should, of course, result in <code>3</code>. But right now we only have <code>OpConstant</code> defined, which makes the only thing we can test and implement the pushing of constants on the stack. And in this test case, the <code>2</code> is the second integer to be pushed, so that’s what we’re going to test.</p>
<p>The other two test cases, with only the integers <code>1</code> and <code>2</code> as their input, are sanity checks. They do not test separate functionality. Pushing a sole integer on to the stack is included in, well, pushing two of them. But these test cases do not have a huge cost and don’t take up a lot of space, so I added them to explicitly make sure that a single integer literal in an expression statement ends with an integer being pushed on to the stack.</p>
<p>Currently, though, nothing’s pushed because we haven’t defined <code>VM</code> yet. But we can do that now, since we already know which parts <code>VM</code> needs to have: instructions, constants and a stack.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb45-1"><a href="#cb45-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb45-2"><a href="#cb45-2"></a></span>
<span id="cb45-3"><a href="#cb45-3"></a><span class="kw">package</span> vm</span>
<span id="cb45-4"><a href="#cb45-4"></a></span>
<span id="cb45-5"><a href="#cb45-5"></a><span class="kw">import</span> (</span>
<span id="cb45-6"><a href="#cb45-6"></a>    <span class="st">&quot;monkey/code&quot;</span></span>
<span id="cb45-7"><a href="#cb45-7"></a>    <span class="st">&quot;monkey/compiler&quot;</span></span>
<span id="cb45-8"><a href="#cb45-8"></a>    <span class="st">&quot;monkey/object&quot;</span></span>
<span id="cb45-9"><a href="#cb45-9"></a>)</span>
<span id="cb45-10"><a href="#cb45-10"></a></span>
<span id="cb45-11"><a href="#cb45-11"></a><span class="kw">const</span> StackSize = <span class="dv">2048</span></span>
<span id="cb45-12"><a href="#cb45-12"></a></span>
<span id="cb45-13"><a href="#cb45-13"></a><span class="kw">type</span> VM <span class="kw">struct</span> {</span>
<span id="cb45-14"><a href="#cb45-14"></a>    constants    []object.Object</span>
<span id="cb45-15"><a href="#cb45-15"></a>    instructions code.Instructions</span>
<span id="cb45-16"><a href="#cb45-16"></a></span>
<span id="cb45-17"><a href="#cb45-17"></a>    stack []object.Object</span>
<span id="cb45-18"><a href="#cb45-18"></a>    sp    <span class="dt">int</span> <span class="co">// Always points to the next value. Top of stack is stack[sp-1]</span></span>
<span id="cb45-19"><a href="#cb45-19"></a>}</span>
<span id="cb45-20"><a href="#cb45-20"></a></span>
<span id="cb45-21"><a href="#cb45-21"></a><span class="kw">func</span> New(bytecode *compiler.Bytecode) *VM {</span>
<span id="cb45-22"><a href="#cb45-22"></a>    <span class="kw">return</span> &amp;VM{</span>
<span id="cb45-23"><a href="#cb45-23"></a>        instructions: bytecode.Instructions,</span>
<span id="cb45-24"><a href="#cb45-24"></a>        constants:    bytecode.Constants,</span>
<span id="cb45-25"><a href="#cb45-25"></a></span>
<span id="cb45-26"><a href="#cb45-26"></a>        stack: <span class="bu">make</span>([]object.Object, StackSize),</span>
<span id="cb45-27"><a href="#cb45-27"></a>        sp:    <span class="dv">0</span>,</span>
<span id="cb45-28"><a href="#cb45-28"></a>    }</span>
<span id="cb45-29"><a href="#cb45-29"></a>}</span></code></pre></div>
<p>Our virtual machine is a struct with four fields. It holds the <code>constants</code> and <code>instructions</code> generated by the <code>compiler</code> and has a <code>stack</code>. Rather simple for something with such a grand name, isn’t it?</p>
<p>The <code>stack</code> is preallocated to have a <code>StackSize</code> number of elements, which should be enough for us. <code>sp</code> is the stackpointer, which we’ll increment or decrement to grow or shrink the stack, instead of modifying the <code>stack</code> slice itself.</p>
<p>Here’s the convention we’ll use for <code>stack</code> and <code>sp</code>: <code>sp</code> will always point to the <em>next</em> free slot in the stack. If there’s one element on the stack, located at index <code>0</code>, the value of <code>sp</code> would be <code>1</code> and to access the element we’d use <code>stack[sp-1]</code>. A new element would be stored at <code>stack[sp]</code>, before <code>sp</code> is incremented.</p>
<p>Knowing this, we define the <code>StackTop</code> method we use in our VM tests:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb46-1"><a href="#cb46-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb46-2"><a href="#cb46-2"></a></span>
<span id="cb46-3"><a href="#cb46-3"></a><span class="kw">func</span> (vm *VM) StackTop() object.Object {</span>
<span id="cb46-4"><a href="#cb46-4"></a>    <span class="kw">if</span> vm.sp == <span class="dv">0</span> {</span>
<span id="cb46-5"><a href="#cb46-5"></a>        <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb46-6"><a href="#cb46-6"></a>    }</span>
<span id="cb46-7"><a href="#cb46-7"></a>    <span class="kw">return</span> vm.stack[vm.sp<span class="dv">-1</span>]</span>
<span id="cb46-8"><a href="#cb46-8"></a>}</span></code></pre></div>
<p>Now the only thing that’s keeping us from running the tests is the missing <code>Run</code> method of the <code>VM</code>:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb47-1"><a href="#cb47-1"></a>$ go test ./vm</span>
<span id="cb47-2"><a href="#cb47-2"></a># monkey/vm</span>
<span id="cb47-3"><a href="#cb47-3"></a>vm/vm_test.go:41:11: vm.Run undefined (type *VM has no field or method Run)</span>
<span id="cb47-4"><a href="#cb47-4"></a>FAIL    monkey/vm [build failed]</span></code></pre></div>
<p>The <code>Run</code> method is what turns the <code>VM</code> into a virtual machine. It contains its heartbeat, the main loop, the fetch-decode-execute cycle:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb48-1"><a href="#cb48-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb48-2"><a href="#cb48-2"></a></span>
<span id="cb48-3"><a href="#cb48-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb48-4"><a href="#cb48-4"></a>    <span class="kw">for</span> ip := <span class="dv">0</span>; ip &lt; <span class="bu">len</span>(vm.instructions); ip++ {</span>
<span id="cb48-5"><a href="#cb48-5"></a>        op := code.Opcode(vm.instructions[ip])</span>
<span id="cb48-6"><a href="#cb48-6"></a></span>
<span id="cb48-7"><a href="#cb48-7"></a>        <span class="kw">switch</span> op {</span>
<span id="cb48-8"><a href="#cb48-8"></a>        }</span>
<span id="cb48-9"><a href="#cb48-9"></a>    }</span>
<span id="cb48-10"><a href="#cb48-10"></a></span>
<span id="cb48-11"><a href="#cb48-11"></a>    <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb48-12"><a href="#cb48-12"></a>}</span></code></pre></div>
<p>That’s the first part of the cycle, the “fetch”. We iterate through <code>vm.instructions</code> by incrementing the instruction pointer, <code>ip</code>, and fetch the current instruction by directly accessing <code>vm.instructions</code>. Then we turn the <code>byte</code> into an <code>Opcode</code>. It’s important that we do not use <code>code.Lookup</code> here to get from a <code>byte</code> to an <code>Opcode</code>. That would be far too slow. It costs time to move the byte around, lookup the opcode’s definition, return it and take it apart.</p>
<p>I know that this doesn’t sound like my usual chant of “we’re here to learn, not to build the fastest thing ever”, but we’re in <em>the</em> hot path here; everything we can get rid of, we should throw out. Using <code>code.Lookup</code> here would be like putting a sleep statement in the loop. And in contrast to a generic method that wants to lookup an opcode (like our mini-disassembler in <code>Instructions.String</code>) we have to encode our knowledge about the instructions into the VM’s <code>Run</code> method anyway. We can’t just delegate the execution away and treat every instruction the same.</p>
<p>Alas, fast as it may be, the “fetch” part alone is not enough:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb49-1"><a href="#cb49-1"></a>$ go test ./vm</span>
<span id="cb49-2"><a href="#cb49-2"></a>--- FAIL: TestIntegerArithmetic (0.00s)</span>
<span id="cb49-3"><a href="#cb49-3"></a> vm_test.go:20: testIntegerObject failed:\</span>
<span id="cb49-4"><a href="#cb49-4"></a>   object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</span>
<span id="cb49-5"><a href="#cb49-5"></a> vm_test.go:20: testIntegerObject failed:\</span>
<span id="cb49-6"><a href="#cb49-6"></a>   object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</span>
<span id="cb49-7"><a href="#cb49-7"></a> vm_test.go:20: testIntegerObject failed:\</span>
<span id="cb49-8"><a href="#cb49-8"></a>   object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</span>
<span id="cb49-9"><a href="#cb49-9"></a>FAIL</span>
<span id="cb49-10"><a href="#cb49-10"></a>FAIL    monkey/vm   0.006s</span></code></pre></div>
<p>Time to “decode” and “execute”. Decoding means adding a new <code>case</code> branch and decoding the operands of the instruction:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb50-1"><a href="#cb50-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb50-2"><a href="#cb50-2"></a></span>
<span id="cb50-3"><a href="#cb50-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb50-4"><a href="#cb50-4"></a>    <span class="co">// [...]</span></span>
<span id="cb50-5"><a href="#cb50-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb50-6"><a href="#cb50-6"></a>        <span class="kw">case</span> code.OpConstant:</span>
<span id="cb50-7"><a href="#cb50-7"></a>            constIndex := code.ReadUint16(vm.instructions[ip+<span class="dv">1</span>:])</span>
<span id="cb50-8"><a href="#cb50-8"></a>            ip += <span class="dv">2</span></span>
<span id="cb50-9"><a href="#cb50-9"></a>        }</span>
<span id="cb50-10"><a href="#cb50-10"></a>    <span class="co">// [...]</span></span>
<span id="cb50-11"><a href="#cb50-11"></a>}</span></code></pre></div>
<p>With the <code>code.ReadUint16</code> function we decode the operands in the bytecode, starting with the byte positioned right after the opcode, at <code>ip+1</code>. And we use <code>code.ReadUint16</code> and not <code>code.ReadOperands</code> for the same reason we don’t use <code>code.Lookup</code> when fetching the instruction: speed.</p>
<p>After decoding the operands, we must be careful to increment <code>ip</code> by the correct amount – the number of bytes we read to decode the operands. The result is that the next iteration of the loop starts with <code>ip</code> pointing to an opcode instead of an operand.</p>
<p>We still can’t run the tests, because the compiler now tells us to use the declared but unused <code>constIndex</code>. We better do that, by adding the “execute” part of our VM cycle:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb51-1"><a href="#cb51-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb51-2"><a href="#cb51-2"></a></span>
<span id="cb51-3"><a href="#cb51-3"></a><span class="kw">import</span> (</span>
<span id="cb51-4"><a href="#cb51-4"></a>    <span class="st">&quot;fmt&quot;</span></span>
<span id="cb51-5"><a href="#cb51-5"></a>    <span class="co">// [...]</span></span>
<span id="cb51-6"><a href="#cb51-6"></a>)</span>
<span id="cb51-7"><a href="#cb51-7"></a></span>
<span id="cb51-8"><a href="#cb51-8"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb51-9"><a href="#cb51-9"></a>    <span class="co">// [...]</span></span>
<span id="cb51-10"><a href="#cb51-10"></a>        <span class="kw">switch</span> op {</span>
<span id="cb51-11"><a href="#cb51-11"></a>        <span class="kw">case</span> code.OpConstant:</span>
<span id="cb51-12"><a href="#cb51-12"></a>            constIndex := code.ReadUint16(vm.instructions[ip+<span class="dv">1</span>:])</span>
<span id="cb51-13"><a href="#cb51-13"></a>            ip += <span class="dv">2</span></span>
<span id="cb51-14"><a href="#cb51-14"></a></span>
<span id="cb51-15"><a href="#cb51-15"></a>            err := vm.push(vm.constants[constIndex])</span>
<span id="cb51-16"><a href="#cb51-16"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb51-17"><a href="#cb51-17"></a>                <span class="kw">return</span> err</span>
<span id="cb51-18"><a href="#cb51-18"></a>            }</span>
<span id="cb51-19"><a href="#cb51-19"></a>        }</span>
<span id="cb51-20"><a href="#cb51-20"></a>    <span class="co">// [...]</span></span>
<span id="cb51-21"><a href="#cb51-21"></a>}</span>
<span id="cb51-22"><a href="#cb51-22"></a></span>
<span id="cb51-23"><a href="#cb51-23"></a><span class="kw">func</span> (vm *VM) push(o object.Object) <span class="dt">error</span> {</span>
<span id="cb51-24"><a href="#cb51-24"></a>    <span class="kw">if</span> vm.sp &gt;= StackSize {</span>
<span id="cb51-25"><a href="#cb51-25"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;stack overflow&quot;</span>)</span>
<span id="cb51-26"><a href="#cb51-26"></a>    }</span>
<span id="cb51-27"><a href="#cb51-27"></a></span>
<span id="cb51-28"><a href="#cb51-28"></a>    vm.stack[vm.sp] = o</span>
<span id="cb51-29"><a href="#cb51-29"></a>    vm.sp++</span>
<span id="cb51-30"><a href="#cb51-30"></a></span>
<span id="cb51-31"><a href="#cb51-31"></a>    <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb51-32"><a href="#cb51-32"></a>}</span></code></pre></div>
<p>We use <code>constIndex</code> to get to the constant in <code>vm.constants</code> and then push it on to the stack. The succinctly named <code>vm.push</code> method that takes care of checking the stack size, adding the object and incrementing the stackpointer, <code>sp</code>.</p>
<p>Our virtual machine has come to life:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb52-1"><a href="#cb52-1"></a>$ go test ./vm</span>
<span id="cb52-2"><a href="#cb52-2"></a>ok      monkey/vm   0.007s</span></code></pre></div>
<p>That means we have successfully defined our own bytecode format, built a compiler that translates a subset of Monkey into this bytecode format and created a virtual machine that executes the bytecode. Again, <code>ok</code> is rather somber – <code>itstimetodance</code> would be more appropriate.</p>
<p>We’ve also built a lot of infrastructure and tools to compile and execute these two <code>OpConstant</code> instruction. And at the moment that might feel excessive, but believe me, it’s going to pay off. We can already see the benefits when we add another opcode now.</p>
<h2 id="adding-on-the-stack">Adding on the Stack</h2>
<p>At the beginning of this chapter we set out to compile and execute the Monkey expression <code>1 + 2</code>. Now we’re nearly there. All that’s left to do is to actually add the integers we’ve pushed on to the stack. For that, we need a new opcode.</p>
<p>The new opcode is called <code>OpAdd</code> and tells the VM to pop the two topmost elements off the stack, add them together and push the result back on to the stack. In contrast to <code>OpConstant</code>, it doesn’t have any operands. It’s simply one byte, a single opcode:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb53-1"><a href="#cb53-1"></a><span class="co">// code/code.go</span></span>
<span id="cb53-2"><a href="#cb53-2"></a></span>
<span id="cb53-3"><a href="#cb53-3"></a><span class="kw">const</span> (</span>
<span id="cb53-4"><a href="#cb53-4"></a>    OpConstant Opcode = <span class="ot">iota</span></span>
<span id="cb53-5"><a href="#cb53-5"></a>    OpAdd</span>
<span id="cb53-6"><a href="#cb53-6"></a>)</span>
<span id="cb53-7"><a href="#cb53-7"></a></span>
<span id="cb53-8"><a href="#cb53-8"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb53-9"><a href="#cb53-9"></a>    OpConstant: {<span class="st">&quot;OpConstant&quot;</span>, []<span class="dt">int</span>{<span class="dv">2</span>}},</span>
<span id="cb53-10"><a href="#cb53-10"></a>    OpAdd:      {<span class="st">&quot;OpAdd&quot;</span>, []<span class="dt">int</span>{}},</span>
<span id="cb53-11"><a href="#cb53-11"></a>}</span></code></pre></div>
<p>Right next to <code>OpConstant</code> we add the new definition of <code>OpAdd</code>. There’s nothing remarkable here, except that the <code>OperandWidths</code> field in the <code>*Definition</code> holds an empty slice to signify that <code>OpAdd</code> doesn’t have any operands. And that’s only remarkable in how unremarkable it is. But we still need to make sure that our tooling can handle an opcode without any operands. First on the list is <code>Make</code>:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb54-1"><a href="#cb54-1"></a><span class="co">// code/code_test.go</span></span>
<span id="cb54-2"><a href="#cb54-2"></a></span>
<span id="cb54-3"><a href="#cb54-3"></a><span class="kw">func</span> TestMake(t *testing.T) {</span>
<span id="cb54-4"><a href="#cb54-4"></a>    tests := []<span class="kw">struct</span> {</span>
<span id="cb54-5"><a href="#cb54-5"></a>        op       Opcode</span>
<span id="cb54-6"><a href="#cb54-6"></a>        operands []<span class="dt">int</span></span>
<span id="cb54-7"><a href="#cb54-7"></a>        expected []<span class="dt">byte</span></span>
<span id="cb54-8"><a href="#cb54-8"></a>    }{</span>
<span id="cb54-9"><a href="#cb54-9"></a>        <span class="co">// [...]</span></span>
<span id="cb54-10"><a href="#cb54-10"></a>        {OpAdd, []<span class="dt">int</span>{}, []<span class="dt">byte</span>{<span class="dt">byte</span>(OpAdd)}},</span>
<span id="cb54-11"><a href="#cb54-11"></a>    }</span>
<span id="cb54-12"><a href="#cb54-12"></a></span>
<span id="cb54-13"><a href="#cb54-13"></a>    <span class="co">// [...]</span></span>
<span id="cb54-14"><a href="#cb54-14"></a>}</span></code></pre></div>
<p>One new test case to make sure that <code>Make</code> knows how to encode a single <code>Opcode</code> into a byte slice. And guess what? It already does:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb55-1"><a href="#cb55-1"></a>$ go test ./code</span>
<span id="cb55-2"><a href="#cb55-2"></a>ok      monkey/code 0.006s</span></code></pre></div>
<p>That means we can now use <code>Make</code> to test whether the <code>Instructions.String</code> method can also handle <code>OpAdd</code>. We change the test input and the expectation to include it:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb56-1"><a href="#cb56-1"></a><span class="co">// code/code_test.go</span></span>
<span id="cb56-2"><a href="#cb56-2"></a></span>
<span id="cb56-3"><a href="#cb56-3"></a><span class="kw">func</span> TestInstructionsString(t *testing.T) {</span>
<span id="cb56-4"><a href="#cb56-4"></a>    instructions := []Instructions{</span>
<span id="cb56-5"><a href="#cb56-5"></a>        Make(OpAdd),</span>
<span id="cb56-6"><a href="#cb56-6"></a>        Make(OpConstant, <span class="dv">2</span>),</span>
<span id="cb56-7"><a href="#cb56-7"></a>        Make(OpConstant, <span class="dv">65535</span>),</span>
<span id="cb56-8"><a href="#cb56-8"></a>    }</span>
<span id="cb56-9"><a href="#cb56-9"></a></span>
<span id="cb56-10"><a href="#cb56-10"></a>    expected := <span class="st">`0000 OpAdd</span></span>
<span id="cb56-11"><a href="#cb56-11"></a><span class="st">0001 OpConstant 2</span></span>
<span id="cb56-12"><a href="#cb56-12"></a><span class="st">0004 OpConstant 65535</span></span>
<span id="cb56-13"><a href="#cb56-13"></a><span class="st">`</span></span>
<span id="cb56-14"><a href="#cb56-14"></a></span>
<span id="cb56-15"><a href="#cb56-15"></a>    <span class="co">// [...]</span></span>
<span id="cb56-16"><a href="#cb56-16"></a>}</span></code></pre></div>
<p>But, we didn’t get so lucky this time, the test fails:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb57-1"><a href="#cb57-1"></a>$ go test ./code</span>
<span id="cb57-2"><a href="#cb57-2"></a>--- FAIL: TestInstructionsString (0.00s)</span>
<span id="cb57-3"><a href="#cb57-3"></a> code_test.go:51: instructions wrongly formatted.</span>
<span id="cb57-4"><a href="#cb57-4"></a>  want=&quot;0000 OpAdd\n0001 OpConstant 2\n0004 OpConstant 65535\n&quot;</span>
<span id="cb57-5"><a href="#cb57-5"></a>  got=&quot;0000 ERROR: unhandled operandCount for OpAdd\n\n\</span>
<span id="cb57-6"><a href="#cb57-6"></a>    0001 OpConstant 2\n0004 OpConstant 65535\n&quot;</span>
<span id="cb57-7"><a href="#cb57-7"></a>FAIL</span>
<span id="cb57-8"><a href="#cb57-8"></a>FAIL    monkey/code 0.007s</span></code></pre></div>
<p>The error message points in the right direction, though. We need to extend the <code>switch</code> statement in the <code>Instructions.fmtInstruction</code> method to handle opcodes with no operands:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb58-1"><a href="#cb58-1"></a><span class="co">// code/code.go</span></span>
<span id="cb58-2"><a href="#cb58-2"></a></span>
<span id="cb58-3"><a href="#cb58-3"></a><span class="kw">func</span> (ins Instructions) fmtInstruction(def *Definition, operands []<span class="dt">int</span>) <span class="dt">string</span> {</span>
<span id="cb58-4"><a href="#cb58-4"></a>    <span class="co">// [...]</span></span>
<span id="cb58-5"><a href="#cb58-5"></a></span>
<span id="cb58-6"><a href="#cb58-6"></a>    <span class="kw">switch</span> operandCount {</span>
<span id="cb58-7"><a href="#cb58-7"></a>    <span class="kw">case</span> <span class="dv">0</span>:</span>
<span id="cb58-8"><a href="#cb58-8"></a>        <span class="kw">return</span> def.Name</span>
<span id="cb58-9"><a href="#cb58-9"></a>    <span class="kw">case</span> <span class="dv">1</span>:</span>
<span id="cb58-10"><a href="#cb58-10"></a>        <span class="kw">return</span> fmt.Sprintf(<span class="st">&quot;%s %d&quot;</span>, def.Name, operands[<span class="dv">0</span>])</span>
<span id="cb58-11"><a href="#cb58-11"></a>    }</span>
<span id="cb58-12"><a href="#cb58-12"></a></span>
<span id="cb58-13"><a href="#cb58-13"></a>    <span class="kw">return</span> fmt.Sprintf(<span class="st">&quot;ERROR: unhandled operandCount for %s</span><span class="ch">\n</span><span class="st">&quot;</span>, def.Name)</span>
<span id="cb58-14"><a href="#cb58-14"></a>}</span></code></pre></div>
<p>That turns our tests from red to green again:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb59-1"><a href="#cb59-1"></a>$ go test ./code</span>
<span id="cb59-2"><a href="#cb59-2"></a>ok      monkey/code 0.006s</span></code></pre></div>
<p>And since <code>OpAdd</code> doesn’t have any operands, we don’t need to change <code>ReadOperands</code>, which means we’re done with updating our tools. <code>OpAdd</code> is now fully defined and ready to be used in our compiler.</p>
<p>Now, think back to our first compiler test, <code>TestIntegerArithmetic</code>. We asserted that the Monkey expression <code>1 + 2</code> should result in two <code>OpConstant</code> instructions. That was wrong back then and it’s still wrong. But we set out to build the smallest possible compiler that only does one thing, pushing integers on to the stack, so that was okay. Now we want to add those numbers, which means it’s time to fix the test by adding the missing <code>OpAdd</code> instruction:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb60-1"><a href="#cb60-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb60-2"><a href="#cb60-2"></a></span>
<span id="cb60-3"><a href="#cb60-3"></a><span class="kw">func</span> TestIntegerArithmetic(t *testing.T) {</span>
<span id="cb60-4"><a href="#cb60-4"></a>    tests := []compilerTestCase{</span>
<span id="cb60-5"><a href="#cb60-5"></a>        {</span>
<span id="cb60-6"><a href="#cb60-6"></a>            input:             <span class="st">&quot;1 + 2&quot;</span>,</span>
<span id="cb60-7"><a href="#cb60-7"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">1</span>, <span class="dv">2</span>},</span>
<span id="cb60-8"><a href="#cb60-8"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb60-9"><a href="#cb60-9"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb60-10"><a href="#cb60-10"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb60-11"><a href="#cb60-11"></a>                code.Make(code.OpAdd),</span>
<span id="cb60-12"><a href="#cb60-12"></a>            },</span>
<span id="cb60-13"><a href="#cb60-13"></a>        },</span>
<span id="cb60-14"><a href="#cb60-14"></a>    }</span>
<span id="cb60-15"><a href="#cb60-15"></a>    <span class="co">// [...]</span></span>
<span id="cb60-16"><a href="#cb60-16"></a>}</span></code></pre></div>
<p><code>expectedInstructions</code> is now correct. Two <code>OpConstant</code> instructions to push the two constants on to the stack and then an <code>OpAdd</code> instruction that should cause the VM to add them together.</p>
<p>Since we only updated our tools but not yet the compiler, the test now tells us which instruction we’re not emitting:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb61-1"><a href="#cb61-1"></a>$ go test ./compiler</span>
<span id="cb61-2"><a href="#cb61-2"></a>--- FAIL: TestIntegerArithmetic (0.00s)</span>
<span id="cb61-3"><a href="#cb61-3"></a> compiler_test.go:26: testInstructions failed: wrong instructions length.</span>
<span id="cb61-4"><a href="#cb61-4"></a>  want=&quot;0000 OpConstant 0\n0003 OpConstant 1\n0006 OpAdd\n&quot;</span>
<span id="cb61-5"><a href="#cb61-5"></a>  got =&quot;0000 OpConstant 0\n0003 OpConstant 1\n&quot;</span>
<span id="cb61-6"><a href="#cb61-6"></a>FAIL</span>
<span id="cb61-7"><a href="#cb61-7"></a>FAIL    monkey/compiler 0.007s</span></code></pre></div>
<p>It’s my unwavering opinion that the <code>Instructions.String</code> method is worth its bytes in gold.</p>
<p>This failing test now tells us – nicely formatted and readable! – that we need to emit an <code>OpAdd</code> instruction. And since we already came across an <code>*ast.InfixExpression</code> in the compiler’s <code>Compile</code> method, we know where to do that:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb62-1"><a href="#cb62-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb62-2"><a href="#cb62-2"></a></span>
<span id="cb62-3"><a href="#cb62-3"></a><span class="kw">import</span> (</span>
<span id="cb62-4"><a href="#cb62-4"></a>    <span class="st">&quot;fmt&quot;</span></span>
<span id="cb62-5"><a href="#cb62-5"></a>    <span class="co">// [...]</span></span>
<span id="cb62-6"><a href="#cb62-6"></a>)</span>
<span id="cb62-7"><a href="#cb62-7"></a></span>
<span id="cb62-8"><a href="#cb62-8"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb62-9"><a href="#cb62-9"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb62-10"><a href="#cb62-10"></a>    <span class="co">// [...]</span></span>
<span id="cb62-11"><a href="#cb62-11"></a></span>
<span id="cb62-12"><a href="#cb62-12"></a>    <span class="kw">case</span> *ast.InfixExpression:</span>
<span id="cb62-13"><a href="#cb62-13"></a>        err := c.Compile(node.Left)</span>
<span id="cb62-14"><a href="#cb62-14"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb62-15"><a href="#cb62-15"></a>            <span class="kw">return</span> err</span>
<span id="cb62-16"><a href="#cb62-16"></a>        }</span>
<span id="cb62-17"><a href="#cb62-17"></a></span>
<span id="cb62-18"><a href="#cb62-18"></a>        err = c.Compile(node.Right)</span>
<span id="cb62-19"><a href="#cb62-19"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb62-20"><a href="#cb62-20"></a>            <span class="kw">return</span> err</span>
<span id="cb62-21"><a href="#cb62-21"></a>        }</span>
<span id="cb62-22"><a href="#cb62-22"></a></span>
<span id="cb62-23"><a href="#cb62-23"></a>        <span class="kw">switch</span> node.Operator {</span>
<span id="cb62-24"><a href="#cb62-24"></a>        <span class="kw">case</span> <span class="st">&quot;+&quot;</span>:</span>
<span id="cb62-25"><a href="#cb62-25"></a>            c.emit(code.OpAdd)</span>
<span id="cb62-26"><a href="#cb62-26"></a>        <span class="kw">default</span>:</span>
<span id="cb62-27"><a href="#cb62-27"></a>            <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;unknown operator %s&quot;</span>, node.Operator)</span>
<span id="cb62-28"><a href="#cb62-28"></a>        }</span>
<span id="cb62-29"><a href="#cb62-29"></a></span>
<span id="cb62-30"><a href="#cb62-30"></a>    <span class="co">// [...]</span></span>
<span id="cb62-31"><a href="#cb62-31"></a>    }</span>
<span id="cb62-32"><a href="#cb62-32"></a></span>
<span id="cb62-33"><a href="#cb62-33"></a>    <span class="co">// [...]</span></span>
<span id="cb62-34"><a href="#cb62-34"></a>}</span></code></pre></div>
<p>In the new <code>switch</code> statement we check the <code>Operator</code> field of the <code>*ast.InfixExpression</code> node. In case we have a <code>+</code> at hand (which we do in our test) we <code>c.emit</code> an <code>OpAdd</code> instruction. Then, to be safe, we add a <code>default</code> branch that returns an error in case we don’t know how to compile a specific infix operator. And yes, you guessed it, we’re going to add more <code>case</code> branches later on.</p>
<p>And that’s it. Our compiler is now able to emit <code>OpAdd</code> instructions:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb63-1"><a href="#cb63-1"></a>$ go test ./compiler</span>
<span id="cb63-2"><a href="#cb63-2"></a>ok      monkey/compiler 0.006s</span></code></pre></div>
<p>This starts to feel like a winning streak. And now, instead of going on any detour, we move directly to the VM and implement <code>OpAdd</code> there too.</p>
<p>The best part about that is that we don’t have to write a new test – we just have to fix our old one. Because in the <code>vm</code> package we also wrote a “wrong” test before. Remember our assertion about <code>1 + 2</code> leaving <code>2</code> on the stack? We need to change that:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb64-1"><a href="#cb64-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb64-2"><a href="#cb64-2"></a></span>
<span id="cb64-3"><a href="#cb64-3"></a><span class="kw">func</span> TestIntegerArithmetic(t *testing.T) {</span>
<span id="cb64-4"><a href="#cb64-4"></a>    tests := []vmTestCase{</span>
<span id="cb64-5"><a href="#cb64-5"></a>        <span class="co">// [...]</span></span>
<span id="cb64-6"><a href="#cb64-6"></a>        {<span class="st">&quot;1 + 2&quot;</span>, <span class="dv">3</span>},</span>
<span id="cb64-7"><a href="#cb64-7"></a>    }</span>
<span id="cb64-8"><a href="#cb64-8"></a></span>
<span id="cb64-9"><a href="#cb64-9"></a>    runVmTests(t, tests)</span>
<span id="cb64-10"><a href="#cb64-10"></a>}</span></code></pre></div>
<p>Now we expect a <code>3</code> instead of a <code>2</code>. But that alone makes the test fail:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb65-1"><a href="#cb65-1"></a>$ go test ./vm</span>
<span id="cb65-2"><a href="#cb65-2"></a>--- FAIL: TestIntegerArithmetic (0.00s)</span>
<span id="cb65-3"><a href="#cb65-3"></a> vm_test.go:20: testIntegerObject failed:\</span>
<span id="cb65-4"><a href="#cb65-4"></a>   object has wrong value. got=2, want=3</span>
<span id="cb65-5"><a href="#cb65-5"></a>FAIL</span>
<span id="cb65-6"><a href="#cb65-6"></a>FAIL    monkey/vm   0.007s</span></code></pre></div>
<p>We now have to actually do something with the integers we pushed on to the stack, which means we’ve finally arrived at stack arithmetic. And what’s the first thing we need to do to add two numbers together? Exactly, pop the operands off the stack. To help with that, we add another helper to <code>VM</code>:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb66-1"><a href="#cb66-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb66-2"><a href="#cb66-2"></a></span>
<span id="cb66-3"><a href="#cb66-3"></a><span class="kw">func</span> (vm *VM) pop() object.Object {</span>
<span id="cb66-4"><a href="#cb66-4"></a>    o := vm.stack[vm.sp<span class="dv">-1</span>]</span>
<span id="cb66-5"><a href="#cb66-5"></a>    vm.sp--</span>
<span id="cb66-6"><a href="#cb66-6"></a>    <span class="kw">return</span> o</span>
<span id="cb66-7"><a href="#cb66-7"></a>}</span></code></pre></div>
<p>We first take the element from the top of the stack, located at <code>vm.sp-1</code>, and put it on the side. Then we decrement <code>vm.sp</code>, allowing the location of element that was just popped off being overwritten eventually.</p>
<p>In order to use this new <code>pop</code> method we first need to add the “decode” part for the new <code>OpAdd</code> instruction. But since that’s not really worth mentioning on its own, here it is with the first part of the “execute”:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb67-1"><a href="#cb67-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb67-2"><a href="#cb67-2"></a></span>
<span id="cb67-3"><a href="#cb67-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb67-4"><a href="#cb67-4"></a>    <span class="co">// [...]</span></span>
<span id="cb67-5"><a href="#cb67-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb67-6"><a href="#cb67-6"></a>        <span class="co">// [...]</span></span>
<span id="cb67-7"><a href="#cb67-7"></a></span>
<span id="cb67-8"><a href="#cb67-8"></a>        <span class="kw">case</span> code.OpAdd:</span>
<span id="cb67-9"><a href="#cb67-9"></a>            right := vm.pop()</span>
<span id="cb67-10"><a href="#cb67-10"></a>            left := vm.pop()</span>
<span id="cb67-11"><a href="#cb67-11"></a>            leftValue := left.(*object.Integer).Value</span>
<span id="cb67-12"><a href="#cb67-12"></a>            rightValue := right.(*object.Integer).Value</span>
<span id="cb67-13"><a href="#cb67-13"></a></span>
<span id="cb67-14"><a href="#cb67-14"></a>        }</span>
<span id="cb67-15"><a href="#cb67-15"></a>    <span class="co">// [...]</span></span>
<span id="cb67-16"><a href="#cb67-16"></a>}</span></code></pre></div>
<p>Extending the “decode” part of the run-loop means adding the new <code>case code.OpAdd</code>. After that, we’re ready to implement the operation itself, the “execute”. In this case we start by popping the operands off the stack and unwrapping their values into <code>leftValue</code> and <code>rightValue</code>.</p>
<p>It looks innocent enough, but here is where subtle bugs can creep in. We implicitly assume that the <code>right</code> operand of the infix operator is the last one to be pushed on to the stack. In the case of <code>+</code> the order of the operands doesn’t matter, so the implicitness is not an immediate problem. But there are other operators where the wrong order of the operands can cause wrong results. And I’m not talking about some exotic operator here – minus also needs its operand to be in the correct order.</p>
<p>That was just the start of the implementation of <code>OpAdd</code> and the VM test is still failing, so let’s finish it with one elegant addition:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb68-1"><a href="#cb68-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb68-2"><a href="#cb68-2"></a></span>
<span id="cb68-3"><a href="#cb68-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb68-4"><a href="#cb68-4"></a>    <span class="co">// [...]</span></span>
<span id="cb68-5"><a href="#cb68-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb68-6"><a href="#cb68-6"></a>        <span class="co">// [...]</span></span>
<span id="cb68-7"><a href="#cb68-7"></a></span>
<span id="cb68-8"><a href="#cb68-8"></a>        <span class="kw">case</span> code.OpAdd:</span>
<span id="cb68-9"><a href="#cb68-9"></a>            right := vm.pop()</span>
<span id="cb68-10"><a href="#cb68-10"></a>            left := vm.pop()</span>
<span id="cb68-11"><a href="#cb68-11"></a>            leftValue := left.(*object.Integer).Value</span>
<span id="cb68-12"><a href="#cb68-12"></a>            rightValue := right.(*object.Integer).Value</span>
<span id="cb68-13"><a href="#cb68-13"></a></span>
<span id="cb68-14"><a href="#cb68-14"></a>            result := leftValue + rightValue</span>
<span id="cb68-15"><a href="#cb68-15"></a>            vm.push(&amp;object.Integer{Value: result})</span>
<span id="cb68-16"><a href="#cb68-16"></a></span>
<span id="cb68-17"><a href="#cb68-17"></a>        <span class="co">// [...]</span></span>
<span id="cb68-18"><a href="#cb68-18"></a>        }</span>
<span id="cb68-19"><a href="#cb68-19"></a>    <span class="co">// [...]</span></span>
<span id="cb68-20"><a href="#cb68-20"></a>}</span></code></pre></div>
<p>Here’s what the two added lines are doing: add <code>leftValue</code> and <code>rightValue</code> together, turn the result into an <code>*object.Integer</code> and push that on to the stack. And here’s what that amounts to:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb69-1"><a href="#cb69-1"></a>$ go test ./vm</span>
<span id="cb69-2"><a href="#cb69-2"></a>ok      monkey/vm   0.006s</span></code></pre></div>
<p>Passing tests! We did it: we achieved the goal of this chapter and successfully compiled and executed the Monkey expression <code>1 + 2</code>.</p>
<p>We can lean back now, take a big breath, relax and ponder how it feels to write a compiler and a virtual machine. I bet it wasn’t as hard as you thought it would be. Granted, our compiler and the VM are not what you’d call “feature rich”. But we’re not done yet – far from that – and we’ve built important infrastructure that’s essential to both the compiler and the VM. We can be proud of ourselves.</p>
<h2 id="hooking-up-the-repl">Hooking up the REPL</h2>
<p>Before we move on, we can hook up the compiler and the VM to our REPL. That allows us to get instant feedback when we want to experiment with Monkey. All that takes is to remove the evaluator and the environment setup from our REPL’s <code>Start</code> function and replace it with the calls to the compiler and the VM we already know from our tests:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb70-1"><a href="#cb70-1"></a><span class="co">// repl/repl.go</span></span>
<span id="cb70-2"><a href="#cb70-2"></a></span>
<span id="cb70-3"><a href="#cb70-3"></a><span class="kw">import</span> (</span>
<span id="cb70-4"><a href="#cb70-4"></a>    <span class="st">&quot;bufio&quot;</span></span>
<span id="cb70-5"><a href="#cb70-5"></a>    <span class="st">&quot;fmt&quot;</span></span>
<span id="cb70-6"><a href="#cb70-6"></a>    <span class="st">&quot;io&quot;</span></span>
<span id="cb70-7"><a href="#cb70-7"></a>    <span class="st">&quot;monkey/compiler&quot;</span></span>
<span id="cb70-8"><a href="#cb70-8"></a>    <span class="st">&quot;monkey/lexer&quot;</span></span>
<span id="cb70-9"><a href="#cb70-9"></a>    <span class="st">&quot;monkey/parser&quot;</span></span>
<span id="cb70-10"><a href="#cb70-10"></a>    <span class="st">&quot;monkey/vm&quot;</span></span>
<span id="cb70-11"><a href="#cb70-11"></a>)</span>
<span id="cb70-12"><a href="#cb70-12"></a></span>
<span id="cb70-13"><a href="#cb70-13"></a><span class="kw">func</span> Start(in io.Reader, out io.Writer) {</span>
<span id="cb70-14"><a href="#cb70-14"></a>    scanner := bufio.NewScanner(in)</span>
<span id="cb70-15"><a href="#cb70-15"></a></span>
<span id="cb70-16"><a href="#cb70-16"></a>    <span class="kw">for</span> {</span>
<span id="cb70-17"><a href="#cb70-17"></a>        fmt.Fprintf(out, PROMPT)</span>
<span id="cb70-18"><a href="#cb70-18"></a>        scanned := scanner.Scan()</span>
<span id="cb70-19"><a href="#cb70-19"></a>        <span class="kw">if</span> !scanned {</span>
<span id="cb70-20"><a href="#cb70-20"></a>            <span class="kw">return</span></span>
<span id="cb70-21"><a href="#cb70-21"></a>        }</span>
<span id="cb70-22"><a href="#cb70-22"></a></span>
<span id="cb70-23"><a href="#cb70-23"></a>        line := scanner.Text()</span>
<span id="cb70-24"><a href="#cb70-24"></a>        l := lexer.New(line)</span>
<span id="cb70-25"><a href="#cb70-25"></a>        p := parser.New(l)</span>
<span id="cb70-26"><a href="#cb70-26"></a></span>
<span id="cb70-27"><a href="#cb70-27"></a>        program := p.ParseProgram()</span>
<span id="cb70-28"><a href="#cb70-28"></a>        <span class="kw">if</span> <span class="bu">len</span>(p.Errors()) != <span class="dv">0</span> {</span>
<span id="cb70-29"><a href="#cb70-29"></a>            printParserErrors(out, p.Errors())</span>
<span id="cb70-30"><a href="#cb70-30"></a>            <span class="kw">continue</span></span>
<span id="cb70-31"><a href="#cb70-31"></a>        }</span>
<span id="cb70-32"><a href="#cb70-32"></a></span>
<span id="cb70-33"><a href="#cb70-33"></a>        comp := compiler.New()</span>
<span id="cb70-34"><a href="#cb70-34"></a>        err := comp.Compile(program)</span>
<span id="cb70-35"><a href="#cb70-35"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb70-36"><a href="#cb70-36"></a>            fmt.Fprintf(out, <span class="st">&quot;Woops! Compilation failed:</span><span class="ch">\n</span><span class="st"> %s</span><span class="ch">\n</span><span class="st">&quot;</span>, err)</span>
<span id="cb70-37"><a href="#cb70-37"></a>            <span class="kw">continue</span></span>
<span id="cb70-38"><a href="#cb70-38"></a>        }</span>
<span id="cb70-39"><a href="#cb70-39"></a></span>
<span id="cb70-40"><a href="#cb70-40"></a>        machine := vm.New(comp.Bytecode())</span>
<span id="cb70-41"><a href="#cb70-41"></a>        err = machine.Run()</span>
<span id="cb70-42"><a href="#cb70-42"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb70-43"><a href="#cb70-43"></a>            fmt.Fprintf(out, <span class="st">&quot;Woops! Executing bytecode failed:</span><span class="ch">\n</span><span class="st"> %s</span><span class="ch">\n</span><span class="st">&quot;</span>, err)</span>
<span id="cb70-44"><a href="#cb70-44"></a>            <span class="kw">continue</span></span>
<span id="cb70-45"><a href="#cb70-45"></a>        }</span>
<span id="cb70-46"><a href="#cb70-46"></a></span>
<span id="cb70-47"><a href="#cb70-47"></a>        stackTop := machine.StackTop()</span>
<span id="cb70-48"><a href="#cb70-48"></a>        io.WriteString(out, stackTop.Inspect())</span>
<span id="cb70-49"><a href="#cb70-49"></a>        io.WriteString(out, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb70-50"><a href="#cb70-50"></a>    }</span>
<span id="cb70-51"><a href="#cb70-51"></a>}</span></code></pre></div>
<p>First we tokenize the input, then we parse it, then we compile and execute the program. We also replace the previous printing of <code>Eval</code>’s return value with printing the object that sits on top of the VM’s stack.</p>
<p>Now we can start up the REPL and see our compiler and VM work behind the scenes:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb71-1"><a href="#cb71-1"></a>$ go build -o monkey . &amp;&amp; ./monkey</span>
<span id="cb71-2"><a href="#cb71-2"></a>Hello mrnugget! This is the Monkey programming language!</span>
<span id="cb71-3"><a href="#cb71-3"></a>Feel free to type in commands</span>
<span id="cb71-4"><a href="#cb71-4"></a>&gt;&gt; 1</span>
<span id="cb71-5"><a href="#cb71-5"></a>1</span>
<span id="cb71-6"><a href="#cb71-6"></a>&gt;&gt; 1 + 2</span>
<span id="cb71-7"><a href="#cb71-7"></a>3</span>
<span id="cb71-8"><a href="#cb71-8"></a>&gt;&gt; 1 + 2 + 3</span>
<span id="cb71-9"><a href="#cb71-9"></a>6</span>
<span id="cb71-10"><a href="#cb71-10"></a>&gt;&gt; 1000 + 555</span>
<span id="cb71-11"><a href="#cb71-11"></a>1555</span></code></pre></div>
<p>Beautiful. But, of course, it all comes crashing down as soon as we want to do more than add two numbers together:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb72-1"><a href="#cb72-1"></a>&gt;&gt; 99 - 1</span>
<span id="cb72-2"><a href="#cb72-2"></a>Woops! Compilation failed:</span>
<span id="cb72-3"><a href="#cb72-3"></a> unknown operator -</span>
<span id="cb72-4"><a href="#cb72-4"></a>&gt;&gt; 80 / 2</span>
<span id="cb72-5"><a href="#cb72-5"></a>Woops! Compilation failed:</span>
<span id="cb72-6"><a href="#cb72-6"></a> unknown operator /</span></code></pre></div>
<p>We still have work to do. Let’s get to it.</p>
<h1 id="compiling-expressions">Compiling Expressions</h1>
<p>In the previous two chapters we learned a lot of new and strange things, built a tiny compiler, a virtual machine and defined bytecode instructions. In this one, we’ll use our newfound knowledge of bytecode compilation and execution, and combine it with what we know from the first book to add support for all the infix and prefix operators Monkey supports.</p>
<p>That not only allows us to familiarize ourselves with our codebase and further extend its infrastructure but to also catch our breath. Besides, we have some cleaning up to do before we can move on. The thing most in need of a scrub? Our stack.</p>
<h2 id="cleaning-up-the-stack">Cleaning Up the Stack</h2>
<p>In their current state, the only thing our compiler and our VM are capable of is adding two numbers. Give them the expression <code>1 + 2</code> and our VM will correctly put <code>3</code> on its stack. That’s exactly what we want, but there’s one issue lurking in the shadows: the <code>3</code> stays on the stack and will stay there for all eternity if we don’t do something about it.</p>
<p>The problem is not with the expression <code>1 + 2</code> itself, but rather where it occurs. It’s part of an <em>expression statement</em>. As a quick refresher, we have three types of statements in Monkey: let statements, return statements and expression statements. Whereas the first two explicitly reuse the value their child-expression nodes produce, expression statements merely wrap expressions so they can occur on their own. The value they produce is not reused, by definition. But now our problem is that we <em>do</em> reuse it, because we involuntarily keep it on the stack.</p>
<p>Take a look at the following Monkey program:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb73-1"><a href="#cb73-1"></a><span class="dv">1</span><span class="op">;</span></span>
<span id="cb73-2"><a href="#cb73-2"></a><span class="dv">2</span><span class="op">;</span></span>
<span id="cb73-3"><a href="#cb73-3"></a><span class="dv">3</span><span class="op">;</span></span></code></pre></div>
<p>That’s three separate expression statements. And you know what ends up on the stack? Not just the value produced last, <code>3</code>, but everything: <code>1</code>, <code>2</code> and <code>3</code>. If we have a Monkey program consisting of lots of expression statements we could fill up the stack by accident. That’s not good.</p>
<p>In order to fix that, we need to do two things. First, we need to define a new opcode that tells the VM to pop the topmost element off the stack. Second, we need to emit this opcode after every expression statement.</p>
<p>We start with the definition of the opcode, the aptly name <code>OpPop</code>:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb74-1"><a href="#cb74-1"></a><span class="co">// code/code.go</span></span>
<span id="cb74-2"><a href="#cb74-2"></a></span>
<span id="cb74-3"><a href="#cb74-3"></a><span class="kw">const</span> (</span>
<span id="cb74-4"><a href="#cb74-4"></a>    <span class="co">// [...]</span></span>
<span id="cb74-5"><a href="#cb74-5"></a></span>
<span id="cb74-6"><a href="#cb74-6"></a>    OpPop</span>
<span id="cb74-7"><a href="#cb74-7"></a>)</span>
<span id="cb74-8"><a href="#cb74-8"></a></span>
<span id="cb74-9"><a href="#cb74-9"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb74-10"><a href="#cb74-10"></a>    <span class="co">// [...]</span></span>
<span id="cb74-11"><a href="#cb74-11"></a></span>
<span id="cb74-12"><a href="#cb74-12"></a>    OpPop:      {<span class="st">&quot;OpPop&quot;</span>, []<span class="dt">int</span>{}},</span>
<span id="cb74-13"><a href="#cb74-13"></a>}</span></code></pre></div>
<p><code>OpPop</code> doesn’t have any operands, just like <code>OpAdd</code>. Its only job is to tell the VM to pop the topmost element off the stack and for that it doesn’t need an operand.</p>
<p>Now we need to use this new opcode to clean the stack after every expression statement. Thankfully, it’s easy to assert this new behaviour in our test suite, since we don’t have a lot of compiler tests yet, which is also why I thought it wise to introduce <code>OpPop</code> now instead of two chapters down the road. We only need to change our single test case in <code>TestIntegerArithmetic</code>:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb75-1"><a href="#cb75-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb75-2"><a href="#cb75-2"></a></span>
<span id="cb75-3"><a href="#cb75-3"></a><span class="kw">func</span> TestIntegerArithmetic(t *testing.T) {</span>
<span id="cb75-4"><a href="#cb75-4"></a>    tests := []compilerTestCase{</span>
<span id="cb75-5"><a href="#cb75-5"></a>        {</span>
<span id="cb75-6"><a href="#cb75-6"></a>            input:             <span class="st">&quot;1 + 2&quot;</span>,</span>
<span id="cb75-7"><a href="#cb75-7"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">1</span>, <span class="dv">2</span>},</span>
<span id="cb75-8"><a href="#cb75-8"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb75-9"><a href="#cb75-9"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb75-10"><a href="#cb75-10"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb75-11"><a href="#cb75-11"></a>                code.Make(code.OpAdd),</span>
<span id="cb75-12"><a href="#cb75-12"></a>                code.Make(code.OpPop),</span>
<span id="cb75-13"><a href="#cb75-13"></a>            },</span>
<span id="cb75-14"><a href="#cb75-14"></a>        },</span>
<span id="cb75-15"><a href="#cb75-15"></a>    }</span>
<span id="cb75-16"><a href="#cb75-16"></a></span>
<span id="cb75-17"><a href="#cb75-17"></a>    runCompilerTests(t, tests)</span>
<span id="cb75-18"><a href="#cb75-18"></a>}</span></code></pre></div>
<p>The only change here is the new line containing the <code>code.Make(code.OpPop)</code> call. We assert that the compiled expression statement should be followed by an <code>OpPop</code> instruction. The desired behaviour can be made even clearer by adding another test with multiple expression statements:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb76-1"><a href="#cb76-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb76-2"><a href="#cb76-2"></a></span>
<span id="cb76-3"><a href="#cb76-3"></a><span class="kw">func</span> TestIntegerArithmetic(t *testing.T) {</span>
<span id="cb76-4"><a href="#cb76-4"></a>    tests := []compilerTestCase{</span>
<span id="cb76-5"><a href="#cb76-5"></a>        <span class="co">// [...]</span></span>
<span id="cb76-6"><a href="#cb76-6"></a>        {</span>
<span id="cb76-7"><a href="#cb76-7"></a>            input:             <span class="st">&quot;1; 2&quot;</span>,</span>
<span id="cb76-8"><a href="#cb76-8"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">1</span>, <span class="dv">2</span>},</span>
<span id="cb76-9"><a href="#cb76-9"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb76-10"><a href="#cb76-10"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb76-11"><a href="#cb76-11"></a>                code.Make(code.OpPop),</span>
<span id="cb76-12"><a href="#cb76-12"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb76-13"><a href="#cb76-13"></a>                code.Make(code.OpPop),</span>
<span id="cb76-14"><a href="#cb76-14"></a>            },</span>
<span id="cb76-15"><a href="#cb76-15"></a>        },</span>
<span id="cb76-16"><a href="#cb76-16"></a>    }</span>
<span id="cb76-17"><a href="#cb76-17"></a></span>
<span id="cb76-18"><a href="#cb76-18"></a>    runCompilerTests(t, tests)</span>
<span id="cb76-19"><a href="#cb76-19"></a>}</span></code></pre></div>
<p>Please note the <code>;</code> that separates the <code>1</code> from the <code>2</code>. Both integer literals are separate expression statements and after each statement an <code>OpPop</code> instruction should be emitted. That’s not what currently happens. Instead we tell our VM to fill up its stack by loading constants on to it:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb77-1"><a href="#cb77-1"></a>$ go test ./compiler</span>
<span id="cb77-2"><a href="#cb77-2"></a>--- FAIL: TestIntegerArithmetic (0.00s)</span>
<span id="cb77-3"><a href="#cb77-3"></a> compiler_test.go:37: testInstructions failed: wrong instructions length.</span>
<span id="cb77-4"><a href="#cb77-4"></a>  want=&quot;0000 OpConstant 0\n0003 OpConstant 1\n0006 OpAdd\n0007 OpPop\n&quot;</span>
<span id="cb77-5"><a href="#cb77-5"></a>  got =&quot;0000 OpConstant 0\n0003 OpConstant 1\n0006 OpAdd\n&quot;</span>
<span id="cb77-6"><a href="#cb77-6"></a>FAIL</span>
<span id="cb77-7"><a href="#cb77-7"></a>FAIL    monkey/compiler 0.007s</span></code></pre></div>
<p>But here comes the good part. In order to fix this and properly clean the stack, all we need to do is to add a single call to <code>c.emit</code> to our compiler:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb78-1"><a href="#cb78-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb78-2"><a href="#cb78-2"></a></span>
<span id="cb78-3"><a href="#cb78-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb78-4"><a href="#cb78-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb78-5"><a href="#cb78-5"></a>    <span class="co">// [...]</span></span>
<span id="cb78-6"><a href="#cb78-6"></a></span>
<span id="cb78-7"><a href="#cb78-7"></a>    <span class="kw">case</span> *ast.ExpressionStatement:</span>
<span id="cb78-8"><a href="#cb78-8"></a>        err := c.Compile(node.Expression)</span>
<span id="cb78-9"><a href="#cb78-9"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb78-10"><a href="#cb78-10"></a>            <span class="kw">return</span> err</span>
<span id="cb78-11"><a href="#cb78-11"></a>        }</span>
<span id="cb78-12"><a href="#cb78-12"></a>        c.emit(code.OpPop)</span>
<span id="cb78-13"><a href="#cb78-13"></a></span>
<span id="cb78-14"><a href="#cb78-14"></a>    <span class="co">// [...]</span></span>
<span id="cb78-15"><a href="#cb78-15"></a>    }</span>
<span id="cb78-16"><a href="#cb78-16"></a></span>
<span id="cb78-17"><a href="#cb78-17"></a>    <span class="co">// [...]</span></span>
<span id="cb78-18"><a href="#cb78-18"></a>}</span></code></pre></div>
<p>After compiling the <code>node.Expression</code> of an <code>*ast.ExpressionStatement</code> we emit an <code>OpPop</code>. That’s all it takes:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb79-1"><a href="#cb79-1"></a>$ go test ./compiler</span>
<span id="cb79-2"><a href="#cb79-2"></a>ok      monkey/compiler 0.006s</span></code></pre></div>
<p>Okay, that’s not <em>all</em> it takes. We still have some work left to do, because now we need to tell our VM how to handle this <code>OpPop</code> instruction, which would also be a tiny addition if it weren’t for our tests.</p>
<p>In our VM tests we used <code>vm.StackTop</code> to make sure that our VM put the correct things on to its stack, but with <code>OpPop</code> in play we can’t do that anymore. Now, what want to assert is that “this should have been on the stack, right before you popped it off, dear VM”. In order to do that, we add a test-only method to our VM and get rid of <code>StackTop</code>:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb80-1"><a href="#cb80-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb80-2"><a href="#cb80-2"></a></span>
<span id="cb80-3"><a href="#cb80-3"></a><span class="kw">func</span> (vm *VM) LastPoppedStackElem() object.Object {</span>
<span id="cb80-4"><a href="#cb80-4"></a>    <span class="kw">return</span> vm.stack[vm.sp]</span>
<span id="cb80-5"><a href="#cb80-5"></a>}</span></code></pre></div>
<p>As per our convention <code>vm.sp</code> always points to the <em>next free</em> slot in <code>vm.stack</code>. This is where a new element would be pushed. But since we only pop elements off the stack by decrementing <code>vm.sp</code> (without explicitly setting them to <code>nil</code>), this is also where we can find the elements that were previously on top of the stack. With <code>LastPoppedStackElem</code>, we can change our VM tests to make sure <code>OpPop</code> is actually handled correctly:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb81-1"><a href="#cb81-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb81-2"><a href="#cb81-2"></a></span>
<span id="cb81-3"><a href="#cb81-3"></a><span class="kw">func</span> runVmTests(t *testing.T, tests []vmTestCase) {</span>
<span id="cb81-4"><a href="#cb81-4"></a>    t.Helper()</span>
<span id="cb81-5"><a href="#cb81-5"></a></span>
<span id="cb81-6"><a href="#cb81-6"></a>    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</span>
<span id="cb81-7"><a href="#cb81-7"></a>        <span class="co">// [...]</span></span>
<span id="cb81-8"><a href="#cb81-8"></a></span>
<span id="cb81-9"><a href="#cb81-9"></a>        stackElem := vm.LastPoppedStackElem()</span>
<span id="cb81-10"><a href="#cb81-10"></a></span>
<span id="cb81-11"><a href="#cb81-11"></a>        testExpectedObject(t, tt.expected, stackElem)</span>
<span id="cb81-12"><a href="#cb81-12"></a>    }</span>
<span id="cb81-13"><a href="#cb81-13"></a>}</span></code></pre></div>
<p>We changed the call from <code>vm.StackTop</code> to <code>vm.LastPoppedStackElem</code>. It’s enough to break our tests:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb82-1"><a href="#cb82-1"></a>$ go test ./vm</span>
<span id="cb82-2"><a href="#cb82-2"></a>--- FAIL: TestIntegerArithmetic (0.00s)</span>
<span id="cb82-3"><a href="#cb82-3"></a> vm_test.go:20: testIntegerObject failed:\</span>
<span id="cb82-4"><a href="#cb82-4"></a>   object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</span>
<span id="cb82-5"><a href="#cb82-5"></a> vm_test.go:20: testIntegerObject failed:\</span>
<span id="cb82-6"><a href="#cb82-6"></a>   object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</span>
<span id="cb82-7"><a href="#cb82-7"></a> vm_test.go:20: testIntegerObject failed:\</span>
<span id="cb82-8"><a href="#cb82-8"></a>   object has wrong value. got=2, want=3</span>
<span id="cb82-9"><a href="#cb82-9"></a>FAIL</span>
<span id="cb82-10"><a href="#cb82-10"></a>FAIL    monkey/vm   0.007s</span></code></pre></div>
<p>In order to get them to pass again, we need to tell our VM to keep its stack clean and tidy:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb83-1"><a href="#cb83-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb83-2"><a href="#cb83-2"></a></span>
<span id="cb83-3"><a href="#cb83-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb83-4"><a href="#cb83-4"></a>    <span class="co">// [...]</span></span>
<span id="cb83-5"><a href="#cb83-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb83-6"><a href="#cb83-6"></a>        <span class="co">// [...]</span></span>
<span id="cb83-7"><a href="#cb83-7"></a></span>
<span id="cb83-8"><a href="#cb83-8"></a>        <span class="kw">case</span> code.OpPop:</span>
<span id="cb83-9"><a href="#cb83-9"></a>            vm.pop()</span>
<span id="cb83-10"><a href="#cb83-10"></a></span>
<span id="cb83-11"><a href="#cb83-11"></a>        }</span>
<span id="cb83-12"><a href="#cb83-12"></a>    <span class="co">// [...]</span></span>
<span id="cb83-13"><a href="#cb83-13"></a>}</span></code></pre></div>
<p>With that, stack hygiene is restored:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb84-1"><a href="#cb84-1"></a>$ go test ./vm</span>
<span id="cb84-2"><a href="#cb84-2"></a>ok      monkey/vm   0.006s</span></code></pre></div>
<p>But we also need to fix our REPL, where we still use <code>StackTop</code>, by replacing it with <code>LastPoppedStackElem</code>:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb85-1"><a href="#cb85-1"></a><span class="co">// repl/repl.go</span></span>
<span id="cb85-2"><a href="#cb85-2"></a></span>
<span id="cb85-3"><a href="#cb85-3"></a><span class="kw">func</span> Start(in io.Reader, out io.Writer) {</span>
<span id="cb85-4"><a href="#cb85-4"></a>    <span class="co">// [...]</span></span>
<span id="cb85-5"><a href="#cb85-5"></a></span>
<span id="cb85-6"><a href="#cb85-6"></a>    <span class="kw">for</span> {</span>
<span id="cb85-7"><a href="#cb85-7"></a>        <span class="co">// [...]</span></span>
<span id="cb85-8"><a href="#cb85-8"></a></span>
<span id="cb85-9"><a href="#cb85-9"></a>        lastPopped := machine.LastPoppedStackElem()</span>
<span id="cb85-10"><a href="#cb85-10"></a>        io.WriteString(out, lastPopped.Inspect())</span>
<span id="cb85-11"><a href="#cb85-11"></a>        io.WriteString(out, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb85-12"><a href="#cb85-12"></a>    }</span>
<span id="cb85-13"><a href="#cb85-13"></a>}</span></code></pre></div>
<p>Perfect! That means we can move on and safely do more arithmetic on the stack without the stack slowly blowing up in our face.</p>
<h2 id="infix-expressions">Infix Expressions</h2>
<p>Monkey supports eight infix operators and four of them are being used for arithmetic: <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code>. We’ve already added support for <code>+</code> with the <code>OpAdd</code> opcode. Now we need to add three more. And since all three of them work the same way in regards to their use of operands and the stack, we’ll add them together.</p>
<p>The first step is to add the <code>Opcode</code> definitions to the <code>code</code> package:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb86-1"><a href="#cb86-1"></a><span class="co">// code/code.go</span></span>
<span id="cb86-2"><a href="#cb86-2"></a></span>
<span id="cb86-3"><a href="#cb86-3"></a><span class="kw">const</span> (</span>
<span id="cb86-4"><a href="#cb86-4"></a>    <span class="co">// [...]</span></span>
<span id="cb86-5"><a href="#cb86-5"></a></span>
<span id="cb86-6"><a href="#cb86-6"></a>    OpSub</span>
<span id="cb86-7"><a href="#cb86-7"></a>    OpMul</span>
<span id="cb86-8"><a href="#cb86-8"></a>    OpDiv</span>
<span id="cb86-9"><a href="#cb86-9"></a>)</span>
<span id="cb86-10"><a href="#cb86-10"></a></span>
<span id="cb86-11"><a href="#cb86-11"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb86-12"><a href="#cb86-12"></a>    <span class="co">// [...]</span></span>
<span id="cb86-13"><a href="#cb86-13"></a></span>
<span id="cb86-14"><a href="#cb86-14"></a>    OpSub: {<span class="st">&quot;OpSub&quot;</span>, []<span class="dt">int</span>{}},</span>
<span id="cb86-15"><a href="#cb86-15"></a>    OpMul: {<span class="st">&quot;OpMul&quot;</span>, []<span class="dt">int</span>{}},</span>
<span id="cb86-16"><a href="#cb86-16"></a>    OpDiv: {<span class="st">&quot;OpDiv&quot;</span>, []<span class="dt">int</span>{}},</span>
<span id="cb86-17"><a href="#cb86-17"></a>}</span></code></pre></div>
<p><code>OpSub</code> stands for the <code>-</code>, <code>OpMul</code> for the <code>*</code> and <code>OpDiv</code> for the <code>/</code> infix operator. With these opcodes defined, we can use them in our compiler tests to make sure the compiler knows how to output them:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb87-1"><a href="#cb87-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb87-2"><a href="#cb87-2"></a></span>
<span id="cb87-3"><a href="#cb87-3"></a><span class="kw">func</span> TestIntegerArithmetic(t *testing.T) {</span>
<span id="cb87-4"><a href="#cb87-4"></a>    tests := []compilerTestCase{</span>
<span id="cb87-5"><a href="#cb87-5"></a>        <span class="co">// [...]</span></span>
<span id="cb87-6"><a href="#cb87-6"></a>        {</span>
<span id="cb87-7"><a href="#cb87-7"></a>            input:             <span class="st">&quot;1 - 2&quot;</span>,</span>
<span id="cb87-8"><a href="#cb87-8"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">1</span>, <span class="dv">2</span>},</span>
<span id="cb87-9"><a href="#cb87-9"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb87-10"><a href="#cb87-10"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb87-11"><a href="#cb87-11"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb87-12"><a href="#cb87-12"></a>                code.Make(code.OpSub),</span>
<span id="cb87-13"><a href="#cb87-13"></a>                code.Make(code.OpPop),</span>
<span id="cb87-14"><a href="#cb87-14"></a>            },</span>
<span id="cb87-15"><a href="#cb87-15"></a>        },</span>
<span id="cb87-16"><a href="#cb87-16"></a>        {</span>
<span id="cb87-17"><a href="#cb87-17"></a>            input:             <span class="st">&quot;1 * 2&quot;</span>,</span>
<span id="cb87-18"><a href="#cb87-18"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">1</span>, <span class="dv">2</span>},</span>
<span id="cb87-19"><a href="#cb87-19"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb87-20"><a href="#cb87-20"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb87-21"><a href="#cb87-21"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb87-22"><a href="#cb87-22"></a>                code.Make(code.OpMul),</span>
<span id="cb87-23"><a href="#cb87-23"></a>                code.Make(code.OpPop),</span>
<span id="cb87-24"><a href="#cb87-24"></a>            },</span>
<span id="cb87-25"><a href="#cb87-25"></a>        },</span>
<span id="cb87-26"><a href="#cb87-26"></a>        {</span>
<span id="cb87-27"><a href="#cb87-27"></a>            input:             <span class="st">&quot;2 / 1&quot;</span>,</span>
<span id="cb87-28"><a href="#cb87-28"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">2</span>, <span class="dv">1</span>},</span>
<span id="cb87-29"><a href="#cb87-29"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb87-30"><a href="#cb87-30"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb87-31"><a href="#cb87-31"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb87-32"><a href="#cb87-32"></a>                code.Make(code.OpDiv),</span>
<span id="cb87-33"><a href="#cb87-33"></a>                code.Make(code.OpPop),</span>
<span id="cb87-34"><a href="#cb87-34"></a>            },</span>
<span id="cb87-35"><a href="#cb87-35"></a>        },</span>
<span id="cb87-36"><a href="#cb87-36"></a>    }</span>
<span id="cb87-37"><a href="#cb87-37"></a></span>
<span id="cb87-38"><a href="#cb87-38"></a>    runCompilerTests(t, tests)</span>
<span id="cb87-39"><a href="#cb87-39"></a>}</span></code></pre></div>
<p>Hopefully the only thing that gives you pause here is the last test case, where I changed the order of the operands. Other than that, these are boringly similar to our previous test case for <code>1 + 2</code>, except for the operator itself and the expected opcode. But, alas, similarity is not something a compiler understands natively:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb88-1"><a href="#cb88-1"></a>$ go test ./compiler</span>
<span id="cb88-2"><a href="#cb88-2"></a>--- FAIL: TestIntegerArithmetic (0.00s)</span>
<span id="cb88-3"><a href="#cb88-3"></a> compiler_test.go:67: compiler error: unknown operator -</span>
<span id="cb88-4"><a href="#cb88-4"></a>FAIL</span>
<span id="cb88-5"><a href="#cb88-5"></a>FAIL    monkey/compiler 0.006s</span></code></pre></div>
<p>What we need to change is the <code>switch</code> statement in our compiler’s <code>Compile</code> method that checks <code>node.Operator</code>:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb89-1"><a href="#cb89-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb89-2"><a href="#cb89-2"></a></span>
<span id="cb89-3"><a href="#cb89-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb89-4"><a href="#cb89-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb89-5"><a href="#cb89-5"></a>    <span class="co">// [...]</span></span>
<span id="cb89-6"><a href="#cb89-6"></a></span>
<span id="cb89-7"><a href="#cb89-7"></a>    <span class="kw">case</span> *ast.InfixExpression:</span>
<span id="cb89-8"><a href="#cb89-8"></a>        <span class="co">// [...]</span></span>
<span id="cb89-9"><a href="#cb89-9"></a></span>
<span id="cb89-10"><a href="#cb89-10"></a>        <span class="kw">switch</span> node.Operator {</span>
<span id="cb89-11"><a href="#cb89-11"></a>        <span class="kw">case</span> <span class="st">&quot;+&quot;</span>:</span>
<span id="cb89-12"><a href="#cb89-12"></a>            c.emit(code.OpAdd)</span>
<span id="cb89-13"><a href="#cb89-13"></a>        <span class="kw">case</span> <span class="st">&quot;-&quot;</span>:</span>
<span id="cb89-14"><a href="#cb89-14"></a>            c.emit(code.OpSub)</span>
<span id="cb89-15"><a href="#cb89-15"></a>        <span class="kw">case</span> <span class="st">&quot;*&quot;</span>:</span>
<span id="cb89-16"><a href="#cb89-16"></a>            c.emit(code.OpMul)</span>
<span id="cb89-17"><a href="#cb89-17"></a>        <span class="kw">case</span> <span class="st">&quot;/&quot;</span>:</span>
<span id="cb89-18"><a href="#cb89-18"></a>            c.emit(code.OpDiv)</span>
<span id="cb89-19"><a href="#cb89-19"></a>        <span class="kw">default</span>:</span>
<span id="cb89-20"><a href="#cb89-20"></a>            <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;unknown operator %s&quot;</span>, node.Operator)</span>
<span id="cb89-21"><a href="#cb89-21"></a>        }</span>
<span id="cb89-22"><a href="#cb89-22"></a></span>
<span id="cb89-23"><a href="#cb89-23"></a>    <span class="co">// [...]</span></span>
<span id="cb89-24"><a href="#cb89-24"></a>    }</span>
<span id="cb89-25"><a href="#cb89-25"></a></span>
<span id="cb89-26"><a href="#cb89-26"></a>    <span class="co">// [...]</span></span>
<span id="cb89-27"><a href="#cb89-27"></a>}</span></code></pre></div>
<p>Only six lines in this snippet are new: the <code>case</code> branches for <code>"-"</code>, <code>"*"</code> and <code>"/"</code>. And they make the tests pass:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb90-1"><a href="#cb90-1"></a>$ go test ./compiler</span>
<span id="cb90-2"><a href="#cb90-2"></a>ok      monkey/compiler 0.006s</span></code></pre></div>
<p>Alright, the compiler now outputs three more opcodes. Our VM must now step up to this challenge. And here too, the first thing to do is add test cases:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb91-1"><a href="#cb91-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb91-2"><a href="#cb91-2"></a></span>
<span id="cb91-3"><a href="#cb91-3"></a><span class="kw">func</span> TestIntegerArithmetic(t *testing.T) {</span>
<span id="cb91-4"><a href="#cb91-4"></a>    tests := []vmTestCase{</span>
<span id="cb91-5"><a href="#cb91-5"></a>        <span class="co">// [...]</span></span>
<span id="cb91-6"><a href="#cb91-6"></a>        {<span class="st">&quot;1 - 2&quot;</span>, <span class="dv">-1</span>},</span>
<span id="cb91-7"><a href="#cb91-7"></a>        {<span class="st">&quot;1 * 2&quot;</span>, <span class="dv">2</span>},</span>
<span id="cb91-8"><a href="#cb91-8"></a>        {<span class="st">&quot;4 / 2&quot;</span>, <span class="dv">2</span>},</span>
<span id="cb91-9"><a href="#cb91-9"></a>        {<span class="st">&quot;50 / 2 * 2 + 10 - 5&quot;</span>, <span class="dv">55</span>},</span>
<span id="cb91-10"><a href="#cb91-10"></a>        {<span class="st">&quot;5 + 5 + 5 + 5 - 10&quot;</span>, <span class="dv">10</span>},</span>
<span id="cb91-11"><a href="#cb91-11"></a>        {<span class="st">&quot;2 * 2 * 2 * 2 * 2&quot;</span>, <span class="dv">32</span>},</span>
<span id="cb91-12"><a href="#cb91-12"></a>        {<span class="st">&quot;5 * 2 + 10&quot;</span>, <span class="dv">20</span>},</span>
<span id="cb91-13"><a href="#cb91-13"></a>        {<span class="st">&quot;5 + 2 * 10&quot;</span>, <span class="dv">25</span>},</span>
<span id="cb91-14"><a href="#cb91-14"></a>        {<span class="st">&quot;5 * (2 + 10)&quot;</span>, <span class="dv">60</span>},</span>
<span id="cb91-15"><a href="#cb91-15"></a>    }</span>
<span id="cb91-16"><a href="#cb91-16"></a></span>
<span id="cb91-17"><a href="#cb91-17"></a>    runVmTests(t, tests)</span>
<span id="cb91-18"><a href="#cb91-18"></a>}</span></code></pre></div>
<p>Some might say that this is excessive, going overboard. But what I want to show you here is the power of stack arithmetic. We not only have the three test cases necessary to make sure the <code>OpSub</code>, <code>OpMul</code> and <code>OpDiv</code> opcodes are recognized by the VM, but there’s also a series of test cases that mix the infix operators, playing with their varying levels of precedence and manipulating them by hand with added parentheses. For now, they all fail, which is not the point I wanted to make:</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb92-1"><a href="#cb92-1"></a>$ go test ./vm</span>
<span id="cb92-2"><a href="#cb92-2"></a>--- FAIL: TestIntegerArithmetic (0.00s)</span>
<span id="cb92-3"><a href="#cb92-3"></a> vm_test.go:30: testIntegerObject failed: object has wrong value.\</span>
<span id="cb92-4"><a href="#cb92-4"></a>   got=2, want=-1</span>
<span id="cb92-5"><a href="#cb92-5"></a> vm_test.go:30: testIntegerObject failed: object has wrong value.\</span>
<span id="cb92-6"><a href="#cb92-6"></a>   got=5, want=55</span>
<span id="cb92-7"><a href="#cb92-7"></a> vm_test.go:30: testIntegerObject failed: object has wrong value.\</span>
<span id="cb92-8"><a href="#cb92-8"></a>   got=2, want=32</span>
<span id="cb92-9"><a href="#cb92-9"></a> vm_test.go:30: testIntegerObject failed: object has wrong value.\</span>
<span id="cb92-10"><a href="#cb92-10"></a>   got=12, want=20</span>
<span id="cb92-11"><a href="#cb92-11"></a> vm_test.go:30: testIntegerObject failed: object has wrong value.\</span>
<span id="cb92-12"><a href="#cb92-12"></a>   got=12, want=25</span>
<span id="cb92-13"><a href="#cb92-13"></a> vm_test.go:30: testIntegerObject failed: object has wrong value.\</span>
<span id="cb92-14"><a href="#cb92-14"></a>   got=12, want=60</span>
<span id="cb92-15"><a href="#cb92-15"></a>FAIL</span>
<span id="cb92-16"><a href="#cb92-16"></a>FAIL    monkey/vm   0.007s</span></code></pre></div>
<p>My point is how minimal the required changes are to make all of them pass. First, we replace the existing <code>case code.OpAdd</code> in our <code>VM</code> with this:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb93-1"><a href="#cb93-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb93-2"><a href="#cb93-2"></a></span>
<span id="cb93-3"><a href="#cb93-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb93-4"><a href="#cb93-4"></a>    <span class="co">// [...]</span></span>
<span id="cb93-5"><a href="#cb93-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb93-6"><a href="#cb93-6"></a>        <span class="co">// [...]</span></span>
<span id="cb93-7"><a href="#cb93-7"></a></span>
<span id="cb93-8"><a href="#cb93-8"></a>        <span class="kw">case</span> code.OpAdd, code.OpSub, code.OpMul, code.OpDiv:</span>
<span id="cb93-9"><a href="#cb93-9"></a>            err := vm.executeBinaryOperation(op)</span>
<span id="cb93-10"><a href="#cb93-10"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb93-11"><a href="#cb93-11"></a>                <span class="kw">return</span> err</span>
<span id="cb93-12"><a href="#cb93-12"></a>            }</span>
<span id="cb93-13"><a href="#cb93-13"></a></span>
<span id="cb93-14"><a href="#cb93-14"></a>        }</span>
<span id="cb93-15"><a href="#cb93-15"></a>    <span class="co">// [...]</span></span>
<span id="cb93-16"><a href="#cb93-16"></a>}</span></code></pre></div>
<p>Everything that has to with binary operations is now neatly tucked away behind the <code>executeBinaryOperation</code> method:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb94-1"><a href="#cb94-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb94-2"><a href="#cb94-2"></a></span>
<span id="cb94-3"><a href="#cb94-3"></a><span class="kw">func</span> (vm *VM) executeBinaryOperation(op code.Opcode) <span class="dt">error</span> {</span>
<span id="cb94-4"><a href="#cb94-4"></a>    right := vm.pop()</span>
<span id="cb94-5"><a href="#cb94-5"></a>    left := vm.pop()</span>
<span id="cb94-6"><a href="#cb94-6"></a></span>
<span id="cb94-7"><a href="#cb94-7"></a>    leftType := left.Type()</span>
<span id="cb94-8"><a href="#cb94-8"></a>    rightType := right.Type()</span>
<span id="cb94-9"><a href="#cb94-9"></a></span>
<span id="cb94-10"><a href="#cb94-10"></a>    <span class="kw">if</span> leftType == object.INTEGER_OBJ &amp;&amp; rightType == object.INTEGER_OBJ {</span>
<span id="cb94-11"><a href="#cb94-11"></a>        <span class="kw">return</span> vm.executeBinaryIntegerOperation(op, left, right)</span>
<span id="cb94-12"><a href="#cb94-12"></a>    }</span>
<span id="cb94-13"><a href="#cb94-13"></a></span>
<span id="cb94-14"><a href="#cb94-14"></a>    <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;unsupported types for binary operation: %s %s&quot;</span>,</span>
<span id="cb94-15"><a href="#cb94-15"></a>        leftType, rightType)</span>
<span id="cb94-16"><a href="#cb94-16"></a>}</span></code></pre></div>
<p>It doesn’t do much more than type assertions and possibly producing an error and delegates most of the work to <code>executeBinaryIntegerOperation</code>:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb95-1"><a href="#cb95-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb95-2"><a href="#cb95-2"></a></span>
<span id="cb95-3"><a href="#cb95-3"></a><span class="kw">func</span> (vm *VM) executeBinaryIntegerOperation(</span>
<span id="cb95-4"><a href="#cb95-4"></a>    op code.Opcode,</span>
<span id="cb95-5"><a href="#cb95-5"></a>    left, right object.Object,</span>
<span id="cb95-6"><a href="#cb95-6"></a>) <span class="dt">error</span> {</span>
<span id="cb95-7"><a href="#cb95-7"></a>    leftValue := left.(*object.Integer).Value</span>
<span id="cb95-8"><a href="#cb95-8"></a>    rightValue := right.(*object.Integer).Value</span>
<span id="cb95-9"><a href="#cb95-9"></a></span>
<span id="cb95-10"><a href="#cb95-10"></a>    <span class="kw">var</span> result <span class="dt">int64</span></span>
<span id="cb95-11"><a href="#cb95-11"></a></span>
<span id="cb95-12"><a href="#cb95-12"></a>    <span class="kw">switch</span> op {</span>
<span id="cb95-13"><a href="#cb95-13"></a>    <span class="kw">case</span> code.OpAdd:</span>
<span id="cb95-14"><a href="#cb95-14"></a>        result = leftValue + rightValue</span>
<span id="cb95-15"><a href="#cb95-15"></a>    <span class="kw">case</span> code.OpSub:</span>
<span id="cb95-16"><a href="#cb95-16"></a>        result = leftValue - rightValue</span>
<span id="cb95-17"><a href="#cb95-17"></a>    <span class="kw">case</span> code.OpMul:</span>
<span id="cb95-18"><a href="#cb95-18"></a>        result = leftValue * rightValue</span>
<span id="cb95-19"><a href="#cb95-19"></a>    <span class="kw">case</span> code.OpDiv:</span>
<span id="cb95-20"><a href="#cb95-20"></a>        result = leftValue / rightValue</span>
<span id="cb95-21"><a href="#cb95-21"></a>    <span class="kw">default</span>:</span>
<span id="cb95-22"><a href="#cb95-22"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;unknown integer operator: %d&quot;</span>, op)</span>
<span id="cb95-23"><a href="#cb95-23"></a>    }</span>
<span id="cb95-24"><a href="#cb95-24"></a></span>
<span id="cb95-25"><a href="#cb95-25"></a>    <span class="kw">return</span> vm.push(&amp;object.Integer{Value: result})</span>
<span id="cb95-26"><a href="#cb95-26"></a>}</span></code></pre></div>
<p>Here is where we finally unwrap the integers contained in the <code>left</code> and <code>right</code> operands and produce a result according to the <code>op</code>. There shouldn’t be any surprises here, because this method has a really similar counterpart in the <code>evaluator</code> package we built in the first book.</p>
<p>Here’s the result of adding these two methods:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb96-1"><a href="#cb96-1"></a>$ go test ./vm</span>
<span id="cb96-2"><a href="#cb96-2"></a>ok      monkey/vm   0.010s</span></code></pre></div>
<p>Addition, subtraction, multiplication, division – they all work. As a single operations, combined, grouped by parentheses; all we do is pop operands off the stack and push the result back. Stack arithmetic – pretty neat.</p>
<h2 id="booleans">Booleans</h2>
<p>These four operators we added comprise only a subset of the operators available in Monkey. There are also the comparison operators <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code> and the two prefix operators <code>!</code> and <code>-</code>. Our next goal is to implement all of them and that includes teaching our Monkey VM about another Monkey data type: booleans. Without booleans we couldn’t represent the results of these operators (well, except for the <code>-</code> prefix), but booleans also exist as literal expressions in Monkey:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb97-1"><a href="#cb97-1"></a><span class="kw">true</span><span class="op">;</span></span>
<span id="cb97-2"><a href="#cb97-2"></a><span class="kw">false</span><span class="op">;</span></span></code></pre></div>
<p>We’re going to start by adding support for these two literals. That way we already have our boolean data type in place when we add the operators.</p>
<p>So what does a boolean literal do? Well, in our <code>evaluator</code> a boolean literal evaluates to the boolean value it designates: true or false. Now we’re working with a compiler and a VM, so we have to adjust our expectations a little bit. Instead of boolean literals <em>evaluating</em> to boolean values, we now want them to cause the VM to load the boolean values on to the stack.</p>
<p>That’s pretty close to what integer literals do and those are compiled to <code>OpConstant</code> instructions. We <em>could</em> treat <code>true</code> and <code>false</code> as constants too, but that would be a waste, not only of bytecode but also of compiler and VM resources. Instead, we’ll now define two new opcodes that directly tell the VM to push an <code>*object.Boolean</code> on to the stack:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb98-1"><a href="#cb98-1"></a><span class="co">// code/code.go</span></span>
<span id="cb98-2"><a href="#cb98-2"></a></span>
<span id="cb98-3"><a href="#cb98-3"></a><span class="kw">const</span> (</span>
<span id="cb98-4"><a href="#cb98-4"></a>    <span class="co">// [...]</span></span>
<span id="cb98-5"><a href="#cb98-5"></a></span>
<span id="cb98-6"><a href="#cb98-6"></a>    OpTrue</span>
<span id="cb98-7"><a href="#cb98-7"></a>    OpFalse</span>
<span id="cb98-8"><a href="#cb98-8"></a>)</span>
<span id="cb98-9"><a href="#cb98-9"></a></span>
<span id="cb98-10"><a href="#cb98-10"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb98-11"><a href="#cb98-11"></a>    <span class="co">// [...]</span></span>
<span id="cb98-12"><a href="#cb98-12"></a></span>
<span id="cb98-13"><a href="#cb98-13"></a>    OpTrue:  {<span class="st">&quot;OpTrue&quot;</span>, []<span class="dt">int</span>{}},</span>
<span id="cb98-14"><a href="#cb98-14"></a>    OpFalse: {<span class="st">&quot;OpFalse&quot;</span>, []<span class="dt">int</span>{}},</span>
<span id="cb98-15"><a href="#cb98-15"></a>}</span></code></pre></div>
<p>Granted, I didn’t waste a lot of creativity on the naming of these two. But what they do should be clear nonetheless. Both opcodes have no operands and simply tell the VM “push true or false on to the stack”.</p>
<p>We can now use that to create a compiler test in which we make sure that the boolean literals <code>true</code> and <code>false</code> are translated to <code>OpTrue</code> and <code>OpFalse</code> instructions:</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb99-1"><a href="#cb99-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb99-2"><a href="#cb99-2"></a></span>
<span id="cb99-3"><a href="#cb99-3"></a><span class="kw">func</span> TestBooleanExpressions(t *testing.T) {</span>
<span id="cb99-4"><a href="#cb99-4"></a>    tests := []compilerTestCase{</span>
<span id="cb99-5"><a href="#cb99-5"></a>        {</span>
<span id="cb99-6"><a href="#cb99-6"></a>            input:             <span class="st">&quot;true&quot;</span>,</span>
<span id="cb99-7"><a href="#cb99-7"></a>            expectedConstants: []<span class="kw">interface</span>{}{},</span>
<span id="cb99-8"><a href="#cb99-8"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb99-9"><a href="#cb99-9"></a>                code.Make(code.OpTrue),</span>
<span id="cb99-10"><a href="#cb99-10"></a>                code.Make(code.OpPop),</span>
<span id="cb99-11"><a href="#cb99-11"></a>            },</span>
<span id="cb99-12"><a href="#cb99-12"></a>        },</span>
<span id="cb99-13"><a href="#cb99-13"></a>        {</span>
<span id="cb99-14"><a href="#cb99-14"></a>            input:             <span class="st">&quot;false&quot;</span>,</span>
<span id="cb99-15"><a href="#cb99-15"></a>            expectedConstants: []<span class="kw">interface</span>{}{},</span>
<span id="cb99-16"><a href="#cb99-16"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb99-17"><a href="#cb99-17"></a>                code.Make(code.OpFalse),</span>
<span id="cb99-18"><a href="#cb99-18"></a>                code.Make(code.OpPop),</span>
<span id="cb99-19"><a href="#cb99-19"></a>            },</span>
<span id="cb99-20"><a href="#cb99-20"></a>        },</span>
<span id="cb99-21"><a href="#cb99-21"></a>    }</span>
<span id="cb99-22"><a href="#cb99-22"></a></span>
<span id="cb99-23"><a href="#cb99-23"></a>    runCompilerTests(t, tests)</span>
<span id="cb99-24"><a href="#cb99-24"></a>}</span></code></pre></div>
<p>This is our second compiler test and has the same structure as the first one. The <code>tests</code> slice will be extended once we implement the comparison operators.</p>
<p>Both test cases fail, because the compiler only knows that it should emit an <code>OpPop</code> after expression statements:</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb100-1"><a href="#cb100-1"></a>$ go test ./compiler</span>
<span id="cb100-2"><a href="#cb100-2"></a>--- FAIL: TestBooleanExpressions (0.00s)</span>
<span id="cb100-3"><a href="#cb100-3"></a> compiler_test.go:90: testInstructions failed: wrong instructions length.</span>
<span id="cb100-4"><a href="#cb100-4"></a>  want=&quot;0000 OpTrue\n0001 OpPop\n&quot;</span>
<span id="cb100-5"><a href="#cb100-5"></a>  got =&quot;0000 OpPop\n&quot;</span>
<span id="cb100-6"><a href="#cb100-6"></a>FAIL</span>
<span id="cb100-7"><a href="#cb100-7"></a>FAIL    monkey/compiler 0.009s</span></code></pre></div>
<p>In order to emit <code>OpTrue</code> or <code>OpFalse</code> instructions we need to add a new <code>case</code> branch for <code>*ast.Boolean</code> to the compiler’s <code>Compile</code> method:</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb101-1"><a href="#cb101-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb101-2"><a href="#cb101-2"></a></span>
<span id="cb101-3"><a href="#cb101-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb101-4"><a href="#cb101-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb101-5"><a href="#cb101-5"></a>    <span class="co">// [...]</span></span>
<span id="cb101-6"><a href="#cb101-6"></a></span>
<span id="cb101-7"><a href="#cb101-7"></a>    <span class="kw">case</span> *ast.Boolean:</span>
<span id="cb101-8"><a href="#cb101-8"></a>        <span class="kw">if</span> node.Value {</span>
<span id="cb101-9"><a href="#cb101-9"></a>            c.emit(code.OpTrue)</span>
<span id="cb101-10"><a href="#cb101-10"></a>        } <span class="kw">else</span> {</span>
<span id="cb101-11"><a href="#cb101-11"></a>            c.emit(code.OpFalse)</span>
<span id="cb101-12"><a href="#cb101-12"></a>        }</span>
<span id="cb101-13"><a href="#cb101-13"></a></span>
<span id="cb101-14"><a href="#cb101-14"></a>    <span class="co">// [...]</span></span>
<span id="cb101-15"><a href="#cb101-15"></a>    }</span>
<span id="cb101-16"><a href="#cb101-16"></a></span>
<span id="cb101-17"><a href="#cb101-17"></a>    <span class="co">// [...]</span></span>
<span id="cb101-18"><a href="#cb101-18"></a>}</span></code></pre></div>
<p>Yep, that did it, alright:</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb102-1"><a href="#cb102-1"></a>$ go test ./compiler</span>
<span id="cb102-2"><a href="#cb102-2"></a>ok      monkey/compiler 0.008s</span></code></pre></div>
<p>The next step is to tell the VM about <code>true</code> and <code>false</code>. And just like in the <code>compiler</code> package we now create a second test function:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb103-1"><a href="#cb103-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb103-2"><a href="#cb103-2"></a></span>
<span id="cb103-3"><a href="#cb103-3"></a><span class="kw">func</span> TestBooleanExpressions(t *testing.T) {</span>
<span id="cb103-4"><a href="#cb103-4"></a>    tests := []vmTestCase{</span>
<span id="cb103-5"><a href="#cb103-5"></a>        {<span class="st">&quot;true&quot;</span>, <span class="ot">true</span>},</span>
<span id="cb103-6"><a href="#cb103-6"></a>        {<span class="st">&quot;false&quot;</span>, <span class="ot">false</span>},</span>
<span id="cb103-7"><a href="#cb103-7"></a>    }</span>
<span id="cb103-8"><a href="#cb103-8"></a></span>
<span id="cb103-9"><a href="#cb103-9"></a>    runVmTests(t, tests)</span>
<span id="cb103-10"><a href="#cb103-10"></a>}</span></code></pre></div>
<p>This test function is very similar to the first one, <code>TestIntegerArithmetic</code>. But since we now have a <code>bool</code> as our expectation here, we need to update the <code>testExpectedObject</code> function used by <code>runVmTests</code> and provide it with a new helper function called <code>testBooleanObject</code>:</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb104-1"><a href="#cb104-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb104-2"><a href="#cb104-2"></a></span>
<span id="cb104-3"><a href="#cb104-3"></a><span class="kw">func</span> testExpectedObject(</span>
<span id="cb104-4"><a href="#cb104-4"></a>    t *testing.T,</span>
<span id="cb104-5"><a href="#cb104-5"></a>    expected <span class="kw">interface</span>{},</span>
<span id="cb104-6"><a href="#cb104-6"></a>    actual object.Object,</span>
<span id="cb104-7"><a href="#cb104-7"></a>) {</span>
<span id="cb104-8"><a href="#cb104-8"></a>    t.Helper()</span>
<span id="cb104-9"><a href="#cb104-9"></a></span>
<span id="cb104-10"><a href="#cb104-10"></a>    <span class="kw">switch</span> expected := expected.(<span class="kw">type</span>) {</span>
<span id="cb104-11"><a href="#cb104-11"></a>    <span class="co">// [...]</span></span>
<span id="cb104-12"><a href="#cb104-12"></a></span>
<span id="cb104-13"><a href="#cb104-13"></a>    <span class="kw">case</span> <span class="dt">bool</span>:</span>
<span id="cb104-14"><a href="#cb104-14"></a>        err := testBooleanObject(<span class="dt">bool</span>(expected), actual)</span>
<span id="cb104-15"><a href="#cb104-15"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb104-16"><a href="#cb104-16"></a>            t.Errorf(<span class="st">&quot;testBooleanObject failed: %s&quot;</span>, err)</span>
<span id="cb104-17"><a href="#cb104-17"></a>        }</span>
<span id="cb104-18"><a href="#cb104-18"></a>    }</span>
<span id="cb104-19"><a href="#cb104-19"></a>}</span>
<span id="cb104-20"><a href="#cb104-20"></a></span>
<span id="cb104-21"><a href="#cb104-21"></a><span class="kw">func</span> testBooleanObject(expected <span class="dt">bool</span>, actual object.Object) <span class="dt">error</span> {</span>
<span id="cb104-22"><a href="#cb104-22"></a>    result, ok := actual.(*object.Boolean)</span>
<span id="cb104-23"><a href="#cb104-23"></a>    <span class="kw">if</span> !ok {</span>
<span id="cb104-24"><a href="#cb104-24"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;object is not Boolean. got=%T (%+v)&quot;</span>,</span>
<span id="cb104-25"><a href="#cb104-25"></a>            actual, actual)</span>
<span id="cb104-26"><a href="#cb104-26"></a>    }</span>
<span id="cb104-27"><a href="#cb104-27"></a></span>
<span id="cb104-28"><a href="#cb104-28"></a>    <span class="kw">if</span> result.Value != expected {</span>
<span id="cb104-29"><a href="#cb104-29"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;object has wrong value. got=%t, want=%t&quot;</span>,</span>
<span id="cb104-30"><a href="#cb104-30"></a>            result.Value, expected)</span>
<span id="cb104-31"><a href="#cb104-31"></a>    }</span>
<span id="cb104-32"><a href="#cb104-32"></a></span>
<span id="cb104-33"><a href="#cb104-33"></a>    <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb104-34"><a href="#cb104-34"></a>}</span></code></pre></div>
<p><code>testBooleanObject</code> is <code>testIntegerObject</code>’s counterpart and not the most fascinating of functions, but we’ll get a lot of use out of it, that’s for sure. What <em>is</em> noteworthy is that our VM tests now blow up:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb105-1"><a href="#cb105-1"></a>$ go test ./vm</span>
<span id="cb105-2"><a href="#cb105-2"></a>--- FAIL: TestBooleanExpressions (0.00s)</span>
<span id="cb105-3"><a href="#cb105-3"></a>panic: runtime error: index out of range [recovered]</span>
<span id="cb105-4"><a href="#cb105-4"></a> panic: runtime error: index out of range</span>
<span id="cb105-5"><a href="#cb105-5"></a></span>
<span id="cb105-6"><a href="#cb105-6"></a>goroutine 19 [running]:</span>
<span id="cb105-7"><a href="#cb105-7"></a>testing.tRunner.func1(0xc4200ba1e0)</span>
<span id="cb105-8"><a href="#cb105-8"></a> /usr/local/go/src/testing/testing.go:742 +0x29d</span>
<span id="cb105-9"><a href="#cb105-9"></a>panic(0x1116f20, 0x11eefc0)</span>
<span id="cb105-10"><a href="#cb105-10"></a> /usr/local/go/src/runtime/panic.go:502 +0x229</span>
<span id="cb105-11"><a href="#cb105-11"></a>monkey/vm.(*VM).pop(...)</span>
<span id="cb105-12"><a href="#cb105-12"></a> /Users/mrnugget/code/02/src/monkey/vm/vm.go:74</span>
<span id="cb105-13"><a href="#cb105-13"></a>monkey/vm.(*VM).Run(0xc420050ed8, 0x800, 0x800)</span>
<span id="cb105-14"><a href="#cb105-14"></a> /Users/mrnugget/code/02/src/monkey/vm/vm.go:49 +0x16f</span>
<span id="cb105-15"><a href="#cb105-15"></a>monkey/vm.runVmTests(0xc4200ba1e0, 0xc420079f58, 0x2, 0x2)</span>
<span id="cb105-16"><a href="#cb105-16"></a> /Users/mrnugget/code/02/src/monkey/vm/vm_test.go:60 +0x35a</span>
<span id="cb105-17"><a href="#cb105-17"></a>monkey/vm.TestBooleanExpressions(0xc4200ba1e0)</span>
<span id="cb105-18"><a href="#cb105-18"></a> /Users/mrnugget/code/02/src/monkey/vm/vm_test.go:39 +0xa0</span>
<span id="cb105-19"><a href="#cb105-19"></a>testing.tRunner(0xc4200ba1e0, 0x11476d0)</span>
<span id="cb105-20"><a href="#cb105-20"></a> /usr/local/go/src/testing/testing.go:777 +0xd0</span>
<span id="cb105-21"><a href="#cb105-21"></a>created by testing.(*T).Run</span>
<span id="cb105-22"><a href="#cb105-22"></a> /usr/local/go/src/testing/testing.go:824 +0x2e0</span>
<span id="cb105-23"><a href="#cb105-23"></a>FAIL    monkey/vm   0.011s</span></code></pre></div>
<p>It blows up because we’re so tidy and issue an <code>OpPop</code> after every expression statement to keep the stack clean. And when we try to pop something off the stack without first putting something on it, we get an <code>index out of range</code> panic.</p>
<p>The first step towards fixing this is to tell our VM about <code>true</code> and <code>false</code> and defining global <code>True</code> and <code>False</code> instances of them:</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb106-1"><a href="#cb106-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb106-2"><a href="#cb106-2"></a></span>
<span id="cb106-3"><a href="#cb106-3"></a><span class="kw">var</span> True = &amp;object.Boolean{Value: <span class="ot">true</span>}</span>
<span id="cb106-4"><a href="#cb106-4"></a><span class="kw">var</span> False = &amp;object.Boolean{Value: <span class="ot">false</span>}</span></code></pre></div>
<p>The reasons for reusing global instances of the <code>*object.Boolean</code>s are the same as in our <code>evaluator</code> package. First, these are immutable, unique values. <code>true</code> will always be <code>true</code> and <code>false</code> will always be <code>false</code>. Treating them as such by defining them as global variables is an absolute no-brainer in terms of performance. Why create new <code>*object.Boolean</code>s with the same value if we can just reference these two? The second reason is that this makes comparisons in Monkey, like <code>true == true</code>, easier to implement and perform, because we can just compare two pointers without having to unwrap the value they’re pointing at.</p>
<p>Of course, defining <code>True</code> and <code>False</code> does not magically make the tests pass. We also need to push them on to the stack when instructed to do so. For that we extend the main loop of our VM:</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb107-1"><a href="#cb107-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb107-2"><a href="#cb107-2"></a></span>
<span id="cb107-3"><a href="#cb107-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb107-4"><a href="#cb107-4"></a>    <span class="co">// [...]</span></span>
<span id="cb107-5"><a href="#cb107-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb107-6"><a href="#cb107-6"></a>        <span class="co">// [...]</span></span>
<span id="cb107-7"><a href="#cb107-7"></a></span>
<span id="cb107-8"><a href="#cb107-8"></a>        <span class="kw">case</span> code.OpTrue:</span>
<span id="cb107-9"><a href="#cb107-9"></a>            err := vm.push(True)</span>
<span id="cb107-10"><a href="#cb107-10"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb107-11"><a href="#cb107-11"></a>                <span class="kw">return</span> err</span>
<span id="cb107-12"><a href="#cb107-12"></a>            }</span>
<span id="cb107-13"><a href="#cb107-13"></a></span>
<span id="cb107-14"><a href="#cb107-14"></a>        <span class="kw">case</span> code.OpFalse:</span>
<span id="cb107-15"><a href="#cb107-15"></a>            err := vm.push(False)</span>
<span id="cb107-16"><a href="#cb107-16"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb107-17"><a href="#cb107-17"></a>                <span class="kw">return</span> err</span>
<span id="cb107-18"><a href="#cb107-18"></a>            }</span>
<span id="cb107-19"><a href="#cb107-19"></a></span>
<span id="cb107-20"><a href="#cb107-20"></a>        }</span>
<span id="cb107-21"><a href="#cb107-21"></a>    <span class="co">// [...]</span></span>
<span id="cb107-22"><a href="#cb107-22"></a>}</span></code></pre></div>
<p>Not much to explain here: we push the globals <code>True</code> and <code>False</code> on to the stack. That means that we <em>are</em> actually pushing something on to the stack before trying to clean it up again, which means our tests don’t blow up anymore:</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb108-1"><a href="#cb108-1"></a>$ go test ./vm</span>
<span id="cb108-2"><a href="#cb108-2"></a>ok      monkey/vm   0.007s</span></code></pre></div>
<p>Alright! Boolean literals work and our VM now knows about <code>True</code> and <code>False</code>. Now we can start to implement the comparison operators, because now we can put their results on to the stack.</p>
<h2 id="comparison-operators">Comparison Operators</h2>
<p>The four comparison operators in Monkey are: <code>==</code>, <code>!=</code>, <code>&gt;</code> and <code>&lt;</code>. We will now add support for all four of them by adding three (!) new opcode definitions and supporting them in the compiler and the VM. Here they are:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb109-1"><a href="#cb109-1"></a><span class="co">// code/code.go</span></span>
<span id="cb109-2"><a href="#cb109-2"></a></span>
<span id="cb109-3"><a href="#cb109-3"></a><span class="kw">const</span> (</span>
<span id="cb109-4"><a href="#cb109-4"></a>    <span class="co">// [...]</span></span>
<span id="cb109-5"><a href="#cb109-5"></a></span>
<span id="cb109-6"><a href="#cb109-6"></a>    OpEqual</span>
<span id="cb109-7"><a href="#cb109-7"></a>    OpNotEqual</span>
<span id="cb109-8"><a href="#cb109-8"></a>    OpGreaterThan</span>
<span id="cb109-9"><a href="#cb109-9"></a>)</span>
<span id="cb109-10"><a href="#cb109-10"></a></span>
<span id="cb109-11"><a href="#cb109-11"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb109-12"><a href="#cb109-12"></a>    <span class="co">// [...]</span></span>
<span id="cb109-13"><a href="#cb109-13"></a></span>
<span id="cb109-14"><a href="#cb109-14"></a>    OpEqual:       {<span class="st">&quot;OpEqual&quot;</span>, []<span class="dt">int</span>{}},</span>
<span id="cb109-15"><a href="#cb109-15"></a>    OpNotEqual:    {<span class="st">&quot;OpNotEqual&quot;</span>, []<span class="dt">int</span>{}},</span>
<span id="cb109-16"><a href="#cb109-16"></a>    OpGreaterThan: {<span class="st">&quot;OpGreaterThan&quot;</span>, []<span class="dt">int</span>{}},</span>
<span id="cb109-17"><a href="#cb109-17"></a>}</span></code></pre></div>
<p>They do not have operands and instead do their work by comparing the two topmost elements on the stack. They tell the VM to pop them off and push the result back on. Just like the opcodes for arithmetic operations.</p>
<p>You might be wondering why there is no opcode for <code>&lt;</code>. If we have <code>OpGreaterThan</code>, shouldn’t we have an <code>OpLessThan</code>, too? That’s a valid question, because we <em>could</em> add <code>OpLessThan</code> and that would be fine, but I want to show something that’s possible with compilation and not with interpretation: reordering of code.</p>
<p>The expression <code>3 &lt; 5</code> can be reordered to <code>5 &gt; 3</code> without changing its result. And because it can be reordered, that’s what our compiler is going to do. It will take every less-than expression and reorder it to emit the greater-than version instead. That way we keep the instruction set small, the loop of our VM tighter and learn about the things we can do with compilation.</p>
<p>Here are new test cases for the existing <code>TestBooleanExpressions</code> function that express this:</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb110-1"><a href="#cb110-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb110-2"><a href="#cb110-2"></a></span>
<span id="cb110-3"><a href="#cb110-3"></a><span class="kw">func</span> TestBooleanExpressions(t *testing.T) {</span>
<span id="cb110-4"><a href="#cb110-4"></a>    tests := []compilerTestCase{</span>
<span id="cb110-5"><a href="#cb110-5"></a>        <span class="co">// [...]</span></span>
<span id="cb110-6"><a href="#cb110-6"></a>        {</span>
<span id="cb110-7"><a href="#cb110-7"></a>            input:             <span class="st">&quot;1 &gt; 2&quot;</span>,</span>
<span id="cb110-8"><a href="#cb110-8"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">1</span>, <span class="dv">2</span>},</span>
<span id="cb110-9"><a href="#cb110-9"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb110-10"><a href="#cb110-10"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb110-11"><a href="#cb110-11"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb110-12"><a href="#cb110-12"></a>                code.Make(code.OpGreaterThan),</span>
<span id="cb110-13"><a href="#cb110-13"></a>                code.Make(code.OpPop),</span>
<span id="cb110-14"><a href="#cb110-14"></a>            },</span>
<span id="cb110-15"><a href="#cb110-15"></a>        },</span>
<span id="cb110-16"><a href="#cb110-16"></a>        {</span>
<span id="cb110-17"><a href="#cb110-17"></a>            input:             <span class="st">&quot;1 &lt; 2&quot;</span>,</span>
<span id="cb110-18"><a href="#cb110-18"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">2</span>, <span class="dv">1</span>},</span>
<span id="cb110-19"><a href="#cb110-19"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb110-20"><a href="#cb110-20"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb110-21"><a href="#cb110-21"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb110-22"><a href="#cb110-22"></a>                code.Make(code.OpGreaterThan),</span>
<span id="cb110-23"><a href="#cb110-23"></a>                code.Make(code.OpPop),</span>
<span id="cb110-24"><a href="#cb110-24"></a>            },</span>
<span id="cb110-25"><a href="#cb110-25"></a>        },</span>
<span id="cb110-26"><a href="#cb110-26"></a>        {</span>
<span id="cb110-27"><a href="#cb110-27"></a>            input:             <span class="st">&quot;1 == 2&quot;</span>,</span>
<span id="cb110-28"><a href="#cb110-28"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">1</span>, <span class="dv">2</span>},</span>
<span id="cb110-29"><a href="#cb110-29"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb110-30"><a href="#cb110-30"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb110-31"><a href="#cb110-31"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb110-32"><a href="#cb110-32"></a>                code.Make(code.OpEqual),</span>
<span id="cb110-33"><a href="#cb110-33"></a>                code.Make(code.OpPop),</span>
<span id="cb110-34"><a href="#cb110-34"></a>            },</span>
<span id="cb110-35"><a href="#cb110-35"></a>        },</span>
<span id="cb110-36"><a href="#cb110-36"></a>        {</span>
<span id="cb110-37"><a href="#cb110-37"></a>            input:             <span class="st">&quot;1 != 2&quot;</span>,</span>
<span id="cb110-38"><a href="#cb110-38"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">1</span>, <span class="dv">2</span>},</span>
<span id="cb110-39"><a href="#cb110-39"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb110-40"><a href="#cb110-40"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb110-41"><a href="#cb110-41"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb110-42"><a href="#cb110-42"></a>                code.Make(code.OpNotEqual),</span>
<span id="cb110-43"><a href="#cb110-43"></a>                code.Make(code.OpPop),</span>
<span id="cb110-44"><a href="#cb110-44"></a>            },</span>
<span id="cb110-45"><a href="#cb110-45"></a>        },</span>
<span id="cb110-46"><a href="#cb110-46"></a>        {</span>
<span id="cb110-47"><a href="#cb110-47"></a>            input:             <span class="st">&quot;true == false&quot;</span>,</span>
<span id="cb110-48"><a href="#cb110-48"></a>            expectedConstants: []<span class="kw">interface</span>{}{},</span>
<span id="cb110-49"><a href="#cb110-49"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb110-50"><a href="#cb110-50"></a>                code.Make(code.OpTrue),</span>
<span id="cb110-51"><a href="#cb110-51"></a>                code.Make(code.OpFalse),</span>
<span id="cb110-52"><a href="#cb110-52"></a>                code.Make(code.OpEqual),</span>
<span id="cb110-53"><a href="#cb110-53"></a>                code.Make(code.OpPop),</span>
<span id="cb110-54"><a href="#cb110-54"></a>            },</span>
<span id="cb110-55"><a href="#cb110-55"></a>        },</span>
<span id="cb110-56"><a href="#cb110-56"></a>        {</span>
<span id="cb110-57"><a href="#cb110-57"></a>            input:             <span class="st">&quot;true != false&quot;</span>,</span>
<span id="cb110-58"><a href="#cb110-58"></a>            expectedConstants: []<span class="kw">interface</span>{}{},</span>
<span id="cb110-59"><a href="#cb110-59"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb110-60"><a href="#cb110-60"></a>                code.Make(code.OpTrue),</span>
<span id="cb110-61"><a href="#cb110-61"></a>                code.Make(code.OpFalse),</span>
<span id="cb110-62"><a href="#cb110-62"></a>                code.Make(code.OpNotEqual),</span>
<span id="cb110-63"><a href="#cb110-63"></a>                code.Make(code.OpPop),</span>
<span id="cb110-64"><a href="#cb110-64"></a>            },</span>
<span id="cb110-65"><a href="#cb110-65"></a>        },</span>
<span id="cb110-66"><a href="#cb110-66"></a>    }</span>
<span id="cb110-67"><a href="#cb110-67"></a></span>
<span id="cb110-68"><a href="#cb110-68"></a>    runCompilerTests(t, tests)</span>
<span id="cb110-69"><a href="#cb110-69"></a>}</span></code></pre></div>
<p>What we want from our compiler is to emit two instructions to get the operands of the infix operators on to the stack and then one instruction with the correct comparison opcode. Pay attention to the expected constants in the <code>1 &lt; 2</code> test case: their order is reversed, because the opcode is the same as in the test case before, <code>OpGreaterThan</code>.</p>
<p>Running the tests shows us that the compiler is still clueless about these new operators and opcodes:</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb111-1"><a href="#cb111-1"></a>$ go test ./compiler</span>
<span id="cb111-2"><a href="#cb111-2"></a>--- FAIL: TestBooleanExpressions (0.00s)</span>
<span id="cb111-3"><a href="#cb111-3"></a> compiler_test.go:150: compiler error: unknown operator &gt;</span>
<span id="cb111-4"><a href="#cb111-4"></a>FAIL</span>
<span id="cb111-5"><a href="#cb111-5"></a>FAIL    monkey/compiler 0.007s</span></code></pre></div>
<p>What we have to do is to extend the <code>case *ast.InfixExpression</code> branch in our <code>Compile</code> method, where we already emit the other infix operator opcodes:</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb112-1"><a href="#cb112-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb112-2"><a href="#cb112-2"></a></span>
<span id="cb112-3"><a href="#cb112-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb112-4"><a href="#cb112-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb112-5"><a href="#cb112-5"></a>    <span class="co">// [...]</span></span>
<span id="cb112-6"><a href="#cb112-6"></a></span>
<span id="cb112-7"><a href="#cb112-7"></a>    <span class="kw">case</span> *ast.InfixExpression:</span>
<span id="cb112-8"><a href="#cb112-8"></a>        <span class="co">// [...]</span></span>
<span id="cb112-9"><a href="#cb112-9"></a></span>
<span id="cb112-10"><a href="#cb112-10"></a>        <span class="kw">switch</span> node.Operator {</span>
<span id="cb112-11"><a href="#cb112-11"></a>        <span class="kw">case</span> <span class="st">&quot;+&quot;</span>:</span>
<span id="cb112-12"><a href="#cb112-12"></a>            c.emit(code.OpAdd)</span>
<span id="cb112-13"><a href="#cb112-13"></a>        <span class="kw">case</span> <span class="st">&quot;-&quot;</span>:</span>
<span id="cb112-14"><a href="#cb112-14"></a>            c.emit(code.OpSub)</span>
<span id="cb112-15"><a href="#cb112-15"></a>        <span class="kw">case</span> <span class="st">&quot;*&quot;</span>:</span>
<span id="cb112-16"><a href="#cb112-16"></a>            c.emit(code.OpMul)</span>
<span id="cb112-17"><a href="#cb112-17"></a>        <span class="kw">case</span> <span class="st">&quot;/&quot;</span>:</span>
<span id="cb112-18"><a href="#cb112-18"></a>            c.emit(code.OpDiv)</span>
<span id="cb112-19"><a href="#cb112-19"></a>        <span class="kw">case</span> <span class="st">&quot;&gt;&quot;</span>:</span>
<span id="cb112-20"><a href="#cb112-20"></a>            c.emit(code.OpGreaterThan)</span>
<span id="cb112-21"><a href="#cb112-21"></a>        <span class="kw">case</span> <span class="st">&quot;==&quot;</span>:</span>
<span id="cb112-22"><a href="#cb112-22"></a>            c.emit(code.OpEqual)</span>
<span id="cb112-23"><a href="#cb112-23"></a>        <span class="kw">case</span> <span class="st">&quot;!=&quot;</span>:</span>
<span id="cb112-24"><a href="#cb112-24"></a>            c.emit(code.OpNotEqual)</span>
<span id="cb112-25"><a href="#cb112-25"></a>        <span class="kw">default</span>:</span>
<span id="cb112-26"><a href="#cb112-26"></a>            <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;unknown operator %s&quot;</span>, node.Operator)</span>
<span id="cb112-27"><a href="#cb112-27"></a>        }</span>
<span id="cb112-28"><a href="#cb112-28"></a></span>
<span id="cb112-29"><a href="#cb112-29"></a>    <span class="co">// [...]</span></span>
<span id="cb112-30"><a href="#cb112-30"></a>    }</span>
<span id="cb112-31"><a href="#cb112-31"></a></span>
<span id="cb112-32"><a href="#cb112-32"></a>    <span class="co">// [...]</span></span>
<span id="cb112-33"><a href="#cb112-33"></a>}</span></code></pre></div>
<p>What’s new are the <code>case</code> branches for the comparison operators and they’re pretty much self-explanatory. Support for the <code>&lt;</code> operator is still missing, though:</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb113-1"><a href="#cb113-1"></a>$ go test ./compiler</span>
<span id="cb113-2"><a href="#cb113-2"></a>--- FAIL: TestBooleanExpressions (0.00s)</span>
<span id="cb113-3"><a href="#cb113-3"></a> compiler_test.go:150: compiler error: unknown operator &lt;</span>
<span id="cb113-4"><a href="#cb113-4"></a>FAIL</span>
<span id="cb113-5"><a href="#cb113-5"></a>FAIL    monkey/compiler 0.006s</span></code></pre></div>
<p>Since this the operator for which we want to reorder the operands, its implementation is an addition right at the beginning of the <code>case</code> branch for <code>*ast.InfixExpression</code>:</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb114-1"><a href="#cb114-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb114-2"><a href="#cb114-2"></a></span>
<span id="cb114-3"><a href="#cb114-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb114-4"><a href="#cb114-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb114-5"><a href="#cb114-5"></a>    <span class="co">// [...]</span></span>
<span id="cb114-6"><a href="#cb114-6"></a></span>
<span id="cb114-7"><a href="#cb114-7"></a>    <span class="kw">case</span> *ast.InfixExpression:</span>
<span id="cb114-8"><a href="#cb114-8"></a>        <span class="kw">if</span> node.Operator == <span class="st">&quot;&lt;&quot;</span> {</span>
<span id="cb114-9"><a href="#cb114-9"></a>            err := c.Compile(node.Right)</span>
<span id="cb114-10"><a href="#cb114-10"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb114-11"><a href="#cb114-11"></a>                <span class="kw">return</span> err</span>
<span id="cb114-12"><a href="#cb114-12"></a>            }</span>
<span id="cb114-13"><a href="#cb114-13"></a></span>
<span id="cb114-14"><a href="#cb114-14"></a>            err = c.Compile(node.Left)</span>
<span id="cb114-15"><a href="#cb114-15"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb114-16"><a href="#cb114-16"></a>                <span class="kw">return</span> err</span>
<span id="cb114-17"><a href="#cb114-17"></a>            }</span>
<span id="cb114-18"><a href="#cb114-18"></a>            c.emit(code.OpGreaterThan)</span>
<span id="cb114-19"><a href="#cb114-19"></a>            <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb114-20"><a href="#cb114-20"></a>        }</span>
<span id="cb114-21"><a href="#cb114-21"></a></span>
<span id="cb114-22"><a href="#cb114-22"></a>        err := c.Compile(node.Left)</span>
<span id="cb114-23"><a href="#cb114-23"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb114-24"><a href="#cb114-24"></a>            <span class="kw">return</span> err</span>
<span id="cb114-25"><a href="#cb114-25"></a>        }</span>
<span id="cb114-26"><a href="#cb114-26"></a>        <span class="co">// [...]</span></span>
<span id="cb114-27"><a href="#cb114-27"></a></span>
<span id="cb114-28"><a href="#cb114-28"></a>    <span class="co">// [...]</span></span>
<span id="cb114-29"><a href="#cb114-29"></a>    }</span>
<span id="cb114-30"><a href="#cb114-30"></a></span>
<span id="cb114-31"><a href="#cb114-31"></a>    <span class="co">// [...]</span></span>
<span id="cb114-32"><a href="#cb114-32"></a>}</span></code></pre></div>
<p>What we did here is to turn <code>&lt;</code> into a special case. We turn the order around and first compile <code>node.Right</code> and <em>then</em> <code>node.Left</code> in case the operator is <code>&lt;</code>. After that we emit the <code>OpGreaterThan</code> opcode. We changed a less-than comparison into a greater-than comparison – while compiling. And it works:</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb115-1"><a href="#cb115-1"></a>$ go test ./compiler</span>
<span id="cb115-2"><a href="#cb115-2"></a>ok      monkey/compiler 0.007s</span></code></pre></div>
<p>The goal is, of course, that it looks to VM as if there is no such thing as a <code>&lt;</code> operator. All the VM should worry about are <code>OpGreaterThan</code> instructions. And now that we are sure our compiler only emits those, we can turn to our VM tests:</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb116-1"><a href="#cb116-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb116-2"><a href="#cb116-2"></a></span>
<span id="cb116-3"><a href="#cb116-3"></a><span class="kw">func</span> TestBooleanExpressions(t *testing.T) {</span>
<span id="cb116-4"><a href="#cb116-4"></a>    tests := []vmTestCase{</span>
<span id="cb116-5"><a href="#cb116-5"></a>        <span class="co">// [...]</span></span>
<span id="cb116-6"><a href="#cb116-6"></a>        {<span class="st">&quot;1 &lt; 2&quot;</span>, <span class="ot">true</span>},</span>
<span id="cb116-7"><a href="#cb116-7"></a>        {<span class="st">&quot;1 &gt; 2&quot;</span>, <span class="ot">false</span>},</span>
<span id="cb116-8"><a href="#cb116-8"></a>        {<span class="st">&quot;1 &lt; 1&quot;</span>, <span class="ot">false</span>},</span>
<span id="cb116-9"><a href="#cb116-9"></a>        {<span class="st">&quot;1 &gt; 1&quot;</span>, <span class="ot">false</span>},</span>
<span id="cb116-10"><a href="#cb116-10"></a>        {<span class="st">&quot;1 == 1&quot;</span>, <span class="ot">true</span>},</span>
<span id="cb116-11"><a href="#cb116-11"></a>        {<span class="st">&quot;1 != 1&quot;</span>, <span class="ot">false</span>},</span>
<span id="cb116-12"><a href="#cb116-12"></a>        {<span class="st">&quot;1 == 2&quot;</span>, <span class="ot">false</span>},</span>
<span id="cb116-13"><a href="#cb116-13"></a>        {<span class="st">&quot;1 != 2&quot;</span>, <span class="ot">true</span>},</span>
<span id="cb116-14"><a href="#cb116-14"></a>        {<span class="st">&quot;true == true&quot;</span>, <span class="ot">true</span>},</span>
<span id="cb116-15"><a href="#cb116-15"></a>        {<span class="st">&quot;false == false&quot;</span>, <span class="ot">true</span>},</span>
<span id="cb116-16"><a href="#cb116-16"></a>        {<span class="st">&quot;true == false&quot;</span>, <span class="ot">false</span>},</span>
<span id="cb116-17"><a href="#cb116-17"></a>        {<span class="st">&quot;true != false&quot;</span>, <span class="ot">true</span>},</span>
<span id="cb116-18"><a href="#cb116-18"></a>        {<span class="st">&quot;false != true&quot;</span>, <span class="ot">true</span>},</span>
<span id="cb116-19"><a href="#cb116-19"></a>        {<span class="st">&quot;(1 &lt; 2) == true&quot;</span>, <span class="ot">true</span>},</span>
<span id="cb116-20"><a href="#cb116-20"></a>        {<span class="st">&quot;(1 &lt; 2) == false&quot;</span>, <span class="ot">false</span>},</span>
<span id="cb116-21"><a href="#cb116-21"></a>        {<span class="st">&quot;(1 &gt; 2) == true&quot;</span>, <span class="ot">false</span>},</span>
<span id="cb116-22"><a href="#cb116-22"></a>        {<span class="st">&quot;(1 &gt; 2) == false&quot;</span>, <span class="ot">true</span>},</span>
<span id="cb116-23"><a href="#cb116-23"></a>    }</span>
<span id="cb116-24"><a href="#cb116-24"></a></span>
<span id="cb116-25"><a href="#cb116-25"></a>    runVmTests(t, tests)</span>
<span id="cb116-26"><a href="#cb116-26"></a>}</span></code></pre></div>
<p>Yes, I went totally overboard here. But aren’t these test cases neat? I guess that’s what great tooling and infrastructure does for you: reduce the cost of adding new tests and, thus, features. Anyway, as neat as they may be, they fail:</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb117-1"><a href="#cb117-1"></a>$ go test ./vm</span>
<span id="cb117-2"><a href="#cb117-2"></a>--- FAIL: TestBooleanExpressions (0.00s)</span>
<span id="cb117-3"><a href="#cb117-3"></a> vm_test.go:57: testBooleanObject failed: object is not Boolean.\</span>
<span id="cb117-4"><a href="#cb117-4"></a>   got=*object.Integer (&amp;{Value:1})</span>
<span id="cb117-5"><a href="#cb117-5"></a> vm_test.go:57: testBooleanObject failed: object is not Boolean.\</span>
<span id="cb117-6"><a href="#cb117-6"></a>   got=*object.Integer (&amp;{Value:2})</span>
<span id="cb117-7"><a href="#cb117-7"></a> vm_test.go:57: testBooleanObject failed: object is not Boolean.\</span>
<span id="cb117-8"><a href="#cb117-8"></a>   got=*object.Integer (&amp;{Value:1})</span>
<span id="cb117-9"><a href="#cb117-9"></a> vm_test.go:57: testBooleanObject failed: object is not Boolean.\</span>
<span id="cb117-10"><a href="#cb117-10"></a>   got=*object.Integer (&amp;{Value:1})</span>
<span id="cb117-11"><a href="#cb117-11"></a> vm_test.go:57: testBooleanObject failed: object is not Boolean.\</span>
<span id="cb117-12"><a href="#cb117-12"></a>   got=*object.Integer (&amp;{Value:1})</span>
<span id="cb117-13"><a href="#cb117-13"></a> vm_test.go:57: testBooleanObject failed: object is not Boolean.\</span>
<span id="cb117-14"><a href="#cb117-14"></a>   got=*object.Integer (&amp;{Value:1})</span>
<span id="cb117-15"><a href="#cb117-15"></a> vm_test.go:57: testBooleanObject failed: object is not Boolean.\</span>
<span id="cb117-16"><a href="#cb117-16"></a>   got=*object.Integer (&amp;{Value:2})</span>
<span id="cb117-17"><a href="#cb117-17"></a> vm_test.go:57: testBooleanObject failed: object is not Boolean.\</span>
<span id="cb117-18"><a href="#cb117-18"></a>   got=*object.Integer (&amp;{Value:2})</span>
<span id="cb117-19"><a href="#cb117-19"></a> vm_test.go:57: testBooleanObject failed: object has wrong value.\</span>
<span id="cb117-20"><a href="#cb117-20"></a>   got=false, want=true</span>
<span id="cb117-21"><a href="#cb117-21"></a> vm_test.go:57: testBooleanObject failed: object has wrong value.\</span>
<span id="cb117-22"><a href="#cb117-22"></a>   got=false, want=true</span>
<span id="cb117-23"><a href="#cb117-23"></a> vm_test.go:57: testBooleanObject failed: object has wrong value.\</span>
<span id="cb117-24"><a href="#cb117-24"></a>   got=true, want=false</span>
<span id="cb117-25"><a href="#cb117-25"></a> vm_test.go:57: testBooleanObject failed: object has wrong value.\</span>
<span id="cb117-26"><a href="#cb117-26"></a>   got=false, want=true</span>
<span id="cb117-27"><a href="#cb117-27"></a>FAIL</span>
<span id="cb117-28"><a href="#cb117-28"></a>FAIL    monkey/vm   0.008s</span></code></pre></div>
<p>You and I know we’re on a roll here and that it doesn’t take much to make all of these error messages disappear. First, we add a new <code>case</code> branch to our VM’s <code>Run</code> method, so it handles the new comparison opcodes:</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb118-1"><a href="#cb118-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb118-2"><a href="#cb118-2"></a></span>
<span id="cb118-3"><a href="#cb118-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb118-4"><a href="#cb118-4"></a>    <span class="co">// [...]</span></span>
<span id="cb118-5"><a href="#cb118-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb118-6"><a href="#cb118-6"></a>        <span class="co">// [...]</span></span>
<span id="cb118-7"><a href="#cb118-7"></a></span>
<span id="cb118-8"><a href="#cb118-8"></a>        <span class="kw">case</span> code.OpEqual, code.OpNotEqual, code.OpGreaterThan:</span>
<span id="cb118-9"><a href="#cb118-9"></a>            err := vm.executeComparison(op)</span>
<span id="cb118-10"><a href="#cb118-10"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb118-11"><a href="#cb118-11"></a>                <span class="kw">return</span> err</span>
<span id="cb118-12"><a href="#cb118-12"></a>            }</span>
<span id="cb118-13"><a href="#cb118-13"></a></span>
<span id="cb118-14"><a href="#cb118-14"></a>        <span class="co">// [...]</span></span>
<span id="cb118-15"><a href="#cb118-15"></a>        }</span>
<span id="cb118-16"><a href="#cb118-16"></a>    <span class="co">// [...]</span></span>
<span id="cb118-17"><a href="#cb118-17"></a>}</span></code></pre></div>
<p>The <code>executionComparison</code> method looks pretty similar to the previously added <code>executeBinaryOperation</code>:</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb119-1"><a href="#cb119-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb119-2"><a href="#cb119-2"></a></span>
<span id="cb119-3"><a href="#cb119-3"></a><span class="kw">func</span> (vm *VM) executeComparison(op code.Opcode) <span class="dt">error</span> {</span>
<span id="cb119-4"><a href="#cb119-4"></a>    right := vm.pop()</span>
<span id="cb119-5"><a href="#cb119-5"></a>    left := vm.pop()</span>
<span id="cb119-6"><a href="#cb119-6"></a></span>
<span id="cb119-7"><a href="#cb119-7"></a>    <span class="kw">if</span> left.Type() == object.INTEGER_OBJ &amp;&amp; right.Type() == object.INTEGER_OBJ {</span>
<span id="cb119-8"><a href="#cb119-8"></a>        <span class="kw">return</span> vm.executeIntegerComparison(op, left, right)</span>
<span id="cb119-9"><a href="#cb119-9"></a>    }</span>
<span id="cb119-10"><a href="#cb119-10"></a></span>
<span id="cb119-11"><a href="#cb119-11"></a>    <span class="kw">switch</span> op {</span>
<span id="cb119-12"><a href="#cb119-12"></a>    <span class="kw">case</span> code.OpEqual:</span>
<span id="cb119-13"><a href="#cb119-13"></a>        <span class="kw">return</span> vm.push(nativeBoolToBooleanObject(right == left))</span>
<span id="cb119-14"><a href="#cb119-14"></a>    <span class="kw">case</span> code.OpNotEqual:</span>
<span id="cb119-15"><a href="#cb119-15"></a>        <span class="kw">return</span> vm.push(nativeBoolToBooleanObject(right != left))</span>
<span id="cb119-16"><a href="#cb119-16"></a>    <span class="kw">default</span>:</span>
<span id="cb119-17"><a href="#cb119-17"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;unknown operator: %d (%s %s)&quot;</span>,</span>
<span id="cb119-18"><a href="#cb119-18"></a>            op, left.Type(), right.Type())</span>
<span id="cb119-19"><a href="#cb119-19"></a>    }</span>
<span id="cb119-20"><a href="#cb119-20"></a>}</span></code></pre></div>
<p>First we pop the two operands off the stack and check their types. If they’re both integers, we’ll defer to <code>executeIntegerComparison</code>. If not, we use <code>nativeBoolToBooleanObject</code> to turn the Go <code>bool</code>s into Monkey <code>*object.Boolean</code>s and push the result back on to the stack.</p>
<p>The recipe for this method is simple: pop the operands off the stack, compare them, push the result back on to the stack. We can find the second half of that again in <code>executeIntegerComparison</code>:</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb120-1"><a href="#cb120-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb120-2"><a href="#cb120-2"></a></span>
<span id="cb120-3"><a href="#cb120-3"></a><span class="kw">func</span> (vm *VM) executeIntegerComparison(</span>
<span id="cb120-4"><a href="#cb120-4"></a>    op code.Opcode,</span>
<span id="cb120-5"><a href="#cb120-5"></a>    left, right object.Object,</span>
<span id="cb120-6"><a href="#cb120-6"></a>) <span class="dt">error</span> {</span>
<span id="cb120-7"><a href="#cb120-7"></a>    leftValue := left.(*object.Integer).Value</span>
<span id="cb120-8"><a href="#cb120-8"></a>    rightValue := right.(*object.Integer).Value</span>
<span id="cb120-9"><a href="#cb120-9"></a></span>
<span id="cb120-10"><a href="#cb120-10"></a>    <span class="kw">switch</span> op {</span>
<span id="cb120-11"><a href="#cb120-11"></a>    <span class="kw">case</span> code.OpEqual:</span>
<span id="cb120-12"><a href="#cb120-12"></a>        <span class="kw">return</span> vm.push(nativeBoolToBooleanObject(rightValue == leftValue))</span>
<span id="cb120-13"><a href="#cb120-13"></a>    <span class="kw">case</span> code.OpNotEqual:</span>
<span id="cb120-14"><a href="#cb120-14"></a>        <span class="kw">return</span> vm.push(nativeBoolToBooleanObject(rightValue != leftValue))</span>
<span id="cb120-15"><a href="#cb120-15"></a>    <span class="kw">case</span> code.OpGreaterThan:</span>
<span id="cb120-16"><a href="#cb120-16"></a>        <span class="kw">return</span> vm.push(nativeBoolToBooleanObject(leftValue &gt; rightValue))</span>
<span id="cb120-17"><a href="#cb120-17"></a>    <span class="kw">default</span>:</span>
<span id="cb120-18"><a href="#cb120-18"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;unknown operator: %d&quot;</span>, op)</span>
<span id="cb120-19"><a href="#cb120-19"></a>    }</span>
<span id="cb120-20"><a href="#cb120-20"></a>}</span></code></pre></div>
<p>In this method we do not need to pop off anything anymore, but can go straight to unwrapping the integer values contained in <code>left</code> and <code>right</code>. And then, again, we compare the operands and turn the resulting <code>bool</code> into <code>True</code> or <code>False</code>. If you’re excited to learn how <em>that</em> is done, I’m sorry, it’s really rather simple. Here is <code>nativeBoolToBooleanObject</code>:</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb121-1"><a href="#cb121-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb121-2"><a href="#cb121-2"></a></span>
<span id="cb121-3"><a href="#cb121-3"></a><span class="kw">func</span> nativeBoolToBooleanObject(input <span class="dt">bool</span>) *object.Boolean {</span>
<span id="cb121-4"><a href="#cb121-4"></a>    <span class="kw">if</span> input {</span>
<span id="cb121-5"><a href="#cb121-5"></a>        <span class="kw">return</span> True</span>
<span id="cb121-6"><a href="#cb121-6"></a>    }</span>
<span id="cb121-7"><a href="#cb121-7"></a>    <span class="kw">return</span> False</span>
<span id="cb121-8"><a href="#cb121-8"></a>}</span></code></pre></div>
<p>In total, that’s three new methods: <code>executeComparison</code>, <code>executeIntegerComparison</code> and <code>nativeBoolToBooleanObject</code>. And that’s all it takes for the tests to pass:</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb122-1"><a href="#cb122-1"></a>$ go test ./vm</span>
<span id="cb122-2"><a href="#cb122-2"></a>ok      monkey/vm   0.008s</span></code></pre></div>
<p>I told you, we’re on a roll here.</p>
<h2 id="prefix-expressions">Prefix Expressions</h2>
<p>Monkey supports the two prefix operators <code>-</code> and <code>!</code>. The first one negates integers and the second one booleans. Adding support for them to our compiler and VM means nearly the same as for the previous operators: define the necessary opcodes, emit them in the compiler and handle them in the VM. The difference is that this time we have to do even <em>less</em>, because the prefix operators only have <em>one</em> operand on the stack, instead of two.</p>
<p>Here are the two opcode definitions that translate to <code>-</code> and <code>!</code>:</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb123-1"><a href="#cb123-1"></a><span class="co">// code/code.go</span></span>
<span id="cb123-2"><a href="#cb123-2"></a></span>
<span id="cb123-3"><a href="#cb123-3"></a><span class="kw">const</span> (</span>
<span id="cb123-4"><a href="#cb123-4"></a>    <span class="co">// [...]</span></span>
<span id="cb123-5"><a href="#cb123-5"></a></span>
<span id="cb123-6"><a href="#cb123-6"></a>    OpMinus</span>
<span id="cb123-7"><a href="#cb123-7"></a>    OpBang</span>
<span id="cb123-8"><a href="#cb123-8"></a>)</span>
<span id="cb123-9"><a href="#cb123-9"></a></span>
<span id="cb123-10"><a href="#cb123-10"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb123-11"><a href="#cb123-11"></a>    <span class="co">// [...]</span></span>
<span id="cb123-12"><a href="#cb123-12"></a></span>
<span id="cb123-13"><a href="#cb123-13"></a>    OpMinus: {<span class="st">&quot;OpMinus&quot;</span>, []<span class="dt">int</span>{}},</span>
<span id="cb123-14"><a href="#cb123-14"></a>    OpBang:  {<span class="st">&quot;OpBang&quot;</span>, []<span class="dt">int</span>{}},</span>
<span id="cb123-15"><a href="#cb123-15"></a>}</span></code></pre></div>
<p>I don’t think I have to tell you which one’s which.</p>
<p>Next, we need to emit them in the compiler, which means we need to add compiler tests. Here it becomes clear that <code>-</code> is an integer operator and <code>!</code> negates booleans, because we won’t put them together in their own test function. Instead we add test cases for them to the respective test functions that already exist. Here is the test case for <code>OpMinus</code> in <code>TestIntegerArithmetic</code>:</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb124-1"><a href="#cb124-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb124-2"><a href="#cb124-2"></a></span>
<span id="cb124-3"><a href="#cb124-3"></a><span class="kw">func</span> TestIntegerArithmetic(t *testing.T) {</span>
<span id="cb124-4"><a href="#cb124-4"></a>    tests := []compilerTestCase{</span>
<span id="cb124-5"><a href="#cb124-5"></a>        <span class="co">// [...]</span></span>
<span id="cb124-6"><a href="#cb124-6"></a>        {</span>
<span id="cb124-7"><a href="#cb124-7"></a>            input:             <span class="st">&quot;-1&quot;</span>,</span>
<span id="cb124-8"><a href="#cb124-8"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">1</span>},</span>
<span id="cb124-9"><a href="#cb124-9"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb124-10"><a href="#cb124-10"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb124-11"><a href="#cb124-11"></a>                code.Make(code.OpMinus),</span>
<span id="cb124-12"><a href="#cb124-12"></a>                code.Make(code.OpPop),</span>
<span id="cb124-13"><a href="#cb124-13"></a>            },</span>
<span id="cb124-14"><a href="#cb124-14"></a>        },</span>
<span id="cb124-15"><a href="#cb124-15"></a>    }</span>
<span id="cb124-16"><a href="#cb124-16"></a></span>
<span id="cb124-17"><a href="#cb124-17"></a>    runCompilerTests(t, tests)</span>
<span id="cb124-18"><a href="#cb124-18"></a>}</span></code></pre></div>
<p>And here is the test case for <code>OpBang</code> in <code>TestBooleanExpressions</code>:</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb125-1"><a href="#cb125-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb125-2"><a href="#cb125-2"></a></span>
<span id="cb125-3"><a href="#cb125-3"></a><span class="kw">func</span> TestBooleanExpressions(t *testing.T) {</span>
<span id="cb125-4"><a href="#cb125-4"></a>    tests := []compilerTestCase{</span>
<span id="cb125-5"><a href="#cb125-5"></a>        <span class="co">// [...]</span></span>
<span id="cb125-6"><a href="#cb125-6"></a>        {</span>
<span id="cb125-7"><a href="#cb125-7"></a>            input:             <span class="st">&quot;!true&quot;</span>,</span>
<span id="cb125-8"><a href="#cb125-8"></a>            expectedConstants: []<span class="kw">interface</span>{}{},</span>
<span id="cb125-9"><a href="#cb125-9"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb125-10"><a href="#cb125-10"></a>                code.Make(code.OpTrue),</span>
<span id="cb125-11"><a href="#cb125-11"></a>                code.Make(code.OpBang),</span>
<span id="cb125-12"><a href="#cb125-12"></a>                code.Make(code.OpPop),</span>
<span id="cb125-13"><a href="#cb125-13"></a>            },</span>
<span id="cb125-14"><a href="#cb125-14"></a>        },</span>
<span id="cb125-15"><a href="#cb125-15"></a>    }</span>
<span id="cb125-16"><a href="#cb125-16"></a></span>
<span id="cb125-17"><a href="#cb125-17"></a>    runCompilerTests(t, tests)</span>
<span id="cb125-18"><a href="#cb125-18"></a>}</span></code></pre></div>
<p>Now we have two failing test functions:</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb126-1"><a href="#cb126-1"></a>$ go test ./compiler</span>
<span id="cb126-2"><a href="#cb126-2"></a>--- FAIL: TestIntegerArithmetic (0.00s)</span>
<span id="cb126-3"><a href="#cb126-3"></a> compiler_test.go:76: testInstructions failed: wrong instructions length.</span>
<span id="cb126-4"><a href="#cb126-4"></a>  want=&quot;0000 OpConstant 0\n0003 OpMinus\n0004 OpPop\n&quot;</span>
<span id="cb126-5"><a href="#cb126-5"></a>  got =&quot;0000 OpPop\n&quot;</span>
<span id="cb126-6"><a href="#cb126-6"></a>--- FAIL: TestBooleanExpressions (0.00s)</span>
<span id="cb126-7"><a href="#cb126-7"></a> compiler_test.go:168: testInstructions failed: wrong instructions length.</span>
<span id="cb126-8"><a href="#cb126-8"></a>  want=&quot;0000 OpTrue\n0001 OpBang\n0002 OpPop\n&quot;</span>
<span id="cb126-9"><a href="#cb126-9"></a>  got =&quot;0000 OpPop\n&quot;</span>
<span id="cb126-10"><a href="#cb126-10"></a>FAIL</span>
<span id="cb126-11"><a href="#cb126-11"></a>FAIL    monkey/compiler 0.008s</span></code></pre></div>
<p>The failing assertions tell us that we’re missing two instructions. One to load the operand (<code>OpConstant</code> or <code>OpTrue</code>) and one for the prefix operator (<code>OpMinus</code> or <code>OpBang</code>).</p>
<p>Since we already know how to turn integer literals into <code>OpConstant</code> instructions and also how to emit <code>OpTrue</code> (and <code>OpFalse</code> for that matter), it’s irritating that this is not what’s happening in the <code>TestIntegerArithmetic</code> test. There is no <code>OpConstant</code> and no <code>OpTrue</code> in the output. Why?</p>
<p>When we take a closer look at the compiler, however, the cause is easy to spot: in the <code>Compile</code> method we don’t handle <code>*ast.PrefixExpression</code> nodes yet, we skip over them and that means we never compile the integer and boolean literals. Here’s what we need to change:</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb127-1"><a href="#cb127-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb127-2"><a href="#cb127-2"></a></span>
<span id="cb127-3"><a href="#cb127-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb127-4"><a href="#cb127-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb127-5"><a href="#cb127-5"></a>    <span class="co">// [...]</span></span>
<span id="cb127-6"><a href="#cb127-6"></a></span>
<span id="cb127-7"><a href="#cb127-7"></a>    <span class="kw">case</span> *ast.PrefixExpression:</span>
<span id="cb127-8"><a href="#cb127-8"></a>        err := c.Compile(node.Right)</span>
<span id="cb127-9"><a href="#cb127-9"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb127-10"><a href="#cb127-10"></a>            <span class="kw">return</span> err</span>
<span id="cb127-11"><a href="#cb127-11"></a>        }</span>
<span id="cb127-12"><a href="#cb127-12"></a></span>
<span id="cb127-13"><a href="#cb127-13"></a>        <span class="kw">switch</span> node.Operator {</span>
<span id="cb127-14"><a href="#cb127-14"></a>        <span class="kw">case</span> <span class="st">&quot;!&quot;</span>:</span>
<span id="cb127-15"><a href="#cb127-15"></a>            c.emit(code.OpBang)</span>
<span id="cb127-16"><a href="#cb127-16"></a>        <span class="kw">case</span> <span class="st">&quot;-&quot;</span>:</span>
<span id="cb127-17"><a href="#cb127-17"></a>            c.emit(code.OpMinus)</span>
<span id="cb127-18"><a href="#cb127-18"></a>        <span class="kw">default</span>:</span>
<span id="cb127-19"><a href="#cb127-19"></a>            <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;unknown operator %s&quot;</span>, node.Operator)</span>
<span id="cb127-20"><a href="#cb127-20"></a>        }</span>
<span id="cb127-21"><a href="#cb127-21"></a></span>
<span id="cb127-22"><a href="#cb127-22"></a>    <span class="co">// [...]</span></span>
<span id="cb127-23"><a href="#cb127-23"></a>    }</span>
<span id="cb127-24"><a href="#cb127-24"></a></span>
<span id="cb127-25"><a href="#cb127-25"></a>    <span class="co">// [...]</span></span>
<span id="cb127-26"><a href="#cb127-26"></a>}</span></code></pre></div>
<p>With that we walk the AST down one level further and first compile the <code>node.Right</code> branch of the <code>*ast.PrefixExpression</code> node. That results in the operand of the expression being compiled to either an <code>OpTrue</code> or an <code>OpConstant</code> instruction. That’s the first of the two missing instructions.</p>
<p>And we also need to emit the opcode for the operator itself. For that we make use of our trusted friend the <code>switch</code> statement and either generate a <code>OpBang</code> or a <code>OpMinus</code> instruction, depending on the <code>node.Operator</code> at hand.</p>
<p>And now we have passing tests:</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb128-1"><a href="#cb128-1"></a>$ go test ./compiler</span>
<span id="cb128-2"><a href="#cb128-2"></a>ok      monkey/compiler 0.008s</span></code></pre></div>
<p>Another milestone reached! By now you know where we’re headed next: the tests of our VM. Here, just like in our compiler tests, we add test cases to the existing <code>TestIntegerArithmetic</code> and <code>TestBooleanExpressions</code> functions:</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb129-1"><a href="#cb129-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb129-2"><a href="#cb129-2"></a></span>
<span id="cb129-3"><a href="#cb129-3"></a><span class="kw">func</span> TestIntegerArithmetic(t *testing.T) {</span>
<span id="cb129-4"><a href="#cb129-4"></a>    tests := []vmTestCase{</span>
<span id="cb129-5"><a href="#cb129-5"></a>        <span class="co">// [...]</span></span>
<span id="cb129-6"><a href="#cb129-6"></a>        {<span class="st">&quot;-5&quot;</span>, <span class="dv">-5</span>},</span>
<span id="cb129-7"><a href="#cb129-7"></a>        {<span class="st">&quot;-10&quot;</span>, <span class="dv">-10</span>},</span>
<span id="cb129-8"><a href="#cb129-8"></a>        {<span class="st">&quot;-50 + 100 + -50&quot;</span>, <span class="dv">0</span>},</span>
<span id="cb129-9"><a href="#cb129-9"></a>        {<span class="st">&quot;(5 + 10 * 2 + 15 / 3) * 2 + -10&quot;</span>, <span class="dv">50</span>},</span>
<span id="cb129-10"><a href="#cb129-10"></a>    }</span>
<span id="cb129-11"><a href="#cb129-11"></a></span>
<span id="cb129-12"><a href="#cb129-12"></a>    runVmTests(t, tests)</span>
<span id="cb129-13"><a href="#cb129-13"></a>}</span>
<span id="cb129-14"><a href="#cb129-14"></a></span>
<span id="cb129-15"><a href="#cb129-15"></a><span class="kw">func</span> TestBooleanExpressions(t *testing.T) {</span>
<span id="cb129-16"><a href="#cb129-16"></a>    tests := []vmTestCase{</span>
<span id="cb129-17"><a href="#cb129-17"></a>        <span class="co">// [...]</span></span>
<span id="cb129-18"><a href="#cb129-18"></a>        {<span class="st">&quot;!true&quot;</span>, <span class="ot">false</span>},</span>
<span id="cb129-19"><a href="#cb129-19"></a>        {<span class="st">&quot;!false&quot;</span>, <span class="ot">true</span>},</span>
<span id="cb129-20"><a href="#cb129-20"></a>        {<span class="st">&quot;!5&quot;</span>, <span class="ot">false</span>},</span>
<span id="cb129-21"><a href="#cb129-21"></a>        {<span class="st">&quot;!!true&quot;</span>, <span class="ot">true</span>},</span>
<span id="cb129-22"><a href="#cb129-22"></a>        {<span class="st">&quot;!!false&quot;</span>, <span class="ot">false</span>},</span>
<span id="cb129-23"><a href="#cb129-23"></a>        {<span class="st">&quot;!!5&quot;</span>, <span class="ot">true</span>},</span>
<span id="cb129-24"><a href="#cb129-24"></a>    }</span>
<span id="cb129-25"><a href="#cb129-25"></a></span>
<span id="cb129-26"><a href="#cb129-26"></a>    runVmTests(t, tests)</span>
<span id="cb129-27"><a href="#cb129-27"></a>}</span></code></pre></div>
<p>That’s a lot of new test cases for our VM to chew on, ranging from “tiny” to “completely overboard”, like the test case that exercises every integer operator we have. But these test cases are neat, they’re cheap, I love them and they blow up spectacularly:</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb130-1"><a href="#cb130-1"></a>$ go test ./vm</span>
<span id="cb130-2"><a href="#cb130-2"></a>--- FAIL: TestIntegerArithmetic (0.00s)</span>
<span id="cb130-3"><a href="#cb130-3"></a> vm_test.go:34: testIntegerObject failed: object has wrong value.\</span>
<span id="cb130-4"><a href="#cb130-4"></a>   got=5, want=-5</span>
<span id="cb130-5"><a href="#cb130-5"></a> vm_test.go:34: testIntegerObject failed: object has wrong value.\</span>
<span id="cb130-6"><a href="#cb130-6"></a>   got=10, want=-10</span>
<span id="cb130-7"><a href="#cb130-7"></a> vm_test.go:34: testIntegerObject failed: object has wrong value.\</span>
<span id="cb130-8"><a href="#cb130-8"></a>   got=200, want=0</span>
<span id="cb130-9"><a href="#cb130-9"></a> vm_test.go:34: testIntegerObject failed: object has wrong value.\</span>
<span id="cb130-10"><a href="#cb130-10"></a>   got=70, want=50</span>
<span id="cb130-11"><a href="#cb130-11"></a>--- FAIL: TestBooleanExpressions (0.00s)</span>
<span id="cb130-12"><a href="#cb130-12"></a> vm_test.go:66: testBooleanObject failed: object has wrong value.\</span>
<span id="cb130-13"><a href="#cb130-13"></a>   got=true, want=false</span>
<span id="cb130-14"><a href="#cb130-14"></a> vm_test.go:66: testBooleanObject failed: object has wrong value.\</span>
<span id="cb130-15"><a href="#cb130-15"></a>   got=false, want=true</span>
<span id="cb130-16"><a href="#cb130-16"></a> vm_test.go:66: testBooleanObject failed: object is not Boolean.\</span>
<span id="cb130-17"><a href="#cb130-17"></a>   got=*object.Integer (&amp;{Value:5})</span>
<span id="cb130-18"><a href="#cb130-18"></a> vm_test.go:66: testBooleanObject failed: object is not Boolean.\</span>
<span id="cb130-19"><a href="#cb130-19"></a>   got=*object.Integer (&amp;{Value:5})</span>
<span id="cb130-20"><a href="#cb130-20"></a>FAIL</span>
<span id="cb130-21"><a href="#cb130-21"></a>FAIL    monkey/vm   0.009s</span></code></pre></div>
<p>We’re pros, though. Spectacular test failures don’t give us pause. We don’t blink an eye and know what to do. First, we tackle the <code>OpBang</code> instructions and add the missing <code>case</code> branch to our VM’s main loop:</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb131-1"><a href="#cb131-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb131-2"><a href="#cb131-2"></a></span>
<span id="cb131-3"><a href="#cb131-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb131-4"><a href="#cb131-4"></a>    <span class="co">// [...]</span></span>
<span id="cb131-5"><a href="#cb131-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb131-6"><a href="#cb131-6"></a>        <span class="co">// [...]</span></span>
<span id="cb131-7"><a href="#cb131-7"></a></span>
<span id="cb131-8"><a href="#cb131-8"></a>        <span class="kw">case</span> code.OpBang:</span>
<span id="cb131-9"><a href="#cb131-9"></a>            err := vm.executeBangOperator()</span>
<span id="cb131-10"><a href="#cb131-10"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb131-11"><a href="#cb131-11"></a>                <span class="kw">return</span> err</span>
<span id="cb131-12"><a href="#cb131-12"></a>            }</span>
<span id="cb131-13"><a href="#cb131-13"></a></span>
<span id="cb131-14"><a href="#cb131-14"></a>        <span class="co">// [...]</span></span>
<span id="cb131-15"><a href="#cb131-15"></a>        }</span>
<span id="cb131-16"><a href="#cb131-16"></a>    <span class="co">// [...]</span></span>
<span id="cb131-17"><a href="#cb131-17"></a>}</span>
<span id="cb131-18"><a href="#cb131-18"></a></span>
<span id="cb131-19"><a href="#cb131-19"></a><span class="kw">func</span> (vm *VM) executeBangOperator() <span class="dt">error</span> {</span>
<span id="cb131-20"><a href="#cb131-20"></a>    operand := vm.pop()</span>
<span id="cb131-21"><a href="#cb131-21"></a></span>
<span id="cb131-22"><a href="#cb131-22"></a>    <span class="kw">switch</span> operand {</span>
<span id="cb131-23"><a href="#cb131-23"></a>    <span class="kw">case</span> True:</span>
<span id="cb131-24"><a href="#cb131-24"></a>        <span class="kw">return</span> vm.push(False)</span>
<span id="cb131-25"><a href="#cb131-25"></a>    <span class="kw">case</span> False:</span>
<span id="cb131-26"><a href="#cb131-26"></a>        <span class="kw">return</span> vm.push(True)</span>
<span id="cb131-27"><a href="#cb131-27"></a>    <span class="kw">default</span>:</span>
<span id="cb131-28"><a href="#cb131-28"></a>        <span class="kw">return</span> vm.push(False)</span>
<span id="cb131-29"><a href="#cb131-29"></a>    }</span>
<span id="cb131-30"><a href="#cb131-30"></a>}</span></code></pre></div>
<p>In <code>executeBangOperator</code> we pop the <code>operand</code> off the stack and negate its value by treating everything other than <code>False</code> as truthy. The <code>case True</code> branch is not necessary – technically speaking – but I think it makes sense to keep it around if only for documentation’s sake, because this method is now our VM’s implementation of Monkey’s concept of truthiness.</p>
<p>That fixes four test cases, but an equal number is still failing in <code>TestIntegerArithmetic</code>:</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb132-1"><a href="#cb132-1"></a>$ go test ./vm</span>
<span id="cb132-2"><a href="#cb132-2"></a>--- FAIL: TestIntegerArithmetic (0.00s)</span>
<span id="cb132-3"><a href="#cb132-3"></a> vm_test.go:34: testIntegerObject failed: object has wrong value.\</span>
<span id="cb132-4"><a href="#cb132-4"></a>   got=5, want=-5</span>
<span id="cb132-5"><a href="#cb132-5"></a> vm_test.go:34: testIntegerObject failed: object has wrong value.\</span>
<span id="cb132-6"><a href="#cb132-6"></a>   got=10, want=-10</span>
<span id="cb132-7"><a href="#cb132-7"></a> vm_test.go:34: testIntegerObject failed: object has wrong value.\</span>
<span id="cb132-8"><a href="#cb132-8"></a>   got=200, want=0</span>
<span id="cb132-9"><a href="#cb132-9"></a> vm_test.go:34: testIntegerObject failed: object has wrong value.\</span>
<span id="cb132-10"><a href="#cb132-10"></a>   got=70, want=50</span>
<span id="cb132-11"><a href="#cb132-11"></a>FAIL</span>
<span id="cb132-12"><a href="#cb132-12"></a>FAIL    monkey/vm   0.007s</span></code></pre></div>
<p>We now have to mirror what we did for <code>OpBang</code> and booleans and add a case branch for <code>OpMinus</code> to the VM’s <code>Run</code> method:</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb133-1"><a href="#cb133-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb133-2"><a href="#cb133-2"></a></span>
<span id="cb133-3"><a href="#cb133-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb133-4"><a href="#cb133-4"></a>    <span class="co">// [...]</span></span>
<span id="cb133-5"><a href="#cb133-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb133-6"><a href="#cb133-6"></a>        <span class="co">// [...]</span></span>
<span id="cb133-7"><a href="#cb133-7"></a></span>
<span id="cb133-8"><a href="#cb133-8"></a>        <span class="kw">case</span> code.OpMinus:</span>
<span id="cb133-9"><a href="#cb133-9"></a>            err := vm.executeMinusOperator()</span>
<span id="cb133-10"><a href="#cb133-10"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb133-11"><a href="#cb133-11"></a>                <span class="kw">return</span> err</span>
<span id="cb133-12"><a href="#cb133-12"></a>            }</span>
<span id="cb133-13"><a href="#cb133-13"></a></span>
<span id="cb133-14"><a href="#cb133-14"></a>        <span class="co">// [...]</span></span>
<span id="cb133-15"><a href="#cb133-15"></a>        }</span>
<span id="cb133-16"><a href="#cb133-16"></a>    <span class="co">// [...]</span></span>
<span id="cb133-17"><a href="#cb133-17"></a>}</span>
<span id="cb133-18"><a href="#cb133-18"></a></span>
<span id="cb133-19"><a href="#cb133-19"></a><span class="kw">func</span> (vm *VM) executeMinusOperator() <span class="dt">error</span> {</span>
<span id="cb133-20"><a href="#cb133-20"></a>    operand := vm.pop()</span>
<span id="cb133-21"><a href="#cb133-21"></a></span>
<span id="cb133-22"><a href="#cb133-22"></a>    <span class="kw">if</span> operand.Type() != object.INTEGER_OBJ {</span>
<span id="cb133-23"><a href="#cb133-23"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;unsupported type for negation: %s&quot;</span>, operand.Type())</span>
<span id="cb133-24"><a href="#cb133-24"></a>    }</span>
<span id="cb133-25"><a href="#cb133-25"></a></span>
<span id="cb133-26"><a href="#cb133-26"></a>    value := operand.(*object.Integer).Value</span>
<span id="cb133-27"><a href="#cb133-27"></a>    <span class="kw">return</span> vm.push(&amp;object.Integer{Value: -value})</span>
<span id="cb133-28"><a href="#cb133-28"></a>}</span></code></pre></div>
<p>I’ll spare you the explanation and present to you:</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb134-1"><a href="#cb134-1"></a>$ go test ./vm</span>
<span id="cb134-2"><a href="#cb134-2"></a>ok      monkey/vm   0.008s</span></code></pre></div>
<p>That means we’re done. We successfully added all of Monkey’s prefix and infix operators!</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb135-1"><a href="#cb135-1"></a>$ go build -o monkey . &amp;&amp; ./monkey</span>
<span id="cb135-2"><a href="#cb135-2"></a>Hello mrnugget! This is the Monkey programming language!</span>
<span id="cb135-3"><a href="#cb135-3"></a>Feel free to type in commands</span>
<span id="cb135-4"><a href="#cb135-4"></a>&gt;&gt; (10 + 50 + -5 - 5 * 2 / 2) &lt; (100 - 35)</span>
<span id="cb135-5"><a href="#cb135-5"></a>true</span>
<span id="cb135-6"><a href="#cb135-6"></a>&gt;&gt; !!true == false</span>
<span id="cb135-7"><a href="#cb135-7"></a>false</span></code></pre></div>
<p>By now you are quite familiar with the definition of new opcodes and the interaction between compiler and VM. Maybe you’re even bored by the zero-operand instructions we’re emitting, anxious to get to the good stuff. Well, I’ve got good news.</p>
<h1 id="conditionals">Conditionals</h1>
<p>The previous chapter was rather mechanic in that once we knew how to add one operator to our Monkey implementation, we could follow the same recipe for the others. In this chapter, though, we’re going to take it up a notch.</p>
<p>We need to answer a very concrete question: how do we get our VM to execute different bytecode instructions based on a condition? As we’ll see, there’s a number of small puzzles hiding behind this question and solving them is great fun, especially once we get down to the nitty-gritty. Before we do that, though, we have to answer this question without writing any code.</p>
<p>So let’s give this question a little bit of context and frame it. Monkey’s conditionals look like this:</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb136-1"><a href="#cb136-1"></a><span class="cf">if</span> (<span class="dv">5</span> <span class="op">&gt;</span> <span class="dv">3</span>) {</span>
<span id="cb136-2"><a href="#cb136-2"></a>  everythingsFine()<span class="op">;</span></span>
<span id="cb136-3"><a href="#cb136-3"></a>} <span class="cf">else</span> {</span>
<span id="cb136-4"><a href="#cb136-4"></a>  lawsOfUniverseBroken()<span class="op">;</span></span>
<span id="cb136-5"><a href="#cb136-5"></a>}</span></code></pre></div>
<p>If the condition <code>5 &gt; 3</code> evaluates to a truthy value, the first branch is executed. That’s the branch containing <code>everythingsFine()</code>. If the condition is not truthy, the <code>else</code> branch, containing <code>lawsOfUniverseBroken()</code>, is executed. The first branch is called the “consequence” and the <code>else</code> branch is called the “alternative” of a conditional.</p>
<p>In order to provide a blueprint for a possible implementation of conditionals and to refreshen your memory, let me go over the implementation of conditionals in <em>Writing An Interpreter In Go</em> real quick.</p>
<p>When we come across an <code>*ast.IfExpression</code> in the <code>evaluator</code> package’s <code>Eval</code> function, we evaluate its <code>Condition</code> and check the result with the <code>isTruthy</code> function. In case the value <em>is</em> truthy, we <code>Eval</code> the <code>Consequence</code> of the <code>*ast.IfExpression</code>. If it’s not truthy <em>and</em> the <code>*ast.IfExpression</code> has an <code>Alternative</code>, we <code>Eval</code> that instead. But if we don’t have an <code>Alternative</code>, we return an <code>*object.Null</code>.</p>
<p>All in all, implementing conditionals took us only around 50 lines of code. And the reason why it was so easy to implement was that we had the AST nodes on our hands. We could decide which side of the <code>*ast.IfExpression</code> to evaluate, because we had both available to us in the <code>evaluator</code>.</p>
<p>That’s not the case anymore. Instead of walking down the AST and executing it at the same time, we now turn the AST into bytecode and <em>flatten</em> it. “Flatten” because bytecode is a sequence of instructions and there are no child nodes we can choose to walk down or not. That brings us back to the hidden main question of this chapter and another problem we have to solve: how do we represent conditionals in bytecode?</p>
<p>Let’s say we have the following Monkey code:</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb137-1"><a href="#cb137-1"></a><span class="cf">if</span> (<span class="dv">5</span> <span class="op">&gt;</span> <span class="dv">2</span>) {</span>
<span id="cb137-2"><a href="#cb137-2"></a>  <span class="dv">30</span> <span class="op">+</span> <span class="dv">20</span></span>
<span id="cb137-3"><a href="#cb137-3"></a>} <span class="cf">else</span> {</span>
<span id="cb137-4"><a href="#cb137-4"></a>  <span class="dv">50</span> <span class="op">-</span> <span class="dv">25</span></span>
<span id="cb137-5"><a href="#cb137-5"></a>}</span></code></pre></div>
<p>We already know how to represent the condition <code>5 &gt; 2</code> in bytecode, because we implemented that in the last chapter:</p>
<!-- ./ascii_drawings/04/branching_intro.monopic -->
<figure>
<img src="./images/04/branching_intro_condition.svg" style="width:50.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>We also know how to represent the consequence, <code>30 + 20</code>:</p>
<!-- ./ascii_drawings/04/branching_intro.monopic -->
<figure>
<img src="./images/04/branching_intro_consequence.svg" style="width:50.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>Representing the alternative, the <code>50 - 25</code>, is just a variation of that:</p>
<!-- ./ascii_drawings/04/branching_intro.monopic -->
<figure>
<img src="./images/04/branching_intro_alternative.svg" style="width:50.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>But how do we tell the machine to either execute the one part or the other part, <em>depending on the result of the <code>OpGreaterThan</code> instruction</em>?</p>
<!-- ./ascii_drawings/04/branching_intro.monopic -->
<figure>
<img src="./images/04/branching_intro_how_to_jump.svg" style="width:80.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>If we were to take these instructions and pass them to the VM as a flat sequence, what would happen? The VM would execute all of them, one after the other, happily incrementing its instruction pointer, fetching, decoding and executing, without a care in the world, no decisions or branches in sight. And that’s exactly what we <em>don’t</em> want!</p>
<p>What we want is for the VM to <em>either</em> execute the <code>OpAdd</code> instruction <em>or</em> the <code>OpSub</code> instruction. But since we <em>do</em> pass bytecode around as a flat sequence of instructions, how do we do that? Well, if we reorder our graph of instructions so that it represents a flat sequence of instructions, the question becomes this: what do we fill in the blanks here?</p>
<!-- ./ascii_drawings/04/branching_intro.monopic -->
<figure>
<img src="./images/04/branching_intro_how_reordered.svg" style="width:25.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>We need to put <em>something</em> in the blanks so that based on the result of the <code>OpGreaterThan</code> instruction the VM either ignores the instructions of the consequence or the instructions making up the alternative. It should skip them. Or instead of “skip”, should we maybe say “jump over”?</p>
<h2 id="jumps">Jumps</h2>
<p>Jumps are instructions that tell machines to jump to other instructions. They’re used to implement branching (conditionals) in machine code, giving them the name “branch instructions”. And with “machine code” I mean the code that computers execute but also the bytecode virtual machines run on. Translated into the technical terms of our VM: jumps are instructions that tell the VM to change its instruction pointer to a certain value. Here’s how that works.</p>
<p>Let’s say – hypothetically speaking – that we had two jump opcodes and called them <code>JUMP_IF_NOT_TRUE</code> and <code>JUMP_NO_MATTER_WHAT</code>. We could use them to fill in the blanks in our graph from above like this:</p>
<!-- ./ascii_drawings/04/branching_intro.monopic -->
<figure>
<img src="./images/04/branching_jumps_first_instructions.svg" style="width:37.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>When the VM executes these instructions sequentially, top to bottom here, it would first execute the instructions making up the condition, ending with the <code>OpGreaterThan</code> instruction. That results in a boolean sitting on the stack. Just as we defined and implemented it in the previous chapter.</p>
<p>The next instruction, <code>JUMP_IF_NOT_TRUE</code>, would tell the VM to jump to the <code>OpConstant 4</code> instruction, <em>but only if</em> the boolean on the stack is <em>not</em> true. If that’s the case, the VM would <em>jump over</em> the consequence and right to the “else” part of the conditional, the alternative. And in case the boolean on the stack <em>is</em> true, the <code>JUMP_IF_NOT_TRUE</code> would have no effect and the VM would execute the consequence part of the conditional. It would increment its instruction pointer and start to fetch, decode and execute the next instruction – <code>OpConstant 2</code>, the start of the consequence.</p>
<p>Here’s where it gets interesting. After executing the consequence of the conditional – the three instructions that end with <code>OpAdd</code> – the VM would then come across the aptly named <code>JUMP_NO_MATTER_WHAT</code>. This instruction comes without any attached condition and tells the VM to directly jump to the first instruction <em>after</em> the alternative of the conditional, skipping it entirely.</p>
<p>That ends our little thought experiment and gives us a clear result: if we had two opcodes like these we could implement conditionals. But still, a last question remains: how would we represent the arrows? How do we tell the VM where to jump to?</p>
<p>Well, why not use numbers? Jumps are instructions that tell the VM to change the value of its instruction pointer and the arrows in the diagram above are nothing more than potential values for the instruction pointer. They can be represented as numbers, contained in the jump instructions as operands and their value being the index of the instruction the VM should jump to. That value is called an offset. Used like this, with the jump target being the index of an instruction, it’s an absolute offset. Relative offsets also exist: they’re relative to the position of the jump instruction itself and denote not <em>where exactly</em> to jump to, but <em>how far</em> to jump.</p>
<p>If we replace the arrows with offsets and give each instructions a unique index that’s independent of its byte size (for illustration purposes), the diagram looks like this:</p>
<!-- ./ascii_drawings/04/two_branch_conditional_bytecode.monopic -->
<figure>
<img src="./images/04/two_branch_conditional_bytecode.svg" style="width:40.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>The operand of <code>JUMP_IF_NOT_TRUE</code> is now <code>0008</code>. That’s the index of the <code>OpConstant 4</code> instruction to which the VM should jump in case the condition is not true. The operand of <code>JUMP_NO_MATTER_WHAT</code> is <code>0011</code>, which is the index of the instruction following the whole conditional.</p>
<p>And <em>that’s</em> how we’re going to implement conditionals! We’ll define two jump opcodes: one comes with a condition (“jump only if not true”) and one does not (“just jump”). They’ll both have one operand, the index of the instruction where the VM should jump to.</p>
<p>So that’s our goal. Question is: how do we get there?</p>
<h2 id="compiling-conditionals">Compiling Conditionals</h2>
<p>The hard part of emitting jump instructions is not choosing the right opcode. It’s the operands that make it challenging.</p>
<p>Say we’re in our compiler’s recursive <code>Compile</code> method, having just called <code>Compile</code> again, passing in the <code>.Condition</code> field of an <code>*ast.IfExpression</code>. The condition has been successfully compiled and we’ve emitted the translated instructions. Now we want to emit the jump instruction that tells the VM to skip to the consequence of the conditional if the value on the stack is not truthy.</p>
<p>Which operand do we give this jump instruction? Where do we tell the VM to jump to? We don’t know <em>yet</em>. Since we haven’t compiled the consequence or the alternative branch yet, we don’t how many instructions we’re going to emit, which means we don’t know how many instructions we have to jump over. <em>That’s</em> the challenge.</p>
<p>I have to admit that solving this is a lot of fun. And a great part of the fun comes from the fact that it’s pretty easy to write a test and tell the compiler exactly what’s expected – because we’re pretty sure about that part – and then make your way there step by step.</p>
<p>But we can only make assertions once we defined our new opcodes, so we’ll do that now. One for a jump and another one for a conditional jump.</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb138-1"><a href="#cb138-1"></a><span class="co">// code/code.go</span></span>
<span id="cb138-2"><a href="#cb138-2"></a></span>
<span id="cb138-3"><a href="#cb138-3"></a><span class="kw">const</span> (</span>
<span id="cb138-4"><a href="#cb138-4"></a>    <span class="co">// [...]</span></span>
<span id="cb138-5"><a href="#cb138-5"></a></span>
<span id="cb138-6"><a href="#cb138-6"></a>    OpJumpNotTruthy</span>
<span id="cb138-7"><a href="#cb138-7"></a>    OpJump</span>
<span id="cb138-8"><a href="#cb138-8"></a>)</span>
<span id="cb138-9"><a href="#cb138-9"></a></span>
<span id="cb138-10"><a href="#cb138-10"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb138-11"><a href="#cb138-11"></a>    <span class="co">// [...]</span></span>
<span id="cb138-12"><a href="#cb138-12"></a></span>
<span id="cb138-13"><a href="#cb138-13"></a>    OpJumpNotTruthy: {<span class="st">&quot;OpJumpNotTruthy&quot;</span>, []<span class="dt">int</span>{<span class="dv">2</span>}},</span>
<span id="cb138-14"><a href="#cb138-14"></a>    OpJump:          {<span class="st">&quot;OpJump&quot;</span>, []<span class="dt">int</span>{<span class="dv">2</span>}},</span>
<span id="cb138-15"><a href="#cb138-15"></a>}</span></code></pre></div>
<p>I’m pretty sure you can tell which one’s which. <code>OpJumpNotTruthy</code> will tell the VM to only jump if the value on top of the stack is not Monkey truthy, <em>i.e.</em>, not <code>false</code> nor null. Its single operand is the offset of the instruction the VM should jump to. <code>OpJump</code> will tell the VM to just “jump there”, with “there” being its operand, also an offset of an instruction.</p>
<p>The operand of both opcodes is 16-bit wide. That’s the same width as the operand of <code>OpConstant</code> has, which means we don’t have to extend our tooling in the <code>code</code> package to support it.</p>
<p>We’re now ready to write a first test. And we’ll start slow and only try to handle a conditional without an <code>else</code> part first. Here’s what we want the compiler to emit when we provide it a single-branch conditional:</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb139-1"><a href="#cb139-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb139-2"><a href="#cb139-2"></a></span>
<span id="cb139-3"><a href="#cb139-3"></a><span class="kw">func</span> TestConditionals(t *testing.T) {</span>
<span id="cb139-4"><a href="#cb139-4"></a>    tests := []compilerTestCase{</span>
<span id="cb139-5"><a href="#cb139-5"></a>        {</span>
<span id="cb139-6"><a href="#cb139-6"></a>            input: <span class="st">`</span></span>
<span id="cb139-7"><a href="#cb139-7"></a><span class="st">            if (true) { 10 }; 3333;</span></span>
<span id="cb139-8"><a href="#cb139-8"></a><span class="st">            `</span>,</span>
<span id="cb139-9"><a href="#cb139-9"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">10</span>, <span class="dv">3333</span>},</span>
<span id="cb139-10"><a href="#cb139-10"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb139-11"><a href="#cb139-11"></a>                <span class="co">// 0000</span></span>
<span id="cb139-12"><a href="#cb139-12"></a>                code.Make(code.OpTrue),</span>
<span id="cb139-13"><a href="#cb139-13"></a>                <span class="co">// 0001</span></span>
<span id="cb139-14"><a href="#cb139-14"></a>                code.Make(code.OpJumpNotTruthy, <span class="dv">7</span>),</span>
<span id="cb139-15"><a href="#cb139-15"></a>                <span class="co">// 0004</span></span>
<span id="cb139-16"><a href="#cb139-16"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb139-17"><a href="#cb139-17"></a>                <span class="co">// 0007</span></span>
<span id="cb139-18"><a href="#cb139-18"></a>                code.Make(code.OpPop),</span>
<span id="cb139-19"><a href="#cb139-19"></a>                <span class="co">// 0008</span></span>
<span id="cb139-20"><a href="#cb139-20"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb139-21"><a href="#cb139-21"></a>                <span class="co">// 0011</span></span>
<span id="cb139-22"><a href="#cb139-22"></a>                code.Make(code.OpPop),</span>
<span id="cb139-23"><a href="#cb139-23"></a>            },</span>
<span id="cb139-24"><a href="#cb139-24"></a>        },</span>
<span id="cb139-25"><a href="#cb139-25"></a>    }</span>
<span id="cb139-26"><a href="#cb139-26"></a></span>
<span id="cb139-27"><a href="#cb139-27"></a>    runCompilerTests(t, tests)</span>
<span id="cb139-28"><a href="#cb139-28"></a>}</span></code></pre></div>
<p>Once parsed, the <code>input</code> turns into an <code>*ast.IfExpression</code> with a <code>Condition</code> and a <code>Consequence</code>. The <code>Condition</code> is the boolean literal <code>true</code> and the <code>Consequence</code> is the integer literal <code>10</code>. Both are intentionally simple Monkey expressions, because in this test case we do not care about the expressions themselves. What we care about are the jump instructions the compiler emits and that they have correct operands.</p>
<p>That’s why I annotated the <code>expectedInstructions</code> with comments that show the offset of the instructions generated by <code>code.Make</code>. We won’t need these comments later on, but for now, they help us writing out the expected jump instructions, especially since the offsets of the instructions we want to jump to are based on the number of bytes each instruction takes up. An <code>OpPop</code> instruction is one byte wide, for example, but an <code>OpConstant</code> instruction takes up three bytes.</p>
<p>The first instruction we expect the compiler to emit is an <code>OpTrue</code> instruction to tell the VM to push <code>vm.True</code> on to the stack. That’s the <code>Condition</code>. Then it should emit an <code>OpJumpNotTruthy</code> instruction that causes the VM to jump over the <code>Consequence</code>, with the <code>Consequence</code> being the <code>OpConstant</code> instruction that loads the integer <code>10</code> on to the stack.</p>
<p>But where does the first <code>OpPop</code> instruction (offset <code>0007</code>) come from? It’s not part of the <code>Consequence</code>, no. It’s there because conditionals in Monkey are expressions – <code>if (true) { 10 }</code> evaluates to <code>10</code> – and stand-alone expressions whose value is unused are wrapped in an <code>*ast.ExpressionStatement</code>. And those we compile with an appended <code>OpPop</code> instruction in order to clear the VM’s stack. The first <code>OpPop</code> is thus the first instruction <em>after</em> the whole conditional, which makes its offset the location where <code>OpJumpNotTruthy</code> needs to jump to in order to skip the consequence.</p>
<p>So now you might be wondering what the <code>3333;</code> is doing in the Monkey code. It serves as a point of reference. It’s not strictly required, but in order to make sure that our jump offsets are correct it helps to have one expression in the code which we can easily find among the resulting instructions and use as a signpost that tells us where we <em>shouldn’t</em> jump to. Of course, the <code>OpConstant 1</code> instruction that loads <code>3333</code> is also followed by an <code>OpPop</code> instruction, since it’s an expression statement.</p>
<p>Quite the long explanation for one test. Here’s how much the compiler understands of it:</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb140-1"><a href="#cb140-1"></a>$ go test ./compiler</span>
<span id="cb140-2"><a href="#cb140-2"></a>--- FAIL: TestConditionals (0.00s)</span>
<span id="cb140-3"><a href="#cb140-3"></a> compiler_test.go:195: testInstructions failed: wrong instructions length.</span>
<span id="cb140-4"><a href="#cb140-4"></a>  want=&quot;0000 OpTrue\n0001 OpJumpNotTruthy 7\n0004 OpConstant 0\n0007 OpPop\</span>
<span id="cb140-5"><a href="#cb140-5"></a>    \n0008 OpConstant 1\n0011 OpPop\n&quot;</span>
<span id="cb140-6"><a href="#cb140-6"></a>  got =&quot;0000 OpPop\n0001 OpConstant 0\n0004 OpPop\n&quot;</span>
<span id="cb140-7"><a href="#cb140-7"></a>FAIL</span>
<span id="cb140-8"><a href="#cb140-8"></a>FAIL    monkey/compiler 0.008s</span></code></pre></div>
<p>Neither the condition nor the consequence of the conditional are compiled. In fact, the whole <code>*ast.IfExpression</code> is skipped by the compiler. We can fix the first issue, the condition not being compiled, by extending the compiler’s <code>Compile</code> method like this:</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb141-1"><a href="#cb141-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb141-2"><a href="#cb141-2"></a></span>
<span id="cb141-3"><a href="#cb141-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb141-4"><a href="#cb141-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb141-5"><a href="#cb141-5"></a>    <span class="co">// [...]</span></span>
<span id="cb141-6"><a href="#cb141-6"></a></span>
<span id="cb141-7"><a href="#cb141-7"></a>    <span class="kw">case</span> *ast.IfExpression:</span>
<span id="cb141-8"><a href="#cb141-8"></a>        err := c.Compile(node.Condition)</span>
<span id="cb141-9"><a href="#cb141-9"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb141-10"><a href="#cb141-10"></a>            <span class="kw">return</span> err</span>
<span id="cb141-11"><a href="#cb141-11"></a>        }</span>
<span id="cb141-12"><a href="#cb141-12"></a></span>
<span id="cb141-13"><a href="#cb141-13"></a>    <span class="co">// [...]</span></span>
<span id="cb141-14"><a href="#cb141-14"></a>    }</span>
<span id="cb141-15"><a href="#cb141-15"></a></span>
<span id="cb141-16"><a href="#cb141-16"></a>    <span class="co">// [...]</span></span>
<span id="cb141-17"><a href="#cb141-17"></a>}</span></code></pre></div>
<p>With this change, the compiler now knows about <code>*ast.IfExpression</code> and emits the instructions that represent <code>node.Condition</code>. And even though the consequence and the conditional jump over it are still missing, we get four out of six instructions right:</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb142-1"><a href="#cb142-1"></a>$ go test ./compiler</span>
<span id="cb142-2"><a href="#cb142-2"></a>--- FAIL: TestConditionals (0.00s)</span>
<span id="cb142-3"><a href="#cb142-3"></a> compiler_test.go:195: testInstructions failed: wrong instructions length.</span>
<span id="cb142-4"><a href="#cb142-4"></a>  want=&quot;0000 OpTrue\n0001 OpJumpNotTruthy 7\n0004 OpConstant 0\n0007 OpPop\n\</span>
<span id="cb142-5"><a href="#cb142-5"></a>    0008 OpConstant 1\n0011 OpPop\n&quot;</span>
<span id="cb142-6"><a href="#cb142-6"></a>  got =&quot;0000 OpTrue\n0001 OpPop\n0002 OpConstant 0\n0005 OpPop\n&quot;</span>
<span id="cb142-7"><a href="#cb142-7"></a>FAIL</span>
<span id="cb142-8"><a href="#cb142-8"></a>FAIL    monkey/compiler 0.009s</span></code></pre></div>
<p>The <code>OpTrue</code> instruction is there, as are the last three: the <code>OpPop</code> following the <code>*ast.IfExpression</code>, the <code>OpConstant</code> to load the <code>3333</code> and the <code>OpPop</code> following that, all in the correct order. All that’s left to do now is emit the <code>OpJumpNotTruthy</code> instruction and the instructions to represent the <code>node.Consequence</code>.</p>
<p>With “all that’s left to do now” I, of course, mean: “this is where it gets hairy”. The challenge now is to emit an <code>OpJumpNotTruthy</code> instruction with an offset pointing <em>right after</em> the instructions of the <code>node.Consequence</code> – before compiling the <code>node.Consequence</code>.</p>
<p>Which offset do we use when we don’t even know how far we have to jump yet? The answer is a rather pragmatic “let’s just put garbage in there and fix it later”. You chuckle, but I’m serious. Let’s use a bogus offset and worry about fixing it later:</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb143-1"><a href="#cb143-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb143-2"><a href="#cb143-2"></a></span>
<span id="cb143-3"><a href="#cb143-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb143-4"><a href="#cb143-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb143-5"><a href="#cb143-5"></a>    <span class="co">// [...]</span></span>
<span id="cb143-6"><a href="#cb143-6"></a></span>
<span id="cb143-7"><a href="#cb143-7"></a>    <span class="kw">case</span> *ast.IfExpression:</span>
<span id="cb143-8"><a href="#cb143-8"></a>        err := c.Compile(node.Condition)</span>
<span id="cb143-9"><a href="#cb143-9"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb143-10"><a href="#cb143-10"></a>            <span class="kw">return</span> err</span>
<span id="cb143-11"><a href="#cb143-11"></a>        }</span>
<span id="cb143-12"><a href="#cb143-12"></a></span>
<span id="cb143-13"><a href="#cb143-13"></a>        <span class="co">// Emit an `OpJumpNotTruthy` with a bogus value</span></span>
<span id="cb143-14"><a href="#cb143-14"></a>        c.emit(code.OpJumpNotTruthy, <span class="dv">9999</span>)</span>
<span id="cb143-15"><a href="#cb143-15"></a></span>
<span id="cb143-16"><a href="#cb143-16"></a>        err = c.Compile(node.Consequence)</span>
<span id="cb143-17"><a href="#cb143-17"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb143-18"><a href="#cb143-18"></a>            <span class="kw">return</span> err</span>
<span id="cb143-19"><a href="#cb143-19"></a>        }</span>
<span id="cb143-20"><a href="#cb143-20"></a></span>
<span id="cb143-21"><a href="#cb143-21"></a>    <span class="co">// [...]</span></span>
<span id="cb143-22"><a href="#cb143-22"></a>    }</span>
<span id="cb143-23"><a href="#cb143-23"></a></span>
<span id="cb143-24"><a href="#cb143-24"></a>    <span class="co">// [...]</span></span>
<span id="cb143-25"><a href="#cb143-25"></a>}</span></code></pre></div>
<p>Even though most programmers already squint their eyes and instinctively know that something fishy is going on when they see a <code>9999</code> in code, an inline code comment here helps making the intention clear. Because here we really do want to emit an <code>OpJumpNotTruthy</code> instruction with a garbage offset and then compile the <code>node.Consequence</code>. Again, the <code>9999</code> is not what will end up in the VM and we’ll later take care of it. But for now, it should get us a lot more correct instructions in our test.</p>
<p>But, no, we only get one more right and that’s the <code>OpJumpNotTruthy</code> instruction itself:</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb144-1"><a href="#cb144-1"></a>$ go test ./compiler</span>
<span id="cb144-2"><a href="#cb144-2"></a>--- FAIL: TestConditionals (0.00s)</span>
<span id="cb144-3"><a href="#cb144-3"></a> compiler_test.go:195: testInstructions failed: wrong instructions length.</span>
<span id="cb144-4"><a href="#cb144-4"></a>  want=&quot;0000 OpTrue\n0001 OpJumpNotTruthy 7\n0004 OpConstant 0\n0007 OpPop\n\</span>
<span id="cb144-5"><a href="#cb144-5"></a>    0008 OpConstant 1\n0011 OpPop\n&quot;</span>
<span id="cb144-6"><a href="#cb144-6"></a>  got =&quot;0000 OpTrue\n0001 OpJumpNotTruthy 9999\n0004 OpPop\n\</span>
<span id="cb144-7"><a href="#cb144-7"></a>    0005 OpConstant 0\n0008 OpPop\n&quot;</span>
<span id="cb144-8"><a href="#cb144-8"></a>FAIL</span>
<span id="cb144-9"><a href="#cb144-9"></a>FAIL    monkey/compiler 0.008s</span></code></pre></div>
<p>While we have the <code>OpJumpNotTruthy 9999</code> instruction, we’re apparently not yet compiling the <code>Consequence</code>.</p>
<p>That’s because it’s an <code>*ast.BlockStatement</code>, which our compiler doesn’t know about yet. In order to get it compiled, we need to extend the <code>Compile</code> method by another <code>case</code> branch:</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb145-1"><a href="#cb145-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb145-2"><a href="#cb145-2"></a></span>
<span id="cb145-3"><a href="#cb145-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb145-4"><a href="#cb145-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb145-5"><a href="#cb145-5"></a>    <span class="co">// [...]</span></span>
<span id="cb145-6"><a href="#cb145-6"></a></span>
<span id="cb145-7"><a href="#cb145-7"></a>    <span class="kw">case</span> *ast.BlockStatement:</span>
<span id="cb145-8"><a href="#cb145-8"></a>        <span class="kw">for</span> _, s := <span class="kw">range</span> node.Statements {</span>
<span id="cb145-9"><a href="#cb145-9"></a>            err := c.Compile(s)</span>
<span id="cb145-10"><a href="#cb145-10"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb145-11"><a href="#cb145-11"></a>                <span class="kw">return</span> err</span>
<span id="cb145-12"><a href="#cb145-12"></a>            }</span>
<span id="cb145-13"><a href="#cb145-13"></a>        }</span>
<span id="cb145-14"><a href="#cb145-14"></a></span>
<span id="cb145-15"><a href="#cb145-15"></a>    <span class="co">// [...]</span></span>
<span id="cb145-16"><a href="#cb145-16"></a>    }</span>
<span id="cb145-17"><a href="#cb145-17"></a></span>
<span id="cb145-18"><a href="#cb145-18"></a>    <span class="co">// [...]</span></span>
<span id="cb145-19"><a href="#cb145-19"></a>}</span></code></pre></div>
<p>That’s exactly the same snippet of code we already have in the <code>case</code> branch for <code>*ast.Program</code>. And it works:</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb146-1"><a href="#cb146-1"></a>$ go test ./compiler</span>
<span id="cb146-2"><a href="#cb146-2"></a>--- FAIL: TestConditionals (0.00s)</span>
<span id="cb146-3"><a href="#cb146-3"></a> compiler_test.go:195: testInstructions failed: wrong instructions length.</span>
<span id="cb146-4"><a href="#cb146-4"></a>  want=&quot;0000 OpTrue\n0001 OpJumpNotTruthy 7\n0004 OpConstant 0\n\</span>
<span id="cb146-5"><a href="#cb146-5"></a>    0007 OpPop\n0008 OpConstant 1\n0011 OpPop\n&quot;</span>
<span id="cb146-6"><a href="#cb146-6"></a>  got =&quot;0000 OpTrue\n0001 OpJumpNotTruthy 9999\n0004 OpConstant 0\n\</span>
<span id="cb146-7"><a href="#cb146-7"></a>    0007 OpPop\n0008 OpPop\n0009 OpConstant 1\n0012 OpPop\n&quot;</span>
<span id="cb146-8"><a href="#cb146-8"></a>FAIL</span>
<span id="cb146-9"><a href="#cb146-9"></a>FAIL    monkey/compiler 0.010s</span></code></pre></div>
<p>We’re getting closer. But, besides the bogus <code>9999</code> offset, which we didn’t expect to magically disappear, there’s a new issue visible in the output, a far more subtle one. It’s possible that you missed it, so let me point you to it: there is an additional <code>OpPop</code> instruction generated by the compiler, at position <code>0007</code>. Its origin is the compilation of <code>node.Consequence</code> – an expression statement.</p>
<p>We need to get rid of this <code>OpPop</code>, because we do want the consequence and the alternative of a conditional to leave a value on the stack. Otherwise, we couldn’t do this:</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb147-1"><a href="#cb147-1"></a><span class="kw">let</span> result <span class="op">=</span> <span class="cf">if</span> (<span class="dv">5</span> <span class="op">&gt;</span> <span class="dv">3</span>) { <span class="dv">5</span> } <span class="cf">else</span> { <span class="dv">3</span> }<span class="op">;</span></span></code></pre></div>
<p>That’s valid Monkey code and it won’t work if we emit an <code>OpPop</code> after the last expression statement in the <code>node.Consequence</code>. The value produced by the consequence would be popped off the stack, the expression wouldn’t evaluate to anything, and the let statement would end up without a value on the right side of its <code>=</code>.</p>
<p>What makes fixing this tricky is that we only want to get rid of the <em>last</em> <code>OpPop</code> instruction in the <code>node.Consequence</code>. Say we had Monkey code like this:</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb148-1"><a href="#cb148-1"></a><span class="cf">if</span> (<span class="kw">true</span>) {</span>
<span id="cb148-2"><a href="#cb148-2"></a>  <span class="dv">3</span><span class="op">;</span></span>
<span id="cb148-3"><a href="#cb148-3"></a>  <span class="dv">2</span><span class="op">;</span></span>
<span id="cb148-4"><a href="#cb148-4"></a>  <span class="dv">1</span><span class="op">;</span></span>
<span id="cb148-5"><a href="#cb148-5"></a>}</span></code></pre></div>
<p>What we want here is the <code>3</code> and the <code>2</code> to be popped off the stack, but the <code>1</code> should be kept around so the whole conditional evaluates to <code>1</code>. So before we tackle our main challenge of giving the <code>OpJumpNotTruthy</code> a <em>real</em> offset, here’s the plan for getting rid of the additional <code>OpPop</code> instruction.</p>
<p>We first change the compiler to keep track of the last two instructions we emitted, including their opcode and the position they were emitted to. For that, we need a new type and two more fields on the compiler:</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb149-1"><a href="#cb149-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb149-2"><a href="#cb149-2"></a></span>
<span id="cb149-3"><a href="#cb149-3"></a><span class="kw">type</span> EmittedInstruction <span class="kw">struct</span> {</span>
<span id="cb149-4"><a href="#cb149-4"></a>    Opcode   code.Opcode</span>
<span id="cb149-5"><a href="#cb149-5"></a>    Position <span class="dt">int</span></span>
<span id="cb149-6"><a href="#cb149-6"></a>}</span>
<span id="cb149-7"><a href="#cb149-7"></a></span>
<span id="cb149-8"><a href="#cb149-8"></a><span class="kw">type</span> Compiler <span class="kw">struct</span> {</span>
<span id="cb149-9"><a href="#cb149-9"></a>    <span class="co">// [...]</span></span>
<span id="cb149-10"><a href="#cb149-10"></a></span>
<span id="cb149-11"><a href="#cb149-11"></a>    lastInstruction     EmittedInstruction</span>
<span id="cb149-12"><a href="#cb149-12"></a>    previousInstruction EmittedInstruction</span>
<span id="cb149-13"><a href="#cb149-13"></a>}</span>
<span id="cb149-14"><a href="#cb149-14"></a></span>
<span id="cb149-15"><a href="#cb149-15"></a><span class="kw">func</span> New() *Compiler {</span>
<span id="cb149-16"><a href="#cb149-16"></a>    <span class="kw">return</span> &amp;Compiler{</span>
<span id="cb149-17"><a href="#cb149-17"></a>        <span class="co">// [...]</span></span>
<span id="cb149-18"><a href="#cb149-18"></a>        lastInstruction:     EmittedInstruction{},</span>
<span id="cb149-19"><a href="#cb149-19"></a>        previousInstruction: EmittedInstruction{},</span>
<span id="cb149-20"><a href="#cb149-20"></a>    }</span>
<span id="cb149-21"><a href="#cb149-21"></a>}</span></code></pre></div>
<p><code>lastInstruction</code> is the very last instruction we emitted and <code>previousInstruction</code> is the one before that. We’ll see why we need to keep track of both in a moment. For now, we change the compiler’s <code>emit</code> method to populate both fields:</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb150-1"><a href="#cb150-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb150-2"><a href="#cb150-2"></a></span>
<span id="cb150-3"><a href="#cb150-3"></a><span class="kw">func</span> (c *Compiler) emit(op code.Opcode, operands ...<span class="dt">int</span>) <span class="dt">int</span> {</span>
<span id="cb150-4"><a href="#cb150-4"></a>    ins := code.Make(op, operands...)</span>
<span id="cb150-5"><a href="#cb150-5"></a>    pos := c.addInstruction(ins)</span>
<span id="cb150-6"><a href="#cb150-6"></a></span>
<span id="cb150-7"><a href="#cb150-7"></a>    c.setLastInstruction(op, pos)</span>
<span id="cb150-8"><a href="#cb150-8"></a></span>
<span id="cb150-9"><a href="#cb150-9"></a>    <span class="kw">return</span> pos</span>
<span id="cb150-10"><a href="#cb150-10"></a>}</span>
<span id="cb150-11"><a href="#cb150-11"></a></span>
<span id="cb150-12"><a href="#cb150-12"></a><span class="kw">func</span> (c *Compiler) setLastInstruction(op code.Opcode, pos <span class="dt">int</span>) {</span>
<span id="cb150-13"><a href="#cb150-13"></a>    previous := c.lastInstruction</span>
<span id="cb150-14"><a href="#cb150-14"></a>    last := EmittedInstruction{Opcode: op, Position: pos}</span>
<span id="cb150-15"><a href="#cb150-15"></a></span>
<span id="cb150-16"><a href="#cb150-16"></a>    c.previousInstruction = previous</span>
<span id="cb150-17"><a href="#cb150-17"></a>    c.lastInstruction = last</span>
<span id="cb150-18"><a href="#cb150-18"></a>}</span></code></pre></div>
<p>With this in place, we can check opcode of the last emitted instruction in a type-safe way, without having to cast from and to bytes. And that’s exactly what we’re going to do. After compiling the <code>node.Consequence</code> of the <code>*ast.IfExpression</code> we check whether the last instruction we emitted was an <code>OpPop</code> instruction and if so, we remove it:</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb151-1"><a href="#cb151-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb151-2"><a href="#cb151-2"></a></span>
<span id="cb151-3"><a href="#cb151-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb151-4"><a href="#cb151-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb151-5"><a href="#cb151-5"></a>    <span class="co">// [...]</span></span>
<span id="cb151-6"><a href="#cb151-6"></a></span>
<span id="cb151-7"><a href="#cb151-7"></a>    <span class="kw">case</span> *ast.IfExpression:</span>
<span id="cb151-8"><a href="#cb151-8"></a>        <span class="co">// [...]</span></span>
<span id="cb151-9"><a href="#cb151-9"></a>        c.emit(code.OpJumpNotTruthy, <span class="dv">9999</span>)</span>
<span id="cb151-10"><a href="#cb151-10"></a></span>
<span id="cb151-11"><a href="#cb151-11"></a>        err = c.Compile(node.Consequence)</span>
<span id="cb151-12"><a href="#cb151-12"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb151-13"><a href="#cb151-13"></a>            <span class="kw">return</span> err</span>
<span id="cb151-14"><a href="#cb151-14"></a>        }</span>
<span id="cb151-15"><a href="#cb151-15"></a></span>
<span id="cb151-16"><a href="#cb151-16"></a>        <span class="kw">if</span> c.lastInstructionIsPop() {</span>
<span id="cb151-17"><a href="#cb151-17"></a>            c.removeLastPop()</span>
<span id="cb151-18"><a href="#cb151-18"></a>        }</span>
<span id="cb151-19"><a href="#cb151-19"></a></span>
<span id="cb151-20"><a href="#cb151-20"></a>    <span class="co">// [...]</span></span>
<span id="cb151-21"><a href="#cb151-21"></a>    }</span>
<span id="cb151-22"><a href="#cb151-22"></a></span>
<span id="cb151-23"><a href="#cb151-23"></a>    <span class="co">// [...]</span></span>
<span id="cb151-24"><a href="#cb151-24"></a>}</span></code></pre></div>
<p>This uses two helpers, <code>lastInstructionIsPop</code> The two helpers involved are tiny:</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb152-1"><a href="#cb152-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb152-2"><a href="#cb152-2"></a></span>
<span id="cb152-3"><a href="#cb152-3"></a><span class="kw">func</span> (c *Compiler) lastInstructionIsPop() <span class="dt">bool</span> {</span>
<span id="cb152-4"><a href="#cb152-4"></a>    <span class="kw">return</span> c.lastInstruction.Opcode == code.OpPop</span>
<span id="cb152-5"><a href="#cb152-5"></a>}</span>
<span id="cb152-6"><a href="#cb152-6"></a></span>
<span id="cb152-7"><a href="#cb152-7"></a><span class="kw">func</span> (c *Compiler) removeLastPop() {</span>
<span id="cb152-8"><a href="#cb152-8"></a>    c.instructions = c.instructions[:c.lastInstruction.Position]</span>
<span id="cb152-9"><a href="#cb152-9"></a>    c.lastInstruction = c.previousInstruction</span>
<span id="cb152-10"><a href="#cb152-10"></a>}</span></code></pre></div>
<p><code>lastInstructionIsPop</code> checks whether the opcode of the last instruction is <code>OpPop</code> and <code>removeLastPop</code> shortens <code>c.instruction</code> to cut off the last instruction. After that, it sets <code>c.lastInstruction</code> to <code>c.previousInstruction</code>. And that’s why we need to keep track of both of them, so <code>c.lastInstruction</code> doesn’t go out of sync once we cut off the last <code>OpPop</code> instruction.</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb153-1"><a href="#cb153-1"></a>$ go test ./compiler</span>
<span id="cb153-2"><a href="#cb153-2"></a>--- FAIL: TestConditionals (0.00s)</span>
<span id="cb153-3"><a href="#cb153-3"></a> compiler_test.go:195: testInstructions failed: wrong instruction at 2.</span>
<span id="cb153-4"><a href="#cb153-4"></a>  want=&quot;0000 OpTrue\n0001 OpJumpNotTruthy 7\n0004 OpConstant 0\n\</span>
<span id="cb153-5"><a href="#cb153-5"></a>    0007 OpPop\n 0008 OpConstant 1\n0011 OpPop\n&quot;</span>
<span id="cb153-6"><a href="#cb153-6"></a>  got =&quot;0000 OpTrue\n0001 OpJumpNotTruthy 9999\n0004 OpConstant 0\n\</span>
<span id="cb153-7"><a href="#cb153-7"></a>    0007 OpPop\n 0008 OpConstant 1\n0011 OpPop\n&quot;</span>
<span id="cb153-8"><a href="#cb153-8"></a>FAIL</span>
<span id="cb153-9"><a href="#cb153-9"></a>FAIL    monkey/compiler 0.008s</span></code></pre></div>
<p>Now we have the correct number of instructions and the right opcodes. The only thing that still makes our test fail is the hideous <code>9999</code>. Time to get rid of it.</p>
<p>The way we took care of the superfluous <code>OpPop</code> instruction points us into the right direction by making one thing clear: the instructions we emit are not set in stone, we can <em>change</em> them.</p>
<p>Instead of removing our <code>c.emit(code.OpJumpNotTruthy, 9999)</code> call, we’ll leave it exactly as it is. We won’t even change the <code>9999</code>. Instead, we’ll use <code>Position</code> field of the <code>c.lastInstruction</code> again. That allows us to go back to the <code>OpJumpNotTruthy</code> instruction we emitted and change the <code>9999</code> into the real operand. And when do we do that? That’s the kicker, the beautiful bit. We’ll modify the operand of the <code>OpJumpNotTruthy</code> <em>after</em> we compiled the <code>node.Consequence</code>. At that point, we’ll know how far the VM has to jump and have the correct offset with which to replace the <code>9999</code>.</p>
<p>This is called back-patching and common in compiler’s such as ours, that only traverse the AST once and are thus called single-pass compilers. More advanced compilers might leave the target of the jump instructions empty until they know how far to jump and then do a second pass over the AST (or another IR) and fill in the targets.</p>
<p>Summarized: we’ll keep on emitting the <code>9999</code>, while remembering where we put it. Once we know where we need to jump to, we’ll go back to the <code>9999</code> and change it to the correct offset. You’ll be surprised by how little code is needed to pull that off.</p>
<p>The first thing we need is a tiny method to replace an instruction at an arbitrary offset in the <code>instructions</code> slice:</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb154-1"><a href="#cb154-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb154-2"><a href="#cb154-2"></a></span>
<span id="cb154-3"><a href="#cb154-3"></a><span class="kw">func</span> (c *Compiler) replaceInstruction(pos <span class="dt">int</span>, newInstruction []<span class="dt">byte</span>) {</span>
<span id="cb154-4"><a href="#cb154-4"></a>    <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="bu">len</span>(newInstruction); i++ {</span>
<span id="cb154-5"><a href="#cb154-5"></a>        c.instructions[pos+i] = newInstruction[i]</span>
<span id="cb154-6"><a href="#cb154-6"></a>    }</span>
<span id="cb154-7"><a href="#cb154-7"></a>}</span></code></pre></div>
<p>We’ll use <code>replaceInstruction</code> in another method that allows us to replace the operand of an instruction:</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb155-1"><a href="#cb155-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb155-2"><a href="#cb155-2"></a></span>
<span id="cb155-3"><a href="#cb155-3"></a><span class="kw">func</span> (c *Compiler) changeOperand(opPos <span class="dt">int</span>, operand <span class="dt">int</span>) {</span>
<span id="cb155-4"><a href="#cb155-4"></a>    op := code.Opcode(c.instructions[opPos])</span>
<span id="cb155-5"><a href="#cb155-5"></a>    newInstruction := code.Make(op, operand)</span>
<span id="cb155-6"><a href="#cb155-6"></a></span>
<span id="cb155-7"><a href="#cb155-7"></a>    c.replaceInstruction(opPos, newInstruction)</span>
<span id="cb155-8"><a href="#cb155-8"></a>}</span></code></pre></div>
<p>Instead of really changing the operand itself (which can get messy with multi-byte operands), the <code>changeOperand</code> method recreates the instructions with the new operand and uses <code>replaceInstruction</code> to swap the old instruction for the new one – including the operand.</p>
<p>The underlying assumption here is that we only replace instructions of the same type, with the same non-variable length. If that assumption no longer holds, we’d have to tread far more carefully here and update <code>c.lastInstruction</code> and <code>c.previousInstruction</code> accordingly. You can see how another IR that’s type-safe and independent of the byte-size of encoded instructions comes in handy once the compiler and the instructions it emits grow more complex.</p>
<p>Our solution, though, still fits our needs and all in all is not a lot of code. Two tiny methods, <code>replaceInstruction</code> and <code>changeOperand</code>, and all that’s left to do is to use them, which is not much more code either:</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb156-1"><a href="#cb156-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb156-2"><a href="#cb156-2"></a></span>
<span id="cb156-3"><a href="#cb156-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb156-4"><a href="#cb156-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb156-5"><a href="#cb156-5"></a>    <span class="co">// [...]</span></span>
<span id="cb156-6"><a href="#cb156-6"></a></span>
<span id="cb156-7"><a href="#cb156-7"></a>    <span class="kw">case</span> *ast.IfExpression:</span>
<span id="cb156-8"><a href="#cb156-8"></a>        err := c.Compile(node.Condition)</span>
<span id="cb156-9"><a href="#cb156-9"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb156-10"><a href="#cb156-10"></a>            <span class="kw">return</span> err</span>
<span id="cb156-11"><a href="#cb156-11"></a>        }</span>
<span id="cb156-12"><a href="#cb156-12"></a></span>
<span id="cb156-13"><a href="#cb156-13"></a>        <span class="co">// Emit an `OpJumpNotTruthy` with a bogus value</span></span>
<span id="cb156-14"><a href="#cb156-14"></a>        jumpNotTruthyPos := c.emit(code.OpJumpNotTruthy, <span class="dv">9999</span>)</span>
<span id="cb156-15"><a href="#cb156-15"></a></span>
<span id="cb156-16"><a href="#cb156-16"></a>        err = c.Compile(node.Consequence)</span>
<span id="cb156-17"><a href="#cb156-17"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb156-18"><a href="#cb156-18"></a>            <span class="kw">return</span> err</span>
<span id="cb156-19"><a href="#cb156-19"></a>        }</span>
<span id="cb156-20"><a href="#cb156-20"></a></span>
<span id="cb156-21"><a href="#cb156-21"></a>        <span class="kw">if</span> c.lastInstructionIsPop() {</span>
<span id="cb156-22"><a href="#cb156-22"></a>            c.removeLastPop()</span>
<span id="cb156-23"><a href="#cb156-23"></a>        }</span>
<span id="cb156-24"><a href="#cb156-24"></a></span>
<span id="cb156-25"><a href="#cb156-25"></a>        afterConsequencePos := <span class="bu">len</span>(c.instructions)</span>
<span id="cb156-26"><a href="#cb156-26"></a>        c.changeOperand(jumpNotTruthyPos, afterConsequencePos)</span>
<span id="cb156-27"><a href="#cb156-27"></a></span>
<span id="cb156-28"><a href="#cb156-28"></a>    <span class="co">// [...]</span></span>
<span id="cb156-29"><a href="#cb156-29"></a>    }</span>
<span id="cb156-30"><a href="#cb156-30"></a></span>
<span id="cb156-31"><a href="#cb156-31"></a>    <span class="co">// [...]</span></span>
<span id="cb156-32"><a href="#cb156-32"></a>}</span></code></pre></div>
<p>The first change is saving the return value of <code>c.emit</code> to <code>jumpNotTruthyPos</code>. That’s the position at which we can find the <code>OpJumpNotTruthy</code> instruction later on. “Later on” means right after the check for and possible removal of a <code>OpPop</code> instruction. After that, <code>len(c.instructions)</code> gives us the offset of the next-to-be-emitted instruction, which is where we want to jump to in case we don’t execute the <code>Consequence</code> of the conditional because the value on top of the stack is not truthy. That’s why we save it to <code>afterConsequencePos</code>, to give it a telling name.</p>
<p>After that, we use the new <code>changeOperand</code> method to get rid of the <code>9999</code> operand of the <code>OpJumpNotTruthy</code> instruction, which is located at <code>jumpNotTruthyPos</code>, and replace it with the correct <code>afterConsequencePos</code>.</p>
<p>Did you keep count? If not, I want you to know that the necessary changes add up to three lines. One changed, two added. That’s all:</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb157-1"><a href="#cb157-1"></a>$ go test ./compiler</span>
<span id="cb157-2"><a href="#cb157-2"></a>ok      monkey/compiler 0.008s</span></code></pre></div>
<p>Our compiler now correctly compiles a conditional! The caveat is that it only knows how to compile the <em>consequence</em>. It doesn’t know how to compile a conditional with both a consequence <em>and</em> an alternative else-branch.</p>
<p>But we do and we also know how to write tests:</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb158-1"><a href="#cb158-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb158-2"><a href="#cb158-2"></a></span>
<span id="cb158-3"><a href="#cb158-3"></a><span class="kw">func</span> TestConditionals(t *testing.T) {</span>
<span id="cb158-4"><a href="#cb158-4"></a>    tests := []compilerTestCase{</span>
<span id="cb158-5"><a href="#cb158-5"></a>        <span class="co">// [...]</span></span>
<span id="cb158-6"><a href="#cb158-6"></a>        {</span>
<span id="cb158-7"><a href="#cb158-7"></a>            input: <span class="st">`</span></span>
<span id="cb158-8"><a href="#cb158-8"></a><span class="st">            if (true) { 10 } else { 20 }; 3333;</span></span>
<span id="cb158-9"><a href="#cb158-9"></a><span class="st">            `</span>,</span>
<span id="cb158-10"><a href="#cb158-10"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">3333</span>},</span>
<span id="cb158-11"><a href="#cb158-11"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb158-12"><a href="#cb158-12"></a>                <span class="co">// 0000</span></span>
<span id="cb158-13"><a href="#cb158-13"></a>                code.Make(code.OpTrue),</span>
<span id="cb158-14"><a href="#cb158-14"></a>                <span class="co">// 0001</span></span>
<span id="cb158-15"><a href="#cb158-15"></a>                code.Make(code.OpJumpNotTruthy, <span class="dv">10</span>),</span>
<span id="cb158-16"><a href="#cb158-16"></a>                <span class="co">// 0004</span></span>
<span id="cb158-17"><a href="#cb158-17"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb158-18"><a href="#cb158-18"></a>                <span class="co">// 0007</span></span>
<span id="cb158-19"><a href="#cb158-19"></a>                code.Make(code.OpJump, <span class="dv">13</span>),</span>
<span id="cb158-20"><a href="#cb158-20"></a>                <span class="co">// 0010</span></span>
<span id="cb158-21"><a href="#cb158-21"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb158-22"><a href="#cb158-22"></a>                <span class="co">// 0013</span></span>
<span id="cb158-23"><a href="#cb158-23"></a>                code.Make(code.OpPop),</span>
<span id="cb158-24"><a href="#cb158-24"></a>                <span class="co">// 0014</span></span>
<span id="cb158-25"><a href="#cb158-25"></a>                code.Make(code.OpConstant, <span class="dv">2</span>),</span>
<span id="cb158-26"><a href="#cb158-26"></a>                <span class="co">// 0017</span></span>
<span id="cb158-27"><a href="#cb158-27"></a>                code.Make(code.OpPop),</span>
<span id="cb158-28"><a href="#cb158-28"></a>            },</span>
<span id="cb158-29"><a href="#cb158-29"></a>        },</span>
<span id="cb158-30"><a href="#cb158-30"></a>    }</span>
<span id="cb158-31"><a href="#cb158-31"></a></span>
<span id="cb158-32"><a href="#cb158-32"></a>    runCompilerTests(t, tests)</span>
<span id="cb158-33"><a href="#cb158-33"></a>}</span></code></pre></div>
<p>This is similar to the previous test case in <code>TestConditionals</code>, except that the <code>input</code> now contains not only the consequence of the conditional, but also the alternative: <code>else { 20 }</code>.</p>
<p>The <code>expectedInstructions</code> make clear what we want the bytecode to look like, with the first part being the same as in the previous test case: the condition is compiled to <code>OpTrue</code> and is followed by the <code>OpJumpNotTruthy</code> instruction that instructs the VM to <em>jump over</em> the compiled consequence.</p>
<p>Then, things start to differ. As the next opcode, we expect an <code>OpJump</code>, the opcode for an unconditional jump instruction. It has to be there because if condition is truthy the VM should only execute the consequence and <em>not</em> the alternative. To stop that from happening the <code>OpJump</code> instruction tells the VM to jump over the alternative.</p>
<p>The <code>OpJump</code> should then be followed by instructions that make up the alternative. In our test case, that’s the <code>OpConstant</code> instruction that loads <code>20</code> on to the stack.</p>
<p>Then we’re back on familiar ground. An <code>OpPop</code> is there to pop the value produced by the conditional off the stack and the loading of the bogus <code>3333</code> gives us guidance.</p>
<p>I know that it’s not easy to wrap ones head around these jumps, so I hope that this illustration makes it clearer which instruction belongs to which part of the conditional and how the jumps tie them all together:</p>
<!-- ./ascii_drawings/04/two_branch_conditional_explained.monopic -->
<figure>
<img src="./images/04/two_branch_conditional_explained.svg" style="width:70.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>If that doesn’t help, I’m sure trying to run and fixing the failing test will, because its output tells us what we’re still missing:</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb159-1"><a href="#cb159-1"></a>$ go test ./compiler</span>
<span id="cb159-2"><a href="#cb159-2"></a>--- FAIL: TestConditionals (0.00s)</span>
<span id="cb159-3"><a href="#cb159-3"></a> compiler_test.go:220: testInstructions failed: wrong instructions length.</span>
<span id="cb159-4"><a href="#cb159-4"></a>  want=&quot;0000 OpTrue\n0001 OpJumpNotTruthy 10\n0004 OpConstant 0\n\</span>
<span id="cb159-5"><a href="#cb159-5"></a>    0007 OpJump 13\n0010 OpConstant 1\n\</span>
<span id="cb159-6"><a href="#cb159-6"></a>    0013 OpPop\n0014 OpConstant 2\n0017 OpPop\n&quot;</span>
<span id="cb159-7"><a href="#cb159-7"></a>  got =&quot;0000 OpTrue\n0001 OpJumpNotTruthy 7\n0004 OpConstant 0\n\</span>
<span id="cb159-8"><a href="#cb159-8"></a>    0007 OpPop\n0008 OpConstant 1\n0011 OpPop\n&quot;</span>
<span id="cb159-9"><a href="#cb159-9"></a>FAIL</span>
<span id="cb159-10"><a href="#cb159-10"></a>FAIL    monkey/compiler 0.007s</span></code></pre></div>
<p>What we have here is the condition, then the <code>OpPop</code> following the whole conditional and the pushing and popping of the <code>3333</code>. What’s missing is the <code>OpJump</code> at the end of the consequence and the instructions representing the alternative. The good news is that we already have all the tools at hand. We just need to move things around a tiny bit and compile the alternative.</p>
<p>The first step, though, is to wrap our patching of the <code>OpJumpNotTruthy</code> instruction in a condition itself:</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb160-1"><a href="#cb160-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb160-2"><a href="#cb160-2"></a></span>
<span id="cb160-3"><a href="#cb160-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb160-4"><a href="#cb160-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb160-5"><a href="#cb160-5"></a>    <span class="co">// [...]</span></span>
<span id="cb160-6"><a href="#cb160-6"></a></span>
<span id="cb160-7"><a href="#cb160-7"></a>    <span class="kw">case</span> *ast.IfExpression:</span>
<span id="cb160-8"><a href="#cb160-8"></a>        <span class="co">// [...]</span></span>
<span id="cb160-9"><a href="#cb160-9"></a></span>
<span id="cb160-10"><a href="#cb160-10"></a>        <span class="kw">if</span> node.Alternative == <span class="ot">nil</span> {</span>
<span id="cb160-11"><a href="#cb160-11"></a>            afterConsequencePos := <span class="bu">len</span>(c.instructions)</span>
<span id="cb160-12"><a href="#cb160-12"></a>            c.changeOperand(jumpNotTruthyPos, afterConsequencePos)</span>
<span id="cb160-13"><a href="#cb160-13"></a>        }</span>
<span id="cb160-14"><a href="#cb160-14"></a></span>
<span id="cb160-15"><a href="#cb160-15"></a>    <span class="co">// [...]</span></span>
<span id="cb160-16"><a href="#cb160-16"></a>    }</span>
<span id="cb160-17"><a href="#cb160-17"></a></span>
<span id="cb160-18"><a href="#cb160-18"></a>    <span class="co">// [...]</span></span>
<span id="cb160-19"><a href="#cb160-19"></a>}</span></code></pre></div>
<p>Preceding this <code>node.Alternative == nil</code> check is the compilation of <code>node.Consequence</code> and what this added block translates to is this: only if we have no <code>node.Alternative</code> can we jump to <em>here</em>, the current position in <code>c.instructions</code>.</p>
<p>But if we do have an <code>node.Alternative</code> we need to emit an <code>OpJump</code> that becomes part of the consequence and over which the <code>OpJumpNotTruthy</code> also has to jump:</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb161-1"><a href="#cb161-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb161-2"><a href="#cb161-2"></a></span>
<span id="cb161-3"><a href="#cb161-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb161-4"><a href="#cb161-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb161-5"><a href="#cb161-5"></a>    <span class="co">// [...]</span></span>
<span id="cb161-6"><a href="#cb161-6"></a></span>
<span id="cb161-7"><a href="#cb161-7"></a>    <span class="kw">case</span> *ast.IfExpression:</span>
<span id="cb161-8"><a href="#cb161-8"></a>        <span class="co">// [...]</span></span>
<span id="cb161-9"><a href="#cb161-9"></a></span>
<span id="cb161-10"><a href="#cb161-10"></a>        <span class="kw">if</span> node.Alternative == <span class="ot">nil</span> {</span>
<span id="cb161-11"><a href="#cb161-11"></a>            afterConsequencePos := <span class="bu">len</span>(c.instructions)</span>
<span id="cb161-12"><a href="#cb161-12"></a>            c.changeOperand(jumpNotTruthyPos, afterConsequencePos)</span>
<span id="cb161-13"><a href="#cb161-13"></a>        } <span class="kw">else</span> {</span>
<span id="cb161-14"><a href="#cb161-14"></a>            <span class="co">// Emit an `OpJump` with a bogus value</span></span>
<span id="cb161-15"><a href="#cb161-15"></a>            c.emit(code.OpJump, <span class="dv">9999</span>)</span>
<span id="cb161-16"><a href="#cb161-16"></a></span>
<span id="cb161-17"><a href="#cb161-17"></a>            afterConsequencePos := <span class="bu">len</span>(c.instructions)</span>
<span id="cb161-18"><a href="#cb161-18"></a>            c.changeOperand(jumpNotTruthyPos, afterConsequencePos)</span>
<span id="cb161-19"><a href="#cb161-19"></a>        }</span>
<span id="cb161-20"><a href="#cb161-20"></a></span>
<span id="cb161-21"><a href="#cb161-21"></a>    <span class="co">// [...]</span></span>
<span id="cb161-22"><a href="#cb161-22"></a>    }</span>
<span id="cb161-23"><a href="#cb161-23"></a></span>
<span id="cb161-24"><a href="#cb161-24"></a>    <span class="co">// [...]</span></span>
<span id="cb161-25"><a href="#cb161-25"></a>}</span></code></pre></div>
<p>Don’t worry about the duplication, we’ll take care of that later on. What’s important right now is to make the intention as clear as possible.</p>
<p>The <code>OpJump</code> instruction also has a placeholder operand. That means we have to patch it later, but right now it allows us to change the operand of the <code>OpJumpNotTruthy</code> instruction to the desired value: the position of the instruction right after the consequence <em>and</em> the <code>OpJump</code> instruction.</p>
<p>And why that is the correct operand should be clear by now: the <code>OpJump</code> should skip over the “else”-branch of the conditional in case the condition was truthy. It’s part of the consequence, so to say. And if the condition is not truthy and we need to execute the “else”-branch, we need to use <code>OpJumpNotTruthy</code> to jump <em>after</em> the consequence, which is after the <code>OpJump</code>.</p>
<p>The tests tell us that we’re on the right track:</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb162-1"><a href="#cb162-1"></a>$ go test ./compiler</span>
<span id="cb162-2"><a href="#cb162-2"></a>--- FAIL: TestConditionals (0.00s)</span>
<span id="cb162-3"><a href="#cb162-3"></a> compiler_test.go:220: testInstructions failed: wrong instructions length.</span>
<span id="cb162-4"><a href="#cb162-4"></a>  want=&quot;0000 OpTrue\n0001 OpJumpNotTruthy 10\n0004 OpConstant 0\n\</span>
<span id="cb162-5"><a href="#cb162-5"></a>    0007 OpJump 13\n0010 OpConstant 1\n\</span>
<span id="cb162-6"><a href="#cb162-6"></a>    0013 OpPop\n0014 OpConstant 2\n0017 OpPop\n&quot;</span>
<span id="cb162-7"><a href="#cb162-7"></a>  got =&quot;0000 OpTrue\n0001 OpJumpNotTruthy 10\n0004 OpConstant 0\n\</span>
<span id="cb162-8"><a href="#cb162-8"></a>    0007 OpJump 9999\n\</span>
<span id="cb162-9"><a href="#cb162-9"></a>    0010 OpPop\n0011 OpConstant 1\n0014 OpPop\n&quot;</span>
<span id="cb162-10"><a href="#cb162-10"></a>FAIL</span>
<span id="cb162-11"><a href="#cb162-11"></a>FAIL    monkey/compiler 0.008s</span></code></pre></div>
<p>The operand of <code>OpJumpNotTruthy</code> is correct, <code>OpJump</code> is in the correct place, only its operand is wrong and the whole alternative is missing. We now have to repeat what we previously did for the consequence:</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb163-1"><a href="#cb163-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb163-2"><a href="#cb163-2"></a></span>
<span id="cb163-3"><a href="#cb163-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb163-4"><a href="#cb163-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb163-5"><a href="#cb163-5"></a>    <span class="co">// [...]</span></span>
<span id="cb163-6"><a href="#cb163-6"></a></span>
<span id="cb163-7"><a href="#cb163-7"></a>    <span class="kw">case</span> *ast.IfExpression:</span>
<span id="cb163-8"><a href="#cb163-8"></a>        <span class="co">// [...]</span></span>
<span id="cb163-9"><a href="#cb163-9"></a></span>
<span id="cb163-10"><a href="#cb163-10"></a>        <span class="kw">if</span> node.Alternative == <span class="ot">nil</span> {</span>
<span id="cb163-11"><a href="#cb163-11"></a>            afterConsequencePos := <span class="bu">len</span>(c.instructions)</span>
<span id="cb163-12"><a href="#cb163-12"></a>            c.changeOperand(jumpNotTruthyPos, afterConsequencePos)</span>
<span id="cb163-13"><a href="#cb163-13"></a>        } <span class="kw">else</span> {</span>
<span id="cb163-14"><a href="#cb163-14"></a>            <span class="co">// Emit an `OpJump` with a bogus value</span></span>
<span id="cb163-15"><a href="#cb163-15"></a>            jumpPos := c.emit(code.OpJump, <span class="dv">9999</span>)</span>
<span id="cb163-16"><a href="#cb163-16"></a></span>
<span id="cb163-17"><a href="#cb163-17"></a>            afterConsequencePos := <span class="bu">len</span>(c.instructions)</span>
<span id="cb163-18"><a href="#cb163-18"></a>            c.changeOperand(jumpNotTruthyPos, afterConsequencePos)</span>
<span id="cb163-19"><a href="#cb163-19"></a></span>
<span id="cb163-20"><a href="#cb163-20"></a>            err := c.Compile(node.Alternative)</span>
<span id="cb163-21"><a href="#cb163-21"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb163-22"><a href="#cb163-22"></a>                <span class="kw">return</span> err</span>
<span id="cb163-23"><a href="#cb163-23"></a>            }</span>
<span id="cb163-24"><a href="#cb163-24"></a></span>
<span id="cb163-25"><a href="#cb163-25"></a>            <span class="kw">if</span> c.lastInstructionIsPop() {</span>
<span id="cb163-26"><a href="#cb163-26"></a>                c.removeLastPop()</span>
<span id="cb163-27"><a href="#cb163-27"></a>            }</span>
<span id="cb163-28"><a href="#cb163-28"></a></span>
<span id="cb163-29"><a href="#cb163-29"></a>            afterAlternativePos := <span class="bu">len</span>(c.instructions)</span>
<span id="cb163-30"><a href="#cb163-30"></a>            c.changeOperand(jumpPos, afterAlternativePos)</span>
<span id="cb163-31"><a href="#cb163-31"></a>        }</span>
<span id="cb163-32"><a href="#cb163-32"></a></span>
<span id="cb163-33"><a href="#cb163-33"></a>    <span class="co">// [...]</span></span>
<span id="cb163-34"><a href="#cb163-34"></a>    }</span>
<span id="cb163-35"><a href="#cb163-35"></a></span>
<span id="cb163-36"><a href="#cb163-36"></a>    <span class="co">// [...]</span></span>
<span id="cb163-37"><a href="#cb163-37"></a>}</span></code></pre></div>
<p>We first save the position of the <code>OpJump</code> instruction to <code>jumpPos</code> so that we can later come back and change its operand. Then we patch the operand of the previously emitted <code>OpJumpNotTruthy</code> instruction, located at <code>jumpNotTruthyPos</code>, making it jump <em>right after</em> the just emitted <code>OpJump</code>.</p>
<p>After that, we compile <code>node.Alternative</code>. Here, too, we have to <code>c.removeLastPop()</code> if there is one. Finally, we change the operand of the <code>OpJump</code> instruction to the offset of the next-to-be-emitted instruction, which will be located right after the alternative.</p>
<p>Or, in the words of our test suite:</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb164-1"><a href="#cb164-1"></a>$ go test ./compiler</span>
<span id="cb164-2"><a href="#cb164-2"></a>ok      monkey/compiler 0.009s</span></code></pre></div>
<p>Again, take the <code>ok</code> with a grain of salt. It should say: “Yes! Yes! Yes! We’re compiling conditionals to jump instructions!”</p>
<p>We’re over the hump now. It is time to teach our VM how to execute jumps, and that’s far easier than emitting them.</p>
<h2 id="executing-jumps">Executing Jumps</h2>
<p>Before we wrote the compiler tests for conditionals, we really had to think through what we want them to say and what we want the compiler to do. That’s not the case now, when writing the same tests for the VM. We already know how conditionals in Monkey are supposed to work and can cleanly express that in test cases and assertions:</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb165-1"><a href="#cb165-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb165-2"><a href="#cb165-2"></a></span>
<span id="cb165-3"><a href="#cb165-3"></a><span class="kw">func</span> TestConditionals(t *testing.T) {</span>
<span id="cb165-4"><a href="#cb165-4"></a>    tests := []vmTestCase{</span>
<span id="cb165-5"><a href="#cb165-5"></a>        {<span class="st">&quot;if (true) { 10 }&quot;</span>, <span class="dv">10</span>},</span>
<span id="cb165-6"><a href="#cb165-6"></a>        {<span class="st">&quot;if (true) { 10 } else { 20 }&quot;</span>, <span class="dv">10</span>},</span>
<span id="cb165-7"><a href="#cb165-7"></a>        {<span class="st">&quot;if (false) { 10 } else { 20 } &quot;</span>, <span class="dv">20</span>},</span>
<span id="cb165-8"><a href="#cb165-8"></a>        {<span class="st">&quot;if (1) { 10 }&quot;</span>, <span class="dv">10</span>},</span>
<span id="cb165-9"><a href="#cb165-9"></a>        {<span class="st">&quot;if (1 &lt; 2) { 10 }&quot;</span>, <span class="dv">10</span>},</span>
<span id="cb165-10"><a href="#cb165-10"></a>        {<span class="st">&quot;if (1 &lt; 2) { 10 } else { 20 }&quot;</span>, <span class="dv">10</span>},</span>
<span id="cb165-11"><a href="#cb165-11"></a>        {<span class="st">&quot;if (1 &gt; 2) { 10 } else { 20 }&quot;</span>, <span class="dv">20</span>},</span>
<span id="cb165-12"><a href="#cb165-12"></a>    }</span>
<span id="cb165-13"><a href="#cb165-13"></a></span>
<span id="cb165-14"><a href="#cb165-14"></a>    runVmTests(t, tests)</span>
<span id="cb165-15"><a href="#cb165-15"></a>}</span></code></pre></div>
<p>Half of these test cases would’ve been enough. But they’re easy to write, expressive, neat and cost us basically nothing! It also doesn’t hurt us to be abundantly clear about what we want.</p>
<p>We test whether boolean expressions are correctly evaluated by the VM according to Monkey’s “truthy” standards and that the correct branch of the conditional is taken. Since conditionals are expressions that produce values, they allow us to infer which branch was executed by testing for the produced value of the whole conditional.</p>
<p>As neat as the tests are, the error message they produce is nasty:</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb166-1"><a href="#cb166-1"></a>$ go test ./vm</span>
<span id="cb166-2"><a href="#cb166-2"></a>--- FAIL: TestConditionals (0.00s)</span>
<span id="cb166-3"><a href="#cb166-3"></a>panic: runtime error: index out of range [recovered]</span>
<span id="cb166-4"><a href="#cb166-4"></a> panic: runtime error: index out of range</span>
<span id="cb166-5"><a href="#cb166-5"></a></span>
<span id="cb166-6"><a href="#cb166-6"></a>goroutine 20 [running]:</span>
<span id="cb166-7"><a href="#cb166-7"></a>testing.tRunner.func1(0xc4200bc2d0)</span>
<span id="cb166-8"><a href="#cb166-8"></a> /usr/local/go/src/testing/testing.go:742 +0x29d</span>
<span id="cb166-9"><a href="#cb166-9"></a>panic(0x11190e0, 0x11f1fd0)</span>
<span id="cb166-10"><a href="#cb166-10"></a> /usr/local/go/src/runtime/panic.go:502 +0x229</span>
<span id="cb166-11"><a href="#cb166-11"></a>monkey/vm.(*VM).Run(0xc420050e38, 0x800, 0x800)</span>
<span id="cb166-12"><a href="#cb166-12"></a> /Users/mrnugget/code/04/src/monkey/vm/vm.go:46 +0x30c</span>
<span id="cb166-13"><a href="#cb166-13"></a>monkey/vm.runVmTests(0xc4200bc2d0, 0xc420079eb8, 0x7, 0x7)</span>
<span id="cb166-14"><a href="#cb166-14"></a> /Users/mrnugget/code/04/src/monkey/vm/vm_test.go:101 +0x35a</span>
<span id="cb166-15"><a href="#cb166-15"></a>monkey/vm.TestConditionals(0xc4200bc2d0)</span>
<span id="cb166-16"><a href="#cb166-16"></a> /Users/mrnugget/code/04/src/monkey/vm/vm_test.go:80 +0x114</span>
<span id="cb166-17"><a href="#cb166-17"></a>testing.tRunner(0xc4200bc2d0, 0x1149b40)</span>
<span id="cb166-18"><a href="#cb166-18"></a> /usr/local/go/src/testing/testing.go:777 +0xd0</span>
<span id="cb166-19"><a href="#cb166-19"></a>created by testing.(*T).Run</span>
<span id="cb166-20"><a href="#cb166-20"></a> /usr/local/go/src/testing/testing.go:824 +0x2e0</span>
<span id="cb166-21"><a href="#cb166-21"></a>FAIL    monkey/vm   0.011s</span></code></pre></div>
<p>Ugh. Not even an error, but a panic.</p>
<p>Before you dive into the code, though, and try to figure out where the error originates, let me explain: the VM is tripping over the bytecode because it contains opcodes it doesn’t know how to decode. That in itself shouldn’t be a problem, because unknown opcodes are skipped, but not necessarily their operands. Operands are just integers, remember, and might have the same value as an encoded opcode, which might lead the VM to treat them as such. That’s wrong, of course. It’s time we introduce our VM to our jump instructions.</p>
<p>We’ll start with <code>OpJump</code>, because it’s the most straightforward jump instruction we have. It has one 16 bit operand that’s the offset of the instruction the VM should jump to. That’s all we need to know to implement it:</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb167-1"><a href="#cb167-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb167-2"><a href="#cb167-2"></a></span>
<span id="cb167-3"><a href="#cb167-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb167-4"><a href="#cb167-4"></a>    <span class="co">// [...]</span></span>
<span id="cb167-5"><a href="#cb167-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb167-6"><a href="#cb167-6"></a>        <span class="co">// [...]</span></span>
<span id="cb167-7"><a href="#cb167-7"></a></span>
<span id="cb167-8"><a href="#cb167-8"></a>        <span class="kw">case</span> code.OpJump:</span>
<span id="cb167-9"><a href="#cb167-9"></a>            pos := <span class="dt">int</span>(code.ReadUint16(vm.instructions[ip+<span class="dv">1</span>:]))</span>
<span id="cb167-10"><a href="#cb167-10"></a>            ip = pos - <span class="dv">1</span></span>
<span id="cb167-11"><a href="#cb167-11"></a></span>
<span id="cb167-12"><a href="#cb167-12"></a>        <span class="co">// [...]</span></span>
<span id="cb167-13"><a href="#cb167-13"></a>        }</span>
<span id="cb167-14"><a href="#cb167-14"></a>    <span class="co">// [...]</span></span>
<span id="cb167-15"><a href="#cb167-15"></a>}</span></code></pre></div>
<p>We use <code>code.ReadUint16</code> to decode the operand located right after the opcode. That’s step 1. Step 2 is to set the instruction pointer, <code>ip</code>, to the target of our jump. Here’s where we come across one interesting implementation detail: since we’re in a loop that increments <code>ip</code> with each iteration we need to set <code>ip</code> to the offset right before the one we want. That lets the loop do its work and <code>ip</code> gets set to the value we want in the next cycle.</p>
<p>Solely implementing <code>OpJump</code> doesn’t buy us much though, since it’s <code>OpJumpNotTruthy</code> that’s integral to the implementation of conditionals. But while adding a <code>case</code> branch for <code>code.OpJumpNotTruthy</code> does take slightly more code, it’s not much more complicated:</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb168-1"><a href="#cb168-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb168-2"><a href="#cb168-2"></a></span>
<span id="cb168-3"><a href="#cb168-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb168-4"><a href="#cb168-4"></a>    <span class="kw">for</span> ip := <span class="dv">0</span>; ip &lt; <span class="bu">len</span>(vm.instructions); ip++ {</span>
<span id="cb168-5"><a href="#cb168-5"></a>        op := code.Opcode(vm.instructions[ip])</span>
<span id="cb168-6"><a href="#cb168-6"></a></span>
<span id="cb168-7"><a href="#cb168-7"></a>        <span class="kw">switch</span> op {</span>
<span id="cb168-8"><a href="#cb168-8"></a>        <span class="co">// [...]</span></span>
<span id="cb168-9"><a href="#cb168-9"></a></span>
<span id="cb168-10"><a href="#cb168-10"></a>        <span class="kw">case</span> code.OpJumpNotTruthy:</span>
<span id="cb168-11"><a href="#cb168-11"></a>            pos := <span class="dt">int</span>(code.ReadUint16(vm.instructions[ip+<span class="dv">1</span>:]))</span>
<span id="cb168-12"><a href="#cb168-12"></a>            ip += <span class="dv">2</span></span>
<span id="cb168-13"><a href="#cb168-13"></a></span>
<span id="cb168-14"><a href="#cb168-14"></a>            condition := vm.pop()</span>
<span id="cb168-15"><a href="#cb168-15"></a>            <span class="kw">if</span> !isTruthy(condition) {</span>
<span id="cb168-16"><a href="#cb168-16"></a>                ip = pos - <span class="dv">1</span></span>
<span id="cb168-17"><a href="#cb168-17"></a>            }</span>
<span id="cb168-18"><a href="#cb168-18"></a></span>
<span id="cb168-19"><a href="#cb168-19"></a>        <span class="co">// [...]</span></span>
<span id="cb168-20"><a href="#cb168-20"></a></span>
<span id="cb168-21"><a href="#cb168-21"></a>        }</span>
<span id="cb168-22"><a href="#cb168-22"></a>    }</span>
<span id="cb168-23"><a href="#cb168-23"></a>    <span class="co">// [...]</span></span>
<span id="cb168-24"><a href="#cb168-24"></a>}</span>
<span id="cb168-25"><a href="#cb168-25"></a></span>
<span id="cb168-26"><a href="#cb168-26"></a><span class="kw">func</span> isTruthy(obj object.Object) <span class="dt">bool</span> {</span>
<span id="cb168-27"><a href="#cb168-27"></a>    <span class="kw">switch</span> obj := obj.(<span class="kw">type</span>) {</span>
<span id="cb168-28"><a href="#cb168-28"></a></span>
<span id="cb168-29"><a href="#cb168-29"></a>    <span class="kw">case</span> *object.Boolean:</span>
<span id="cb168-30"><a href="#cb168-30"></a>        <span class="kw">return</span> obj.Value</span>
<span id="cb168-31"><a href="#cb168-31"></a></span>
<span id="cb168-32"><a href="#cb168-32"></a>    <span class="kw">default</span>:</span>
<span id="cb168-33"><a href="#cb168-33"></a>        <span class="kw">return</span> <span class="ot">true</span></span>
<span id="cb168-34"><a href="#cb168-34"></a>    }</span>
<span id="cb168-35"><a href="#cb168-35"></a>}</span></code></pre></div>
<p>We again use <code>code.ReadUint16</code> to read in and decode the operand. After that we manually increase <code>ip</code> by two so we correctly skip over the two bytes of the operand in the next cycle. That’s not a new – we’ve already done that when executing <code>OpConstant</code> instructions.</p>
<p>What’s new is the rest. We pop off the topmost stack element and check if it’s truthy with the helper function <code>isTruthy</code>. If it’s <em>not</em> truthy, we jump, which means that we set <code>ip</code> to the index of the instruction right before the target, letting the for-loop do its work.</p>
<p>If the value <em>is</em> truthy we do nothing and start another iteration of the main loop. The result is that we’re executing the consequence of the conditional, which is made up of the instructions right after the <code>OpJumpNotTruthy</code> instruction.</p>
<p>And now, open a <code>drumroll.wav</code> of your choice in your favorite audio player, pour your preferred beverage, hit play and watch this:</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb169-1"><a href="#cb169-1"></a>$ go test ./vm</span>
<span id="cb169-2"><a href="#cb169-2"></a>ok      monkey/vm   0.009s</span></code></pre></div>
<p>We did it. Yes, we did it! Our bytecode compiler and VM are now able to compile and execute Monkey conditionals!</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb170-1"><a href="#cb170-1"></a>$ go build -o monkey . &amp;&amp; ./monkey</span>
<span id="cb170-2"><a href="#cb170-2"></a>Hello mrnugget! This is the Monkey programming language!</span>
<span id="cb170-3"><a href="#cb170-3"></a>Feel free to type in commands</span>
<span id="cb170-4"><a href="#cb170-4"></a>&gt;&gt; if (10 &gt; 5) { 10; } else { 12; }</span>
<span id="cb170-5"><a href="#cb170-5"></a>10</span>
<span id="cb170-6"><a href="#cb170-6"></a>&gt;&gt; if (5 &gt; 10) { 10; } else { 12; }</span>
<span id="cb170-7"><a href="#cb170-7"></a>12</span>
<span id="cb170-8"><a href="#cb170-8"></a>&gt;&gt;</span></code></pre></div>
<p>This is the point where we went from “well, this is toy, isn’t it?” to “oh wow, we’re getting somewhere!”. Stack arithmetic is one thing, but jump instructions are another. We’re in the big leagues now. Except…</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb171-1"><a href="#cb171-1"></a>&gt;&gt; if (false) { 10; }</span>
<span id="cb171-2"><a href="#cb171-2"></a>panic: runtime error: index out of range</span>
<span id="cb171-3"><a href="#cb171-3"></a></span>
<span id="cb171-4"><a href="#cb171-4"></a>goroutine 1 [running]:</span>
<span id="cb171-5"><a href="#cb171-5"></a>monkey/vm.(*VM).pop(...)</span>
<span id="cb171-6"><a href="#cb171-6"></a> /Users/mrnugget/code/04/src/monkey/vm/vm.go:117</span>
<span id="cb171-7"><a href="#cb171-7"></a>monkey/vm.(*VM).Run(0xc42005be48, 0x800, 0x800)</span>
<span id="cb171-8"><a href="#cb171-8"></a> /Users/mrnugget/code/04/src/monkey/vm/vm.go:60 +0x40e</span>
<span id="cb171-9"><a href="#cb171-9"></a>monkey/repl.Start(0x10f1080, 0xc42000e010, 0x10f10a0, 0xc42000e018)</span>
<span id="cb171-10"><a href="#cb171-10"></a> /Users/mrnugget/code/04/src/monkey/repl/repl.go:43 +0x47a</span>
<span id="cb171-11"><a href="#cb171-11"></a>main.main()</span>
<span id="cb171-12"><a href="#cb171-12"></a> /Users/mrnugget/code/04/src/monkey/main.go:18 +0x107</span></code></pre></div>
<p>We forgot something.</p>
<h2 id="welcome-back-null">Welcome Back, Null!</h2>
<p>At the start of this chapter we looked back at our implementation of conditionals in <em>Writing An Interpreter In Go</em>, and now we have implemented the majority of its behaviour. But there’s one thing we’re still missing: what happens when the condition of a conditional is <em>not</em> truthy but the conditional itself has no alternative? In the previous book the answer to this question was <code>*object.Null</code>, Monkey’s null value.</p>
<p>That makes sense, because conditionals are expressions and expressions, by definition, produce values. So what does an expression that produced nothing evaluate to? Null. Wait, let me try that again, only this time imagine a <em>big organ sound</em> in the background, <em>crows flying overhead</em>, <em>screeching</em>, <em>thunder</em>: They… <em>lightning strikes</em>… evaluate to … <em>sirens</em> … null.</p>
<p>Look, null and I, we’re not the best of friends. I’m not really sure what to think of it, whether it’s good or bad. It’s the cause of many curses but I do understand that there are languages in which some things evaluate to nothing and that “nothing” has to be represented somehow. In Monkey, conditionals with a false condition and no alternative are one of these things, and “nothing” is represented by <code>*object.Null</code>. Long story short: it’s time we introduce <code>*object.Null</code> to our compiler and VM and make this type of conditional work properly.</p>
<p>The first thing we need is a definition of <code>*object.Null</code> in our VM. Since its value is constant, we can define it as a global variable, just like our previous global definitions of <code>vm.True</code> and <code>vm.False</code>:</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb172-1"><a href="#cb172-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb172-2"><a href="#cb172-2"></a></span>
<span id="cb172-3"><a href="#cb172-3"></a><span class="kw">var</span> Null = &amp;object.Null{}</span></code></pre></div>
<p>This is also similar to <code>vm.True</code> and <code>vm.False</code> in that it saves us a lot of work when comparing Monkey objects. We can simply check if an <code>object.Object</code> is <code>*object.Null</code> by checking whether it’s equal to <code>vm.Null</code>. We do not have to unwrap it and take a look at its value.</p>
<p>The reason why we first defined <code>vm.Null</code>, before writing any compiler tests – our usual course of action – is that this time we want do write a VM test first. And that’s because the VM tests allow us to express what we want so succinctly:</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb173-1"><a href="#cb173-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb173-2"><a href="#cb173-2"></a></span>
<span id="cb173-3"><a href="#cb173-3"></a><span class="kw">func</span> TestConditionals(t *testing.T) {</span>
<span id="cb173-4"><a href="#cb173-4"></a>    tests := []vmTestCase{</span>
<span id="cb173-5"><a href="#cb173-5"></a>        <span class="co">// [...]</span></span>
<span id="cb173-6"><a href="#cb173-6"></a>        {<span class="st">&quot;if (1 &gt; 2) { 10 }&quot;</span>, Null},</span>
<span id="cb173-7"><a href="#cb173-7"></a>        {<span class="st">&quot;if (false) { 10 }&quot;</span>, Null},</span>
<span id="cb173-8"><a href="#cb173-8"></a>    }</span>
<span id="cb173-9"><a href="#cb173-9"></a></span>
<span id="cb173-10"><a href="#cb173-10"></a>    runVmTests(t, tests)</span>
<span id="cb173-11"><a href="#cb173-11"></a>}</span>
<span id="cb173-12"><a href="#cb173-12"></a></span>
<span id="cb173-13"><a href="#cb173-13"></a><span class="kw">func</span> testExpectedObject(</span>
<span id="cb173-14"><a href="#cb173-14"></a>    t *testing.T,</span>
<span id="cb173-15"><a href="#cb173-15"></a>    expected <span class="kw">interface</span>{},</span>
<span id="cb173-16"><a href="#cb173-16"></a>    actual object.Object,</span>
<span id="cb173-17"><a href="#cb173-17"></a>) {</span>
<span id="cb173-18"><a href="#cb173-18"></a>    t.Helper()</span>
<span id="cb173-19"><a href="#cb173-19"></a></span>
<span id="cb173-20"><a href="#cb173-20"></a>    <span class="kw">switch</span> expected := expected.(<span class="kw">type</span>) {</span>
<span id="cb173-21"><a href="#cb173-21"></a>    <span class="co">// [...]</span></span>
<span id="cb173-22"><a href="#cb173-22"></a>    <span class="kw">case</span> *object.Null:</span>
<span id="cb173-23"><a href="#cb173-23"></a>        <span class="kw">if</span> actual != Null {</span>
<span id="cb173-24"><a href="#cb173-24"></a>            t.Errorf(<span class="st">&quot;object is not Null: %T (%+v)&quot;</span>, actual, actual)</span>
<span id="cb173-25"><a href="#cb173-25"></a>        }</span>
<span id="cb173-26"><a href="#cb173-26"></a>    }</span>
<span id="cb173-27"><a href="#cb173-27"></a>}</span></code></pre></div>
<p>Here we have two new test cases for our existing <code>TestConditionals</code> function in which the condition is not Monkey truthy to force the evaluation of the alternative. But since there is none, we expect <code>Null</code> to end up on the stack. To test that properly, we extend the <code>testExpectedObject</code> with a new <code>case</code> branch for <code>*object.Null</code>.</p>
<p>Neatly expressed, isn’t it? Well, the error message isn’t:</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb174-1"><a href="#cb174-1"></a>$ go test ./vm</span>
<span id="cb174-2"><a href="#cb174-2"></a>--- FAIL: TestConditionals (0.00s)</span>
<span id="cb174-3"><a href="#cb174-3"></a>panic: runtime error: index out of range [recovered]</span>
<span id="cb174-4"><a href="#cb174-4"></a> panic: runtime error: index out of range</span>
<span id="cb174-5"><a href="#cb174-5"></a></span>
<span id="cb174-6"><a href="#cb174-6"></a>goroutine 7 [running]:</span>
<span id="cb174-7"><a href="#cb174-7"></a>testing.tRunner.func1(0xc4200a82d0)</span>
<span id="cb174-8"><a href="#cb174-8"></a> /usr/local/go/src/testing/testing.go:742 +0x29d</span>
<span id="cb174-9"><a href="#cb174-9"></a>panic(0x1119420, 0x11f1fe0)</span>
<span id="cb174-10"><a href="#cb174-10"></a> /usr/local/go/src/runtime/panic.go:502 +0x229</span>
<span id="cb174-11"><a href="#cb174-11"></a>monkey/vm.(*VM).pop(...)</span>
<span id="cb174-12"><a href="#cb174-12"></a> /Users/mrnugget/code/04/src/monkey/vm/vm.go:121</span>
<span id="cb174-13"><a href="#cb174-13"></a>monkey/vm.(*VM).Run(0xc420054df8, 0x800, 0x800)</span>
<span id="cb174-14"><a href="#cb174-14"></a> /Users/mrnugget/code/04/src/monkey/vm/vm.go:53 +0x418</span>
<span id="cb174-15"><a href="#cb174-15"></a>monkey/vm.runVmTests(0xc4200a82d0, 0xc420073e78, 0x9, 0x9)</span>
<span id="cb174-16"><a href="#cb174-16"></a> /Users/mrnugget/code/04/src/monkey/vm/vm_test.go:103 +0x35a</span>
<span id="cb174-17"><a href="#cb174-17"></a>monkey/vm.TestConditionals(0xc4200a82d0)</span>
<span id="cb174-18"><a href="#cb174-18"></a> /Users/mrnugget/code/04/src/monkey/vm/vm_test.go:82 +0x149</span>
<span id="cb174-19"><a href="#cb174-19"></a>testing.tRunner(0xc4200a82d0, 0x1149f40)</span>
<span id="cb174-20"><a href="#cb174-20"></a> /usr/local/go/src/testing/testing.go:777 +0xd0</span>
<span id="cb174-21"><a href="#cb174-21"></a>created by testing.(*T).Run</span>
<span id="cb174-22"><a href="#cb174-22"></a> /usr/local/go/src/testing/testing.go:824 +0x2e0</span>
<span id="cb174-23"><a href="#cb174-23"></a>FAIL    monkey/vm   0.012s</span></code></pre></div>
<p>The cause for this panic are the <code>OpPop</code> instructions we emit after the conditionals. Since they produced no value, the VM crashes trying to pop something off the stack. Time to change that, time to put <code>vm.Null</code> on to the stack.</p>
<p>We’re going to do two things to pull that off. First, we’re going to define an opcode that tells the VM to put <code>vm.Null</code> on the stack. Then we’re going to modify the compiler to insert an alternative when a conditional doesn’t have one. And the only thing this alternative branch will contain is the new opcode that pushes <code>vm.Null</code> on to the stack.</p>
<p>We define the opcode first so we can use it in our updated compiler tests:</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb175-1"><a href="#cb175-1"></a><span class="co">// code/code.go</span></span>
<span id="cb175-2"><a href="#cb175-2"></a></span>
<span id="cb175-3"><a href="#cb175-3"></a><span class="kw">const</span> (</span>
<span id="cb175-4"><a href="#cb175-4"></a>    <span class="co">// [...]</span></span>
<span id="cb175-5"><a href="#cb175-5"></a></span>
<span id="cb175-6"><a href="#cb175-6"></a>    OpNull</span>
<span id="cb175-7"><a href="#cb175-7"></a>)</span>
<span id="cb175-8"><a href="#cb175-8"></a></span>
<span id="cb175-9"><a href="#cb175-9"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb175-10"><a href="#cb175-10"></a>    <span class="co">// [...]</span></span>
<span id="cb175-11"><a href="#cb175-11"></a></span>
<span id="cb175-12"><a href="#cb175-12"></a>    OpNull:  {<span class="st">&quot;OpNull&quot;</span>, []<span class="dt">int</span>{}},</span>
<span id="cb175-13"><a href="#cb175-13"></a>}</span></code></pre></div>
<p>That’s also similar to the boolean counterparts, <code>OpTrue</code> and <code>OpFalse</code>. <code>OpNull</code> doesn’t have any operands and only instructs the VM to push one value on to the stack.</p>
<p>Instead of now writing a new compiler test, we’re going to update an existing test case in <code>TestConditionals</code> and expect to find <code>OpNull</code> in the generated instructions. Please note that we need to change the first test case, the one in which the conditional doesn’t have an alternative; the other test case stays as it is:</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb176-1"><a href="#cb176-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb176-2"><a href="#cb176-2"></a></span>
<span id="cb176-3"><a href="#cb176-3"></a><span class="kw">func</span> TestConditionals(t *testing.T) {</span>
<span id="cb176-4"><a href="#cb176-4"></a>    tests := []compilerTestCase{</span>
<span id="cb176-5"><a href="#cb176-5"></a>        {</span>
<span id="cb176-6"><a href="#cb176-6"></a>            input: <span class="st">`</span></span>
<span id="cb176-7"><a href="#cb176-7"></a><span class="st">            if (true) { 10 }; 3333;</span></span>
<span id="cb176-8"><a href="#cb176-8"></a><span class="st">            `</span>,</span>
<span id="cb176-9"><a href="#cb176-9"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">10</span>, <span class="dv">3333</span>},</span>
<span id="cb176-10"><a href="#cb176-10"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb176-11"><a href="#cb176-11"></a>                <span class="co">// 0000</span></span>
<span id="cb176-12"><a href="#cb176-12"></a>                code.Make(code.OpTrue),</span>
<span id="cb176-13"><a href="#cb176-13"></a>                <span class="co">// 0001</span></span>
<span id="cb176-14"><a href="#cb176-14"></a>                code.Make(code.OpJumpNotTruthy, <span class="dv">10</span>),</span>
<span id="cb176-15"><a href="#cb176-15"></a>                <span class="co">// 0004</span></span>
<span id="cb176-16"><a href="#cb176-16"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb176-17"><a href="#cb176-17"></a>                <span class="co">// 0007</span></span>
<span id="cb176-18"><a href="#cb176-18"></a>                code.Make(code.OpJump, <span class="dv">11</span>),</span>
<span id="cb176-19"><a href="#cb176-19"></a>                <span class="co">// 0010</span></span>
<span id="cb176-20"><a href="#cb176-20"></a>                code.Make(code.OpNull),</span>
<span id="cb176-21"><a href="#cb176-21"></a>                <span class="co">// 0011</span></span>
<span id="cb176-22"><a href="#cb176-22"></a>                code.Make(code.OpPop),</span>
<span id="cb176-23"><a href="#cb176-23"></a>                <span class="co">// 0012</span></span>
<span id="cb176-24"><a href="#cb176-24"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb176-25"><a href="#cb176-25"></a>                <span class="co">// 0015</span></span>
<span id="cb176-26"><a href="#cb176-26"></a>                code.Make(code.OpPop),</span>
<span id="cb176-27"><a href="#cb176-27"></a>            },</span>
<span id="cb176-28"><a href="#cb176-28"></a>        },</span>
<span id="cb176-29"><a href="#cb176-29"></a>        <span class="co">// [...]</span></span>
<span id="cb176-30"><a href="#cb176-30"></a>    }</span>
<span id="cb176-31"><a href="#cb176-31"></a></span>
<span id="cb176-32"><a href="#cb176-32"></a>    runCompilerTests(t, tests)</span>
<span id="cb176-33"><a href="#cb176-33"></a>}</span></code></pre></div>
<p>New are the two instructions in the middle: <code>OpJump</code> and <code>OpNull</code>. Remember, <code>OpJump</code> is there to jump over the alternative and now <code>OpNull</code> <em>is</em> the alternative. And since the addition of these two instructions changes the index of existing instructions, the operand for <code>OpJumpNotTruthy</code> also has to be changed from <code>7</code> to <code>10</code>. The rest stays the same.</p>
<p>Running the updated tests confirms that the compiler didn’t learn how to insert artificial alternatives to conditionals on its own yet:</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb177-1"><a href="#cb177-1"></a>$ go test ./compiler</span>
<span id="cb177-2"><a href="#cb177-2"></a>--- FAIL: TestConditionals (0.00s)</span>
<span id="cb177-3"><a href="#cb177-3"></a> compiler_test.go:288: testInstructions failed: wrong instructions length.</span>
<span id="cb177-4"><a href="#cb177-4"></a>  want=&quot;0000 OpTrue\n0001 OpJumpNotTruthy 10\n0004 OpConstant 0\n\</span>
<span id="cb177-5"><a href="#cb177-5"></a>    0007 OpJump 11\n0010 OpNull\n\</span>
<span id="cb177-6"><a href="#cb177-6"></a>    0011 OpPop\n0012 OpConstant 1\n0015 OpPop\n&quot;</span>
<span id="cb177-7"><a href="#cb177-7"></a>  got =&quot;0000 OpTrue\n0001 OpJumpNotTruthy 7\n0004 OpConstant 0\n\</span>
<span id="cb177-8"><a href="#cb177-8"></a>    0007 OpPop\n0008 OpConstant 1\n0011 OpPop\n&quot;</span>
<span id="cb177-9"><a href="#cb177-9"></a>FAIL</span>
<span id="cb177-10"><a href="#cb177-10"></a>FAIL    monkey/compiler 0.008s</span></code></pre></div>
<p>The best part about fixing this is making the code in our compiler simpler and easier to understand. We no longer have to check whether to emit <code>OpJump</code> or not, because we always want to do that now. Only sometimes do we want to jump over a “real” alternative and sometimes over an <code>OpNull</code> instruction. So, here’s the updated <code>case *ast.IfExpression</code> branch of the <code>Compile</code> method:</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb178-1"><a href="#cb178-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb178-2"><a href="#cb178-2"></a></span>
<span id="cb178-3"><a href="#cb178-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb178-4"><a href="#cb178-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb178-5"><a href="#cb178-5"></a>    <span class="co">// [...]</span></span>
<span id="cb178-6"><a href="#cb178-6"></a></span>
<span id="cb178-7"><a href="#cb178-7"></a>    <span class="kw">case</span> *ast.IfExpression:</span>
<span id="cb178-8"><a href="#cb178-8"></a>        err := c.Compile(node.Condition)</span>
<span id="cb178-9"><a href="#cb178-9"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb178-10"><a href="#cb178-10"></a>            <span class="kw">return</span> err</span>
<span id="cb178-11"><a href="#cb178-11"></a>        }</span>
<span id="cb178-12"><a href="#cb178-12"></a></span>
<span id="cb178-13"><a href="#cb178-13"></a>        <span class="co">// Emit an `OpJumpNotTruthy` with a bogus value</span></span>
<span id="cb178-14"><a href="#cb178-14"></a>        jumpNotTruthyPos := c.emit(code.OpJumpNotTruthy, <span class="dv">9999</span>)</span>
<span id="cb178-15"><a href="#cb178-15"></a></span>
<span id="cb178-16"><a href="#cb178-16"></a>        err = c.Compile(node.Consequence)</span>
<span id="cb178-17"><a href="#cb178-17"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb178-18"><a href="#cb178-18"></a>            <span class="kw">return</span> err</span>
<span id="cb178-19"><a href="#cb178-19"></a>        }</span>
<span id="cb178-20"><a href="#cb178-20"></a></span>
<span id="cb178-21"><a href="#cb178-21"></a>        <span class="kw">if</span> c.lastInstructionIsPop() {</span>
<span id="cb178-22"><a href="#cb178-22"></a>            c.removeLastPop()</span>
<span id="cb178-23"><a href="#cb178-23"></a>        }</span>
<span id="cb178-24"><a href="#cb178-24"></a></span>
<span id="cb178-25"><a href="#cb178-25"></a>        <span class="co">// Emit an `OpJump` with a bogus value</span></span>
<span id="cb178-26"><a href="#cb178-26"></a>        jumpPos := c.emit(code.OpJump, <span class="dv">9999</span>)</span>
<span id="cb178-27"><a href="#cb178-27"></a></span>
<span id="cb178-28"><a href="#cb178-28"></a>        afterConsequencePos := <span class="bu">len</span>(c.instructions)</span>
<span id="cb178-29"><a href="#cb178-29"></a>        c.changeOperand(jumpNotTruthyPos, afterConsequencePos)</span>
<span id="cb178-30"><a href="#cb178-30"></a></span>
<span id="cb178-31"><a href="#cb178-31"></a>        <span class="kw">if</span> node.Alternative == <span class="ot">nil</span> {</span>
<span id="cb178-32"><a href="#cb178-32"></a>            c.emit(code.OpNull)</span>
<span id="cb178-33"><a href="#cb178-33"></a>        } <span class="kw">else</span> {</span>
<span id="cb178-34"><a href="#cb178-34"></a>            err := c.Compile(node.Alternative)</span>
<span id="cb178-35"><a href="#cb178-35"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb178-36"><a href="#cb178-36"></a>                <span class="kw">return</span> err</span>
<span id="cb178-37"><a href="#cb178-37"></a>            }</span>
<span id="cb178-38"><a href="#cb178-38"></a></span>
<span id="cb178-39"><a href="#cb178-39"></a>            <span class="kw">if</span> c.lastInstructionIsPop() {</span>
<span id="cb178-40"><a href="#cb178-40"></a>                c.removeLastPop()</span>
<span id="cb178-41"><a href="#cb178-41"></a>            }</span>
<span id="cb178-42"><a href="#cb178-42"></a>        }</span>
<span id="cb178-43"><a href="#cb178-43"></a></span>
<span id="cb178-44"><a href="#cb178-44"></a>        afterAlternativePos := <span class="bu">len</span>(c.instructions)</span>
<span id="cb178-45"><a href="#cb178-45"></a>        c.changeOperand(jumpPos, afterAlternativePos)</span>
<span id="cb178-46"><a href="#cb178-46"></a></span>
<span id="cb178-47"><a href="#cb178-47"></a>    <span class="co">// [...]</span></span>
<span id="cb178-48"><a href="#cb178-48"></a>    }</span>
<span id="cb178-49"><a href="#cb178-49"></a></span>
<span id="cb178-50"><a href="#cb178-50"></a>    <span class="co">// [...]</span></span>
<span id="cb178-51"><a href="#cb178-51"></a>}</span></code></pre></div>
<p>That’s the complete branch but only its second half has been changed: the duplicated patching of the <code>OpJumpNotTruthy</code> instruction is gone and in its place we can find the new, readable compilation of a possible <code>node.Alternative</code>.</p>
<p>We start by emitting an <code>OpJump</code> instruction and updating the operand of the <code>OpJumpNotTruthy</code> instruction. That happens whether we have a <code>node.Alternative</code> or not. But then we check whether <code>node.Alternative</code> is <code>nil</code> and if it is, we emit the new <code>OpNull</code> opcode. If it’s not <code>nil</code>, we proceed as before: compile <code>node.Alternative</code> and then try to get rid of a possible <code>OpPop</code> instruction.</p>
<p>After that, we change the operand of the <code>OpJump</code> instruction to jump over the freshly-compiled alternative – no matter whether that’s just an <code>OpNull</code> or more.</p>
<p>That code is not only a lot cleaner than our previous version, it also works:</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb179-1"><a href="#cb179-1"></a>$ go test ./compiler</span>
<span id="cb179-2"><a href="#cb179-2"></a>ok      monkey/compiler 0.009s</span></code></pre></div>
<p>Now we can move on to our VM, where our test is still failing and where we have to implement the new <code>OpNull</code> opcode:</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb180-1"><a href="#cb180-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb180-2"><a href="#cb180-2"></a></span>
<span id="cb180-3"><a href="#cb180-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb180-4"><a href="#cb180-4"></a>    <span class="co">// [...]</span></span>
<span id="cb180-5"><a href="#cb180-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb180-6"><a href="#cb180-6"></a>        <span class="co">// [...]</span></span>
<span id="cb180-7"><a href="#cb180-7"></a></span>
<span id="cb180-8"><a href="#cb180-8"></a>        <span class="kw">case</span> code.OpNull:</span>
<span id="cb180-9"><a href="#cb180-9"></a>            err := vm.push(Null)</span>
<span id="cb180-10"><a href="#cb180-10"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb180-11"><a href="#cb180-11"></a>                <span class="kw">return</span> err</span>
<span id="cb180-12"><a href="#cb180-12"></a>            }</span>
<span id="cb180-13"><a href="#cb180-13"></a></span>
<span id="cb180-14"><a href="#cb180-14"></a>        <span class="co">// [...]</span></span>
<span id="cb180-15"><a href="#cb180-15"></a>        }</span>
<span id="cb180-16"><a href="#cb180-16"></a>    <span class="co">// [...]</span></span>
<span id="cb180-17"><a href="#cb180-17"></a>}</span></code></pre></div>
<p>With that, the panic is gone and our tests pass:</p>
<div class="sourceCode" id="cb181"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb181-1"><a href="#cb181-1"></a>$ go test ./vm</span>
<span id="cb181-2"><a href="#cb181-2"></a>ok      monkey/vm   0.009s</span></code></pre></div>
<p>That means we’ve successfully made conditionals with a non-truthy condition put <code>Null</code> on to the stack. We have now implemented the complete behaviour of conditionals as described in <em>Writing An Interpreter In Go</em>!</p>
<p>But, sorry to say, there’s one more thing we have to do. With this last passing test, we’ve officially entered a new world. Since a conditional is an expression and expressions can be used interchangeably, it follows that any expression can now produce <code>Null</code> in our VM. It’s a scary world, yes.</p>
<p>For us, the practical implication is that we now have to handle <code>Null</code> in every place where we handle a value produced by an expression. Thankfully, most of these places in our VM – like <code>vm.executeBinaryOperation</code> – throw an error if they come across a value they did not expect. But there are functions and methods that now <em>must</em> handle <code>Null</code> explicitly.</p>
<p>The first of these is <code>vm.executeBangOperator</code>. We can add a test to make sure that it handles <code>Null</code> without blowing up:</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb182-1"><a href="#cb182-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb182-2"><a href="#cb182-2"></a></span>
<span id="cb182-3"><a href="#cb182-3"></a><span class="kw">func</span> TestBooleanExpressions(t *testing.T) {</span>
<span id="cb182-4"><a href="#cb182-4"></a>    tests := []vmTestCase{</span>
<span id="cb182-5"><a href="#cb182-5"></a>        <span class="co">// [...]</span></span>
<span id="cb182-6"><a href="#cb182-6"></a>        {<span class="st">&quot;!(if (false) { 5; })&quot;</span>, <span class="ot">true</span>},</span>
<span id="cb182-7"><a href="#cb182-7"></a>    }</span>
<span id="cb182-8"><a href="#cb182-8"></a></span>
<span id="cb182-9"><a href="#cb182-9"></a>    runVmTests(t, tests)</span>
<span id="cb182-10"><a href="#cb182-10"></a>}</span></code></pre></div>
<p>With this test case we implicitly make sure that a conditional with a non-truthy condition and no alternative results in <code>Null</code> and that the negation of that, through the use of the <code>!</code> operator, turns it into <code>True</code>. Under the hood, this involves <code>vm.executeBangOperator</code> and in order to get the test to pass, we need to change it:</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb183-1"><a href="#cb183-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb183-2"><a href="#cb183-2"></a></span>
<span id="cb183-3"><a href="#cb183-3"></a><span class="kw">func</span> (vm *VM) executeBangOperator() <span class="dt">error</span> {</span>
<span id="cb183-4"><a href="#cb183-4"></a>    operand := vm.pop()</span>
<span id="cb183-5"><a href="#cb183-5"></a></span>
<span id="cb183-6"><a href="#cb183-6"></a>    <span class="kw">switch</span> operand {</span>
<span id="cb183-7"><a href="#cb183-7"></a>    <span class="kw">case</span> True:</span>
<span id="cb183-8"><a href="#cb183-8"></a>        <span class="kw">return</span> vm.push(False)</span>
<span id="cb183-9"><a href="#cb183-9"></a>    <span class="kw">case</span> False:</span>
<span id="cb183-10"><a href="#cb183-10"></a>        <span class="kw">return</span> vm.push(True)</span>
<span id="cb183-11"><a href="#cb183-11"></a>    <span class="kw">case</span> Null:</span>
<span id="cb183-12"><a href="#cb183-12"></a>        <span class="kw">return</span> vm.push(True)</span>
<span id="cb183-13"><a href="#cb183-13"></a>    <span class="kw">default</span>:</span>
<span id="cb183-14"><a href="#cb183-14"></a>        <span class="kw">return</span> vm.push(False)</span>
<span id="cb183-15"><a href="#cb183-15"></a>    }</span>
<span id="cb183-16"><a href="#cb183-16"></a>}</span></code></pre></div>
<p>The negation of <code>Null</code> is now <code>True</code> – exactly as in <em>Writing An Interpreter In Go</em>. The tests pass:</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb184-1"><a href="#cb184-1"></a>$ go test ./vm</span>
<span id="cb184-2"><a href="#cb184-2"></a>ok      monkey/vm   0.009s</span></code></pre></div>
<p>Here comes the weird part. Since a conditional is an expression and its condition is one too, it follows that we can use a conditional as the condition of another conditional. Here, too, I’m sure that you and I wouldn’t do this in the code we write, but be that as it may, it has to work in our VM – even if the inner conditional produces <code>Null</code>:</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb185-1"><a href="#cb185-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb185-2"><a href="#cb185-2"></a></span>
<span id="cb185-3"><a href="#cb185-3"></a><span class="kw">func</span> TestConditionals(t *testing.T) {</span>
<span id="cb185-4"><a href="#cb185-4"></a>    tests := []vmTestCase{</span>
<span id="cb185-5"><a href="#cb185-5"></a>        <span class="co">// [...]</span></span>
<span id="cb185-6"><a href="#cb185-6"></a>        {<span class="st">&quot;if ((if (false) { 10 })) { 10 } else { 20 }&quot;</span>, <span class="dv">20</span>},</span>
<span id="cb185-7"><a href="#cb185-7"></a>    }</span>
<span id="cb185-8"><a href="#cb185-8"></a></span>
<span id="cb185-9"><a href="#cb185-9"></a>    runVmTests(t, tests)</span>
<span id="cb185-10"><a href="#cb185-10"></a>}</span></code></pre></div>
<p>This looks like it might be a mess to fix, but since our code is squeaky clean and well maintained there’s only one place where we need to make a change; a quite obvious one, too. We need to tell the VM that an <code>*object.Null</code> is not <code>isTruthy</code>:</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb186-1"><a href="#cb186-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb186-2"><a href="#cb186-2"></a></span>
<span id="cb186-3"><a href="#cb186-3"></a><span class="kw">func</span> isTruthy(obj object.Object) <span class="dt">bool</span> {</span>
<span id="cb186-4"><a href="#cb186-4"></a>    <span class="kw">switch</span> obj := obj.(<span class="kw">type</span>) {</span>
<span id="cb186-5"><a href="#cb186-5"></a></span>
<span id="cb186-6"><a href="#cb186-6"></a>    <span class="kw">case</span> *object.Boolean:</span>
<span id="cb186-7"><a href="#cb186-7"></a>        <span class="kw">return</span> obj.Value</span>
<span id="cb186-8"><a href="#cb186-8"></a></span>
<span id="cb186-9"><a href="#cb186-9"></a>    <span class="kw">case</span> *object.Null:</span>
<span id="cb186-10"><a href="#cb186-10"></a>        <span class="kw">return</span> <span class="ot">false</span></span>
<span id="cb186-11"><a href="#cb186-11"></a></span>
<span id="cb186-12"><a href="#cb186-12"></a>    <span class="kw">default</span>:</span>
<span id="cb186-13"><a href="#cb186-13"></a>        <span class="kw">return</span> <span class="ot">true</span></span>
<span id="cb186-14"><a href="#cb186-14"></a>    }</span>
<span id="cb186-15"><a href="#cb186-15"></a>}</span></code></pre></div>
<p>That’s two new lines of code and we’re done:</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb187-1"><a href="#cb187-1"></a>$ go test ./vm</span>
<span id="cb187-2"><a href="#cb187-2"></a>ok      monkey/vm   0.011s</span></code></pre></div>
<p>And now done means <em>done</em>. Our implementation of conditionals is now feature complete and we have a <code>Null</code>-safe VM:</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb188-1"><a href="#cb188-1"></a>$ go build -o monkey . &amp;&amp; ./monkey</span>
<span id="cb188-2"><a href="#cb188-2"></a>Hello mrnugget! This is the Monkey programming language!</span>
<span id="cb188-3"><a href="#cb188-3"></a>Feel free to type in commands</span>
<span id="cb188-4"><a href="#cb188-4"></a>&gt;&gt; if (false) { 10 }</span>
<span id="cb188-5"><a href="#cb188-5"></a>null</span></code></pre></div>
<p>Time to play <code>drumroll.wav</code> again, only this time knowing that we didn’t forget something.</p>
<h1 id="keeping-track-of-names">Keeping Track of Names</h1>
<p>Up until now we’ve referenced values in our Monkey code by using boolean and integer literals. That’s going to change. In this chapter we’re going to implement <em>bindings</em>, by adding support for let statements and identifier expressions. At the end, we’ll be able to bind any value to any name and then have that name resolve to the value.</p>
<p>As preparation, here’s a short refresher of what let statements in Monkey look like:</p>
<div class="sourceCode" id="cb189"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb189-1"><a href="#cb189-1"></a><span class="kw">let</span> x <span class="op">=</span> <span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span><span class="op">;</span></span></code></pre></div>
<p>As you can see, a let statement in Monkey starts with the <code>let</code> keyword followed by an identifier. The identifier is the name to which we want to bind a value, in this case it’s <code>x</code>. The right side of the <code>=</code> is an expression. It evaluates to the value the name will be bound to. And since it’s a let <em>statement</em> it’s followed by a semicolon. Let name equal value of expression; that’s it.</p>
<p>Referencing the value to which <code>x</code> has been bound is easy, since identifiers, which is what the <code>x</code> is in the terms of our AST, are expressions and can be used interchangeably. We can use <code>x</code> in every place where an expression is valid:</p>
<div class="sourceCode" id="cb190"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb190-1"><a href="#cb190-1"></a>x <span class="op">*</span> <span class="dv">5</span> <span class="op">*</span> x <span class="op">*</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb190-2"><a href="#cb190-2"></a><span class="cf">if</span> (x <span class="op">&lt;</span> <span class="dv">10</span>) { x <span class="op">*</span> <span class="dv">2</span> } <span class="cf">else</span> { x <span class="op">/</span> <span class="dv">2</span> }<span class="op">;</span></span>
<span id="cb190-3"><a href="#cb190-3"></a><span class="kw">let</span> y <span class="op">=</span> x <span class="op">+</span> <span class="dv">5</span><span class="op">;</span></span></code></pre></div>
<p>Let statements are valid as either top-level statements or inside a block statement, like the branches of a conditional or the body of a function. In this chapter, we’re only going to add support for the top-level and non-function-body block-statement varieties. We’ll tackle local variables, which is what let statements inside functions produce, when we implement functions and closures.</p>
<p>Our goal for this chapter is to be able to compile the following code to bytecode and have our VM execute it:</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb191-1"><a href="#cb191-1"></a><span class="kw">let</span> x <span class="op">=</span> <span class="dv">5</span> <span class="op">*</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb191-2"><a href="#cb191-2"></a></span>
<span id="cb191-3"><a href="#cb191-3"></a><span class="cf">if</span> (x <span class="op">&gt;</span> <span class="dv">10</span>) {</span>
<span id="cb191-4"><a href="#cb191-4"></a>  <span class="kw">let</span> y <span class="op">=</span> x <span class="op">*</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb191-5"><a href="#cb191-5"></a>  y<span class="op">;</span></span>
<span id="cb191-6"><a href="#cb191-6"></a>}</span></code></pre></div>
<p>And, yes, it should also <em>correctly</em> execute it and produce <code>50</code> here.</p>
<h2 id="the-plan">The Plan</h2>
<p>So how do we go about implementing this? Obviously, we need to compile let statements and identifier expressions to bytecode instructions and support these instructions in the VM. That much is clear. And I also don’t think there’s any debate about how many new opcodes we need. We need one to tell the VM to bind a value to an identifier and another one to retrieve the value previously bound to an identifier. But what do these new instructions look like?</p>
<p>The main task when implementing bindings is to have the identifiers correctly resolve to the values they were previously bound to. If you can pass around the identifiers when executing the code – like we did in our evaluator – that’s not much of challenge. You can, for example, use the identifiers as keys to a map in which you store and retrieve the values. But we can’t.</p>
<p>We’re not in our evaluator anymore. We’re now working with bytecode and we can’t just pass around identifiers in bytecode – the operands to our opcodes are integers. How do we then represent the identifier in these new instructions? And, how do we reference the value that should be bound to the identifier?</p>
<p>The answer to the second question consists of two words, so let’s start with that one. Here it comes: the stack. Yep, that’s <em>it</em>, we don’t need more than that. We don’t need to explicitly reference the value we want to bind – we have a stack machine! We can just push the value on to the stack and tell the VM: “now bind the topmost stack element to <em>this</em> identifier”. That fits in beautifully with the rest of our instruction set.</p>
<p>Back to the first question: how do we represent identifiers in our bytecode when we can only use numbers as operands? The answer is hidden in the question itself: we’ll use numbers to represent identifiers. Let me explain that with a bit of Monkey code:</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb192-1"><a href="#cb192-1"></a><span class="kw">let</span> x <span class="op">=</span> <span class="dv">33</span><span class="op">;</span></span>
<span id="cb192-2"><a href="#cb192-2"></a><span class="kw">let</span> y <span class="op">=</span> <span class="dv">66</span><span class="op">;</span></span>
<span id="cb192-3"><a href="#cb192-3"></a><span class="kw">let</span> z <span class="op">=</span> x <span class="op">+</span> y<span class="op">;</span></span></code></pre></div>
<p>While compiling this we’ll assign a new, unique number to each identifier we come across. In case we’ve seen the identifier before, we’ll reuse the previously assigned number. How do we generate a new number? We’ll keep it simple and just use increasing numbers, starting with <code>0</code>. In this example, <code>x</code> would be assigned the <code>0</code>, <code>y</code> the <code>1</code> and <code>z</code> would be assigned the <code>2</code>.</p>
<p>We’ll also define the two new opcodes we want and call them <code>OpSetGlobal</code> and <code>OpGetGlobal</code>. Both have one 16-bit-wide operand that holds a number: the unique number we previously assigned to an identifier. When we then compile a let statement we’ll emit an <code>OpSetGlobal</code> instruction to create a binding and when we compile an identifier, we’ll emit an <code>OpGetGlobal</code> instruction to retrieve a value. (16 bits for the operand means we’re limited to a maximum of 65536 global bindings – which should be plenty for us and our Monkey programs).</p>
<p>The three Monkey let statements from above would then look like this in bytecode:</p>
<!-- ./ascii_drawings/05/global_bindings_bytecode.monopic -->
<figure>
<img src="./images/05/global_bindings_bytecode.svg" style="width:60.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>That’s the compiler side of things. In the VM we’ll use a slice to implement the creation and retrieval of global bindings. We’ll call this slice our “globals store” and we’ll use the operands of the <code>OpSetGlobal</code> and <code>OpGetGlobal</code> instructions as indexes into it.</p>
<p>When we execute an <code>OpSetGlobal</code> instruction, we’ll read in the operand, pop the topmost value off the stack and save it to the globals store at the index encoded in the operand. To execute an <code>OpGetGlobal</code> instruction we’ll use the operand to retrieve the value from the globals store and push it on to the stack.</p>
<p>Two new opcodes called <code>OpGetGlobal</code> and <code>OpSetGlobal</code>, a mechanism to associate identifiers with numbers while compiling, and a globals store in the VM. Sounds doable, when broken down like this, right?</p>
<p>Of course, things get more complicated once we introduce functions and local variables, but that’s a bridge we’ll cross once we get there. For now, let’s head on over to our compiler.</p>
<h2 id="compiling-bindings">Compiling Bindings</h2>
<p>First up is the definition of the two new opcodes, <code>OpSetGlobal</code> and <code>OpGetGlobal</code>:</p>
<div class="sourceCode" id="cb193"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb193-1"><a href="#cb193-1"></a><span class="co">// code/code.go</span></span>
<span id="cb193-2"><a href="#cb193-2"></a></span>
<span id="cb193-3"><a href="#cb193-3"></a><span class="kw">const</span> (</span>
<span id="cb193-4"><a href="#cb193-4"></a>    <span class="co">// [...]</span></span>
<span id="cb193-5"><a href="#cb193-5"></a></span>
<span id="cb193-6"><a href="#cb193-6"></a>    OpGetGlobal</span>
<span id="cb193-7"><a href="#cb193-7"></a>    OpSetGlobal</span>
<span id="cb193-8"><a href="#cb193-8"></a>)</span>
<span id="cb193-9"><a href="#cb193-9"></a></span>
<span id="cb193-10"><a href="#cb193-10"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb193-11"><a href="#cb193-11"></a>    <span class="co">// [...]</span></span>
<span id="cb193-12"><a href="#cb193-12"></a></span>
<span id="cb193-13"><a href="#cb193-13"></a>    OpGetGlobal: {<span class="st">&quot;OpGetGlobal&quot;</span>, []<span class="dt">int</span>{<span class="dv">2</span>}},</span>
<span id="cb193-14"><a href="#cb193-14"></a>    OpSetGlobal: {<span class="st">&quot;OpSetGlobal&quot;</span>, []<span class="dt">int</span>{<span class="dv">2</span>}},</span>
<span id="cb193-15"><a href="#cb193-15"></a>}</span></code></pre></div>
<p>Both have a single two-byte operand to hold the unique number of a global binding. Just like we discussed. We can move along and use these new opcodes to write a first compiler test:</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb194-1"><a href="#cb194-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb194-2"><a href="#cb194-2"></a></span>
<span id="cb194-3"><a href="#cb194-3"></a><span class="kw">func</span> TestGlobalLetStatements(t *testing.T) {</span>
<span id="cb194-4"><a href="#cb194-4"></a>    tests := []compilerTestCase{</span>
<span id="cb194-5"><a href="#cb194-5"></a>        {</span>
<span id="cb194-6"><a href="#cb194-6"></a>            input: <span class="st">`</span></span>
<span id="cb194-7"><a href="#cb194-7"></a><span class="st">            let one = 1;</span></span>
<span id="cb194-8"><a href="#cb194-8"></a><span class="st">            let two = 2;</span></span>
<span id="cb194-9"><a href="#cb194-9"></a><span class="st">            `</span>,</span>
<span id="cb194-10"><a href="#cb194-10"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">1</span>, <span class="dv">2</span>},</span>
<span id="cb194-11"><a href="#cb194-11"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb194-12"><a href="#cb194-12"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb194-13"><a href="#cb194-13"></a>                code.Make(code.OpSetGlobal, <span class="dv">0</span>),</span>
<span id="cb194-14"><a href="#cb194-14"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb194-15"><a href="#cb194-15"></a>                code.Make(code.OpSetGlobal, <span class="dv">1</span>),</span>
<span id="cb194-16"><a href="#cb194-16"></a>            },</span>
<span id="cb194-17"><a href="#cb194-17"></a>        },</span>
<span id="cb194-18"><a href="#cb194-18"></a>        {</span>
<span id="cb194-19"><a href="#cb194-19"></a>            input: <span class="st">`</span></span>
<span id="cb194-20"><a href="#cb194-20"></a><span class="st">            let one = 1;</span></span>
<span id="cb194-21"><a href="#cb194-21"></a><span class="st">            one;</span></span>
<span id="cb194-22"><a href="#cb194-22"></a><span class="st">            `</span>,</span>
<span id="cb194-23"><a href="#cb194-23"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">1</span>},</span>
<span id="cb194-24"><a href="#cb194-24"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb194-25"><a href="#cb194-25"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb194-26"><a href="#cb194-26"></a>                code.Make(code.OpSetGlobal, <span class="dv">0</span>),</span>
<span id="cb194-27"><a href="#cb194-27"></a>                code.Make(code.OpGetGlobal, <span class="dv">0</span>),</span>
<span id="cb194-28"><a href="#cb194-28"></a>                code.Make(code.OpPop),</span>
<span id="cb194-29"><a href="#cb194-29"></a>            },</span>
<span id="cb194-30"><a href="#cb194-30"></a>        },</span>
<span id="cb194-31"><a href="#cb194-31"></a>        {</span>
<span id="cb194-32"><a href="#cb194-32"></a>            input: <span class="st">`</span></span>
<span id="cb194-33"><a href="#cb194-33"></a><span class="st">            let one = 1;</span></span>
<span id="cb194-34"><a href="#cb194-34"></a><span class="st">            let two = one;</span></span>
<span id="cb194-35"><a href="#cb194-35"></a><span class="st">            two;</span></span>
<span id="cb194-36"><a href="#cb194-36"></a><span class="st">            `</span>,</span>
<span id="cb194-37"><a href="#cb194-37"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">1</span>},</span>
<span id="cb194-38"><a href="#cb194-38"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb194-39"><a href="#cb194-39"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb194-40"><a href="#cb194-40"></a>                code.Make(code.OpSetGlobal, <span class="dv">0</span>),</span>
<span id="cb194-41"><a href="#cb194-41"></a>                code.Make(code.OpGetGlobal, <span class="dv">0</span>),</span>
<span id="cb194-42"><a href="#cb194-42"></a>                code.Make(code.OpSetGlobal, <span class="dv">1</span>),</span>
<span id="cb194-43"><a href="#cb194-43"></a>                code.Make(code.OpGetGlobal, <span class="dv">1</span>),</span>
<span id="cb194-44"><a href="#cb194-44"></a>                code.Make(code.OpPop),</span>
<span id="cb194-45"><a href="#cb194-45"></a>            },</span>
<span id="cb194-46"><a href="#cb194-46"></a>        },</span>
<span id="cb194-47"><a href="#cb194-47"></a>    }</span>
<span id="cb194-48"><a href="#cb194-48"></a></span>
<span id="cb194-49"><a href="#cb194-49"></a>    runCompilerTests(t, tests)</span>
<span id="cb194-50"><a href="#cb194-50"></a>}</span></code></pre></div>
<p>Same test setup as before, so let’s talk about <em>what</em> we test in these three test cases. The first one makes sure that a let statement leads to the correct <code>OpSetGlobal</code> instruction being emitted. The second one expects that an identifier resolves to a previous binding by testing for the <code>OpGetGlobal</code> instruction. Note here that the operands of the <code>OpSetGlobal</code> and <code>OpGetGlobal</code> instructions have to match. The third test case asserts that combining the setting and getting of global bindings works, too. Here, too, it’s important that the operands of the instructions match.</p>
<p>We’re going to fix these test cases one after the other, starting with the first one, which isn’t doing so well:</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb195-1"><a href="#cb195-1"></a>$ go test ./compiler</span>
<span id="cb195-2"><a href="#cb195-2"></a>--- FAIL: TestGlobalLetStatements (0.00s)</span>
<span id="cb195-3"><a href="#cb195-3"></a> compiler_test.go:361: testInstructions failed: wrong instructions length.</span>
<span id="cb195-4"><a href="#cb195-4"></a>  want=&quot;0000 OpConstant 0\n0003 OpSetGlobal 0\n0006 OpConstant 1\n\</span>
<span id="cb195-5"><a href="#cb195-5"></a>    0009 OpSetGlobal 1\n&quot;</span>
<span id="cb195-6"><a href="#cb195-6"></a>  got =&quot;&quot;</span>
<span id="cb195-7"><a href="#cb195-7"></a>FAIL</span>
<span id="cb195-8"><a href="#cb195-8"></a>FAIL    monkey/compiler 0.009s</span></code></pre></div>
<p>Looks like we’re not even close. But the reason for the empty result is that Monkey code consists solely of let statements and our compiler currently skips them. We can get better feedback from the test by adding a new <code>case</code> branch to the compiler’s <code>Compile</code> method:</p>
<div class="sourceCode" id="cb196"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb196-1"><a href="#cb196-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb196-2"><a href="#cb196-2"></a></span>
<span id="cb196-3"><a href="#cb196-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb196-4"><a href="#cb196-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb196-5"><a href="#cb196-5"></a>    <span class="co">// [...]</span></span>
<span id="cb196-6"><a href="#cb196-6"></a></span>
<span id="cb196-7"><a href="#cb196-7"></a>    <span class="kw">case</span> *ast.LetStatement:</span>
<span id="cb196-8"><a href="#cb196-8"></a>        err := c.Compile(node.Value)</span>
<span id="cb196-9"><a href="#cb196-9"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb196-10"><a href="#cb196-10"></a>            <span class="kw">return</span> err</span>
<span id="cb196-11"><a href="#cb196-11"></a>        }</span>
<span id="cb196-12"><a href="#cb196-12"></a></span>
<span id="cb196-13"><a href="#cb196-13"></a>    <span class="co">// [...]</span></span>
<span id="cb196-14"><a href="#cb196-14"></a>    }</span>
<span id="cb196-15"><a href="#cb196-15"></a></span>
<span id="cb196-16"><a href="#cb196-16"></a>    <span class="co">// [...]</span></span>
<span id="cb196-17"><a href="#cb196-17"></a>}</span></code></pre></div>
<p>The first thing we do when we come across a let statement is to compile the expression on the right side of the equal sign. That’s the <code>Value</code> that will be bound to a name and compiling this expression means instructing the VM to put the value on to the stack:</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb197-1"><a href="#cb197-1"></a>$ go test ./compiler</span>
<span id="cb197-2"><a href="#cb197-2"></a>--- FAIL: TestGlobalLetStatements (0.00s)</span>
<span id="cb197-3"><a href="#cb197-3"></a> compiler_test.go:361: testInstructions failed: wrong instructions length.</span>
<span id="cb197-4"><a href="#cb197-4"></a>  want=&quot;0000 OpConstant 0\n0003 OpSetGlobal 0\n0006 OpConstant 1\n\</span>
<span id="cb197-5"><a href="#cb197-5"></a>    0009 OpSetGlobal 1\n&quot;</span>
<span id="cb197-6"><a href="#cb197-6"></a>  got =&quot;0000 OpConstant 0\n0003 OpConstant 1\n&quot;</span>
<span id="cb197-7"><a href="#cb197-7"></a>FAIL</span>
<span id="cb197-8"><a href="#cb197-8"></a>FAIL    monkey/compiler 0.009s</span></code></pre></div>
<p>Now we can bind it to a name. That means we need to follow up with an <code>OpSetGlobal</code> instruction that tells the VM to create the binding. But which number do we choose for our identifier? The answer comes from a new component we’re going to add to our compiler, a symbol table.</p>
<h3 id="introducing-the-symbol-table">Introducing: the Symbol Table</h3>
<p>A <a href="https://en.wikipedia.org/wiki/Symbol_table">symbol table</a> is a data structure used in interpreters and compilers to associate identifiers with information. It can be used in every phase, from lexing to code generation, to store and retrieve information about a given identifier (which can be called a symbol). Information such as its location, its scope, whether it was previously declared or not, of which type the associated value is, and anything else that seems useful while interpreting or compiling.</p>
<p>We’re going to use as symbol table to associate identifiers with a scope and a unique number. For now, it should do two things:</p>
<ol type="1">
<li>Associate identifiers in the global scope with a unique number</li>
<li>Get the previously associated number for a given identifier</li>
</ol>
<p>The common names for these two methods on a symbol table are “define” and “resolve”. You “define” an identifier in a given scope to associate some information with it. Later you “resolve” the identifier to this information. The information itself we’ll call the “symbol” – an identifier is associated with a symbol and the symbol itself is what contains information.</p>
<p>Working code helps to explain this. Here are the type definitions that make up our symbol table:</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb198-1"><a href="#cb198-1"></a><span class="co">// compiler/symbol_table.go</span></span>
<span id="cb198-2"><a href="#cb198-2"></a></span>
<span id="cb198-3"><a href="#cb198-3"></a><span class="kw">package</span> compiler</span>
<span id="cb198-4"><a href="#cb198-4"></a></span>
<span id="cb198-5"><a href="#cb198-5"></a><span class="kw">type</span> SymbolScope <span class="dt">string</span></span>
<span id="cb198-6"><a href="#cb198-6"></a></span>
<span id="cb198-7"><a href="#cb198-7"></a><span class="kw">const</span> (</span>
<span id="cb198-8"><a href="#cb198-8"></a>    GlobalScope SymbolScope = <span class="st">&quot;GLOBAL&quot;</span></span>
<span id="cb198-9"><a href="#cb198-9"></a>)</span>
<span id="cb198-10"><a href="#cb198-10"></a></span>
<span id="cb198-11"><a href="#cb198-11"></a><span class="kw">type</span> Symbol <span class="kw">struct</span> {</span>
<span id="cb198-12"><a href="#cb198-12"></a>    Name  <span class="dt">string</span></span>
<span id="cb198-13"><a href="#cb198-13"></a>    Scope SymbolScope</span>
<span id="cb198-14"><a href="#cb198-14"></a>    Index <span class="dt">int</span></span>
<span id="cb198-15"><a href="#cb198-15"></a>}</span>
<span id="cb198-16"><a href="#cb198-16"></a></span>
<span id="cb198-17"><a href="#cb198-17"></a><span class="kw">type</span> SymbolTable <span class="kw">struct</span> {</span>
<span id="cb198-18"><a href="#cb198-18"></a>    store          <span class="kw">map</span>[<span class="dt">string</span>]Symbol</span>
<span id="cb198-19"><a href="#cb198-19"></a>    numDefinitions <span class="dt">int</span></span>
<span id="cb198-20"><a href="#cb198-20"></a>}</span>
<span id="cb198-21"><a href="#cb198-21"></a></span>
<span id="cb198-22"><a href="#cb198-22"></a><span class="kw">func</span> NewSymbolTable() *SymbolTable {</span>
<span id="cb198-23"><a href="#cb198-23"></a>    s := <span class="bu">make</span>(<span class="kw">map</span>[<span class="dt">string</span>]Symbol)</span>
<span id="cb198-24"><a href="#cb198-24"></a>    <span class="kw">return</span> &amp;SymbolTable{store: s}</span>
<span id="cb198-25"><a href="#cb198-25"></a>}</span></code></pre></div>
<p>The first definition here is that of <code>SymbolScope</code>, a type alias for <code>string</code>. The value of a <code>SymbolScope</code> itself is not important. What’s important is that it’s unique, because we need to differentiate between different scopes. We use <code>string</code>s as the aliased type (as opposed to an integer, for example) for a better debugging experience.</p>
<p>We then define our first scope, <code>GlobalScope</code>. In the coming chapters we’ll add more.</p>
<p>The next definition is that of <code>Symbol</code>. A <code>Symbol</code> is a struct that holds all the necessary information about a symbol we encounter in Monkey code: the <code>Name</code>, the <code>Scope</code> and the <code>Index</code>. Not much more to explain here.</p>
<p>The <code>SymbolTable</code> itself then associates <code>string</code>s with <code>Symbol</code>s in its <code>store</code> and keeps track of the <code>numDefinitions</code> it has. The <code>string</code>s are the identifiers we come across in the Monkey code.</p>
<p>The names of the types and fields can feel unfamiliar, if you haven’t used a symbol table before, but worry not: we’re building a <code>map</code> that associates strings with information about them. There is no hidden wisdom or trick you need to wrap your head around. Tests make this much clearer by demonstrating what we expect from the missing <code>Define</code> and <code>Resolve</code> methods of the <code>SymbolTable</code>:</p>
<div class="sourceCode" id="cb199"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb199-1"><a href="#cb199-1"></a><span class="co">// compiler/symbol_table_test.go</span></span>
<span id="cb199-2"><a href="#cb199-2"></a></span>
<span id="cb199-3"><a href="#cb199-3"></a><span class="kw">package</span> compiler</span>
<span id="cb199-4"><a href="#cb199-4"></a></span>
<span id="cb199-5"><a href="#cb199-5"></a><span class="kw">import</span> <span class="st">&quot;testing&quot;</span></span>
<span id="cb199-6"><a href="#cb199-6"></a></span>
<span id="cb199-7"><a href="#cb199-7"></a><span class="kw">func</span> TestDefine(t *testing.T) {</span>
<span id="cb199-8"><a href="#cb199-8"></a>    expected := <span class="kw">map</span>[<span class="dt">string</span>]Symbol{</span>
<span id="cb199-9"><a href="#cb199-9"></a>        <span class="st">&quot;a&quot;</span>: Symbol{Name: <span class="st">&quot;a&quot;</span>, Scope: GlobalScope, Index: <span class="dv">0</span>},</span>
<span id="cb199-10"><a href="#cb199-10"></a>        <span class="st">&quot;b&quot;</span>: Symbol{Name: <span class="st">&quot;b&quot;</span>, Scope: GlobalScope, Index: <span class="dv">1</span>},</span>
<span id="cb199-11"><a href="#cb199-11"></a>    }</span>
<span id="cb199-12"><a href="#cb199-12"></a></span>
<span id="cb199-13"><a href="#cb199-13"></a>    global := NewSymbolTable()</span>
<span id="cb199-14"><a href="#cb199-14"></a></span>
<span id="cb199-15"><a href="#cb199-15"></a>    a := global.Define(<span class="st">&quot;a&quot;</span>)</span>
<span id="cb199-16"><a href="#cb199-16"></a>    <span class="kw">if</span> a != expected[<span class="st">&quot;a&quot;</span>] {</span>
<span id="cb199-17"><a href="#cb199-17"></a>        t.Errorf(<span class="st">&quot;expected a=%+v, got=%+v&quot;</span>, expected[<span class="st">&quot;a&quot;</span>], a)</span>
<span id="cb199-18"><a href="#cb199-18"></a>    }</span>
<span id="cb199-19"><a href="#cb199-19"></a></span>
<span id="cb199-20"><a href="#cb199-20"></a>    b := global.Define(<span class="st">&quot;b&quot;</span>)</span>
<span id="cb199-21"><a href="#cb199-21"></a>    <span class="kw">if</span> b != expected[<span class="st">&quot;b&quot;</span>] {</span>
<span id="cb199-22"><a href="#cb199-22"></a>        t.Errorf(<span class="st">&quot;expected b=%+v, got=%+v&quot;</span>, expected[<span class="st">&quot;b&quot;</span>], b)</span>
<span id="cb199-23"><a href="#cb199-23"></a>    }</span>
<span id="cb199-24"><a href="#cb199-24"></a>}</span>
<span id="cb199-25"><a href="#cb199-25"></a></span>
<span id="cb199-26"><a href="#cb199-26"></a><span class="kw">func</span> TestResolveGlobal(t *testing.T) {</span>
<span id="cb199-27"><a href="#cb199-27"></a>    global := NewSymbolTable()</span>
<span id="cb199-28"><a href="#cb199-28"></a>    global.Define(<span class="st">&quot;a&quot;</span>)</span>
<span id="cb199-29"><a href="#cb199-29"></a>    global.Define(<span class="st">&quot;b&quot;</span>)</span>
<span id="cb199-30"><a href="#cb199-30"></a></span>
<span id="cb199-31"><a href="#cb199-31"></a>    expected := []Symbol{</span>
<span id="cb199-32"><a href="#cb199-32"></a>        Symbol{Name: <span class="st">&quot;a&quot;</span>, Scope: GlobalScope, Index: <span class="dv">0</span>},</span>
<span id="cb199-33"><a href="#cb199-33"></a>        Symbol{Name: <span class="st">&quot;b&quot;</span>, Scope: GlobalScope, Index: <span class="dv">1</span>},</span>
<span id="cb199-34"><a href="#cb199-34"></a>    }</span>
<span id="cb199-35"><a href="#cb199-35"></a></span>
<span id="cb199-36"><a href="#cb199-36"></a>    <span class="kw">for</span> _, sym := <span class="kw">range</span> expected {</span>
<span id="cb199-37"><a href="#cb199-37"></a>        result, ok := global.Resolve(sym.Name)</span>
<span id="cb199-38"><a href="#cb199-38"></a>        <span class="kw">if</span> !ok {</span>
<span id="cb199-39"><a href="#cb199-39"></a>            t.Errorf(<span class="st">&quot;name %s not resolvable&quot;</span>, sym.Name)</span>
<span id="cb199-40"><a href="#cb199-40"></a>            <span class="kw">continue</span></span>
<span id="cb199-41"><a href="#cb199-41"></a>        }</span>
<span id="cb199-42"><a href="#cb199-42"></a>        <span class="kw">if</span> result != sym {</span>
<span id="cb199-43"><a href="#cb199-43"></a>            t.Errorf(<span class="st">&quot;expected %s to resolve to %+v, got=%+v&quot;</span>,</span>
<span id="cb199-44"><a href="#cb199-44"></a>                sym.Name, sym, result)</span>
<span id="cb199-45"><a href="#cb199-45"></a>        }</span>
<span id="cb199-46"><a href="#cb199-46"></a>    }</span>
<span id="cb199-47"><a href="#cb199-47"></a>}</span></code></pre></div>
<p>In <code>TestDefine</code> we make assertions about the <code>Define</code> method. It should take an identifier as argument, create a definition and return the <code>Symbol</code>. Note that we don’t have to say in which scope we want to create the definition. It’s the job of the symbol table to keep track of that for us. We only call <code>Define("a")</code> and the symbol table associates the identifier <code>"a"</code> with a new <code>Symbol</code>, that contains the <code>Name</code>, the <code>Scope</code> and the <code>Index</code>. The <code>Index</code> is the unique number we’re after.</p>
<p>In <code>TestResolveGlobal</code> we do the reverse: we hand the symbol table an identifier that was previously defined and expect it to return the associated <code>Symbol</code>. Again, the only argument is the identifier: <code>Resolve("a")</code>. If the identifier is undefined, the second return value of <code>Resolve</code> has to be <code>false</code>.</p>
<p>The tests don’t compile, because both methods are missing and I’m going to spare you from reading through the results of running the tests repeatedly while adding the method definition step by step. Instead, let me give you the full version of <code>Define</code>:</p>
<div class="sourceCode" id="cb200"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb200-1"><a href="#cb200-1"></a><span class="co">// compiler/symbol_table.go</span></span>
<span id="cb200-2"><a href="#cb200-2"></a></span>
<span id="cb200-3"><a href="#cb200-3"></a><span class="kw">func</span> (s *SymbolTable) Define(name <span class="dt">string</span>) Symbol {</span>
<span id="cb200-4"><a href="#cb200-4"></a>    symbol := Symbol{Name: name, Index: s.numDefinitions, Scope: GlobalScope}</span>
<span id="cb200-5"><a href="#cb200-5"></a>    s.store[name] = symbol</span>
<span id="cb200-6"><a href="#cb200-6"></a>    s.numDefinitions++</span>
<span id="cb200-7"><a href="#cb200-7"></a>    <span class="kw">return</span> symbol</span>
<span id="cb200-8"><a href="#cb200-8"></a>}</span></code></pre></div>
<p>I told you, there’s nothing to worry about; we’re building a <code>map</code> with some additional features. Here’s the evidence. We create a new <code>Symbol</code>, associate it with the <code>name</code> in our <code>store</code>, increase the <code>numDefinitions</code> counter and return the new <code>Symbol</code>. Defined. Done.</p>
<p>The <code>Resolve</code> method is even simpler:</p>
<div class="sourceCode" id="cb201"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb201-1"><a href="#cb201-1"></a><span class="co">// compiler/symbol_table.go</span></span>
<span id="cb201-2"><a href="#cb201-2"></a></span>
<span id="cb201-3"><a href="#cb201-3"></a><span class="kw">func</span> (s *SymbolTable) Resolve(name <span class="dt">string</span>) (Symbol, <span class="dt">bool</span>) {</span>
<span id="cb201-4"><a href="#cb201-4"></a>    obj, ok := s.store[name]</span>
<span id="cb201-5"><a href="#cb201-5"></a>    <span class="kw">return</span> obj, ok</span>
<span id="cb201-6"><a href="#cb201-6"></a>}</span></code></pre></div>
<p>Sadly, this method won’t stay that small. As we add more scopes in the future, it’ll grow, but for now, what it does is enough: both tests pass.</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb202-1"><a href="#cb202-1"></a>$ go test -run TestDefine ./compiler</span>
<span id="cb202-2"><a href="#cb202-2"></a>ok      monkey/compiler 0.008s</span>
<span id="cb202-3"><a href="#cb202-3"></a>$ go test -run TestResolveGlobal ./compiler</span>
<span id="cb202-4"><a href="#cb202-4"></a>ok      monkey/compiler 0.011s</span></code></pre></div>
<h3 id="using-symbols-in-the-compiler">Using Symbols in the Compiler</h3>
<p>We had to selectively run the <code>TestDefine</code> and <code>TestResolveGlobal</code> functions to get an <code>"ok"</code> because our compiler test is still failing. Now though, armed with our symbol table, we can make it pass! First we need to add the symbol table to the compiler:</p>
<div class="sourceCode" id="cb203"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb203-1"><a href="#cb203-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb203-2"><a href="#cb203-2"></a></span>
<span id="cb203-3"><a href="#cb203-3"></a><span class="kw">type</span> Compiler <span class="kw">struct</span> {</span>
<span id="cb203-4"><a href="#cb203-4"></a>    <span class="co">// [...]</span></span>
<span id="cb203-5"><a href="#cb203-5"></a></span>
<span id="cb203-6"><a href="#cb203-6"></a>    symbolTable *SymbolTable</span>
<span id="cb203-7"><a href="#cb203-7"></a>}</span>
<span id="cb203-8"><a href="#cb203-8"></a></span>
<span id="cb203-9"><a href="#cb203-9"></a><span class="kw">func</span> New() *Compiler {</span>
<span id="cb203-10"><a href="#cb203-10"></a>    <span class="kw">return</span> &amp;Compiler{</span>
<span id="cb203-11"><a href="#cb203-11"></a>        <span class="co">// [...]</span></span>
<span id="cb203-12"><a href="#cb203-12"></a>        symbolTable:  NewSymbolTable(),</span>
<span id="cb203-13"><a href="#cb203-13"></a>    }</span>
<span id="cb203-14"><a href="#cb203-14"></a>}</span></code></pre></div>
<p>That allows us to define the identifiers in <code>*ast.LetStatement</code>s:</p>
<div class="sourceCode" id="cb204"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb204-1"><a href="#cb204-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb204-2"><a href="#cb204-2"></a></span>
<span id="cb204-3"><a href="#cb204-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb204-4"><a href="#cb204-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb204-5"><a href="#cb204-5"></a>    <span class="co">// [...]</span></span>
<span id="cb204-6"><a href="#cb204-6"></a></span>
<span id="cb204-7"><a href="#cb204-7"></a>    <span class="kw">case</span> *ast.LetStatement:</span>
<span id="cb204-8"><a href="#cb204-8"></a>        err := c.Compile(node.Value)</span>
<span id="cb204-9"><a href="#cb204-9"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb204-10"><a href="#cb204-10"></a>            <span class="kw">return</span> err</span>
<span id="cb204-11"><a href="#cb204-11"></a>        }</span>
<span id="cb204-12"><a href="#cb204-12"></a>        symbol := c.symbolTable.Define(node.Name.Value)</span>
<span id="cb204-13"><a href="#cb204-13"></a></span>
<span id="cb204-14"><a href="#cb204-14"></a>    <span class="co">// [...]</span></span>
<span id="cb204-15"><a href="#cb204-15"></a>    }</span>
<span id="cb204-16"><a href="#cb204-16"></a></span>
<span id="cb204-17"><a href="#cb204-17"></a>    <span class="co">// [...]</span></span>
<span id="cb204-18"><a href="#cb204-18"></a>}</span></code></pre></div>
<p><code>node.Name</code> is the <code>*ast.Identifier</code> on the left side of the let statement’s equal sign. And <code>node.Name.Value</code> holds the <code>string</code> representation of that identifier. We pass it to the symbol table’s <code>Define</code> method and thus define it in the <code>GlobalScope</code>. The returned <code>symbol</code> now has a <code>Name</code>, a <code>Scope</code> and, most importantly, an <code>Index</code>.</p>
<p>We can now use that <code>Index</code> as operand of a <code>OpSetGlobal</code> instruction and emit that:</p>
<div class="sourceCode" id="cb205"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb205-1"><a href="#cb205-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb205-2"><a href="#cb205-2"></a></span>
<span id="cb205-3"><a href="#cb205-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb205-4"><a href="#cb205-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb205-5"><a href="#cb205-5"></a>    <span class="co">// [...]</span></span>
<span id="cb205-6"><a href="#cb205-6"></a></span>
<span id="cb205-7"><a href="#cb205-7"></a>    <span class="kw">case</span> *ast.LetStatement:</span>
<span id="cb205-8"><a href="#cb205-8"></a>        err := c.Compile(node.Value)</span>
<span id="cb205-9"><a href="#cb205-9"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb205-10"><a href="#cb205-10"></a>            <span class="kw">return</span> err</span>
<span id="cb205-11"><a href="#cb205-11"></a>        }</span>
<span id="cb205-12"><a href="#cb205-12"></a>        symbol := c.symbolTable.Define(node.Name.Value)</span>
<span id="cb205-13"><a href="#cb205-13"></a>        c.emit(code.OpSetGlobal, symbol.Index)</span>
<span id="cb205-14"><a href="#cb205-14"></a></span>
<span id="cb205-15"><a href="#cb205-15"></a>    <span class="co">// [...]</span></span>
<span id="cb205-16"><a href="#cb205-16"></a>    }</span>
<span id="cb205-17"><a href="#cb205-17"></a></span>
<span id="cb205-18"><a href="#cb205-18"></a>    <span class="co">// [...]</span></span>
<span id="cb205-19"><a href="#cb205-19"></a>}</span></code></pre></div>
<p>With that we just took a huge step towards our goal:</p>
<div class="sourceCode" id="cb206"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb206-1"><a href="#cb206-1"></a>$ go test ./compiler</span>
<span id="cb206-2"><a href="#cb206-2"></a>--- FAIL: TestGlobalLetStatements (0.00s)</span>
<span id="cb206-3"><a href="#cb206-3"></a> compiler_test.go:361: testInstructions failed: wrong instructions length.</span>
<span id="cb206-4"><a href="#cb206-4"></a>  want=&quot;0000 OpConstant 0\n0003 OpSetGlobal 0\n0006 OpGetGlobal 0\n\</span>
<span id="cb206-5"><a href="#cb206-5"></a>    0009 OpPop\n&quot;</span>
<span id="cb206-6"><a href="#cb206-6"></a>  got =&quot;0000 OpConstant 0\n0003 OpSetGlobal 0\n0006 OpPop\n&quot;</span>
<span id="cb206-7"><a href="#cb206-7"></a>FAIL</span>
<span id="cb206-8"><a href="#cb206-8"></a>FAIL    monkey/compiler 0.011s</span></code></pre></div>
<p>Now we’re talki– wait a second! The test is still failing? No, this is the <em>second</em> test case. The first one is passing! What’s failing now is the test case that makes sure <em>resolving a global binding</em> works.</p>
<p>Instead of defining an identifier and emitting an <code>OpSetGlobal</code> instruction we now have to do the opposite. When we come across an <code>*ast.Identifier</code> we need to check with our symbol table whether the identifier was previously used as part of a let statement and if so, we need to emit an <code>OpGetGlobal</code> instruction with the correct operand. “Correct” here means that the operand holds the same number that was used in the previously emitted <code>OpSetGlobal</code> instruction. We can manage that, can’t we?</p>
<p>First we have to tell the compiler about <code>*ast.Identifier</code>s. It should try to resolve the identifier at hand with the symbol table:</p>
<div class="sourceCode" id="cb207"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb207-1"><a href="#cb207-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb207-2"><a href="#cb207-2"></a></span>
<span id="cb207-3"><a href="#cb207-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb207-4"><a href="#cb207-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb207-5"><a href="#cb207-5"></a>    <span class="co">// [...]</span></span>
<span id="cb207-6"><a href="#cb207-6"></a></span>
<span id="cb207-7"><a href="#cb207-7"></a>    <span class="kw">case</span> *ast.Identifier:</span>
<span id="cb207-8"><a href="#cb207-8"></a>        symbol, ok := c.symbolTable.Resolve(node.Value)</span>
<span id="cb207-9"><a href="#cb207-9"></a>        <span class="kw">if</span> !ok {</span>
<span id="cb207-10"><a href="#cb207-10"></a>            <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;undefined variable %s&quot;</span>, node.Value)</span>
<span id="cb207-11"><a href="#cb207-11"></a>        }</span>
<span id="cb207-12"><a href="#cb207-12"></a></span>
<span id="cb207-13"><a href="#cb207-13"></a>    <span class="co">// [...]</span></span>
<span id="cb207-14"><a href="#cb207-14"></a>    }</span>
<span id="cb207-15"><a href="#cb207-15"></a></span>
<span id="cb207-16"><a href="#cb207-16"></a>    <span class="co">// [...]</span></span>
<span id="cb207-17"><a href="#cb207-17"></a>}</span></code></pre></div>
<p>We take the <code>Value</code> of the <code>*ast.Identifier</code> and ask the symbol table whether it can <code>Resolve</code> it. If not, we return an error. Looks just like any other <code>map</code> access in Go, doesn’t it? But I want you to note that this is a <em>compile time error</em>! Previously, in our evaluator, we could only determine whether a variable was defined or not at <em>run time</em>, while executing the Monkey program. Now we can throw an error before we pass bytecode to the VM. Pretty cool, isn’t it?</p>
<p>In case the identifier can be resolved we have the <code>symbol</code> at hand and can use it to emit the <code>OpGetGlobal</code> instruction:</p>
<div class="sourceCode" id="cb208"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb208-1"><a href="#cb208-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb208-2"><a href="#cb208-2"></a></span>
<span id="cb208-3"><a href="#cb208-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb208-4"><a href="#cb208-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb208-5"><a href="#cb208-5"></a>    <span class="co">// [...]</span></span>
<span id="cb208-6"><a href="#cb208-6"></a></span>
<span id="cb208-7"><a href="#cb208-7"></a>    <span class="kw">case</span> *ast.Identifier:</span>
<span id="cb208-8"><a href="#cb208-8"></a>        symbol, ok := c.symbolTable.Resolve(node.Value)</span>
<span id="cb208-9"><a href="#cb208-9"></a>        <span class="kw">if</span> !ok {</span>
<span id="cb208-10"><a href="#cb208-10"></a>            <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;undefined variable %s&quot;</span>, node.Value)</span>
<span id="cb208-11"><a href="#cb208-11"></a>        }</span>
<span id="cb208-12"><a href="#cb208-12"></a></span>
<span id="cb208-13"><a href="#cb208-13"></a>        c.emit(code.OpGetGlobal, symbol.Index)</span>
<span id="cb208-14"><a href="#cb208-14"></a></span>
<span id="cb208-15"><a href="#cb208-15"></a>    <span class="co">// [...]</span></span>
<span id="cb208-16"><a href="#cb208-16"></a>    }</span>
<span id="cb208-17"><a href="#cb208-17"></a></span>
<span id="cb208-18"><a href="#cb208-18"></a>    <span class="co">// [...]</span></span>
<span id="cb208-19"><a href="#cb208-19"></a>}</span></code></pre></div>
<p>The operand matches the one used in the <code>OpSetGlobal</code> instruction, the <code>Index</code> associated with the <code>symbol</code>. Our symbol table took care of that. That means the VM does not have to worry about identifiers at all but can just concentrate on storing and retrieving values using this <code>Index</code>. In other words:</p>
<div class="sourceCode" id="cb209"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb209-1"><a href="#cb209-1"></a>$ go test ./compiler</span>
<span id="cb209-2"><a href="#cb209-2"></a>ok      monkey/compiler 0.008s</span></code></pre></div>
<p>We did it! We can now use let statements to bind values to an identifier and later use the identifier to get to that value – at least in our compiler.</p>
<h2 id="adding-globals-to-the-vm">Adding Globals to the VM</h2>
<p>Let me be upfront about this and say that the hardest part is over. We’ve added support for the <code>OpSetGlobal</code> and <code>OpGetGlobal</code> instructions to our compiler and doing the same for VM takes far less effort. It’s fun, though, because writing tests for the VM and making them pass is fun:</p>
<div class="sourceCode" id="cb210"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb210-1"><a href="#cb210-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb210-2"><a href="#cb210-2"></a></span>
<span id="cb210-3"><a href="#cb210-3"></a><span class="kw">func</span> TestGlobalLetStatements(t *testing.T) {</span>
<span id="cb210-4"><a href="#cb210-4"></a>    tests := []vmTestCase{</span>
<span id="cb210-5"><a href="#cb210-5"></a>        {<span class="st">&quot;let one = 1; one&quot;</span>, <span class="dv">1</span>},</span>
<span id="cb210-6"><a href="#cb210-6"></a>        {<span class="st">&quot;let one = 1; let two = 2; one + two&quot;</span>, <span class="dv">3</span>},</span>
<span id="cb210-7"><a href="#cb210-7"></a>        {<span class="st">&quot;let one = 1; let two = one + one; one + two&quot;</span>, <span class="dv">3</span>},</span>
<span id="cb210-8"><a href="#cb210-8"></a>    }</span>
<span id="cb210-9"><a href="#cb210-9"></a></span>
<span id="cb210-10"><a href="#cb210-10"></a>    runVmTests(t, tests)</span>
<span id="cb210-11"><a href="#cb210-11"></a>}</span></code></pre></div>
<p>In these test cases we create one or two global bindings and then try to resolve the previously bound identifiers to their values. The result should land on the stack, where we can test for it. Alas, it blows up in our face:</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb211-1"><a href="#cb211-1"></a>$ go test ./vm</span>
<span id="cb211-2"><a href="#cb211-2"></a>--- FAIL: TestGlobalLetStatements (0.00s)</span>
<span id="cb211-3"><a href="#cb211-3"></a>panic: runtime error: index out of range [recovered]</span>
<span id="cb211-4"><a href="#cb211-4"></a> panic: runtime error: index out of range</span>
<span id="cb211-5"><a href="#cb211-5"></a></span>
<span id="cb211-6"><a href="#cb211-6"></a>goroutine 21 [running]:</span>
<span id="cb211-7"><a href="#cb211-7"></a>testing.tRunner.func1(0xc4200c83c0)</span>
<span id="cb211-8"><a href="#cb211-8"></a> /usr/local/go/src/testing/testing.go:742 +0x29d</span>
<span id="cb211-9"><a href="#cb211-9"></a>panic(0x111a5a0, 0x11f3fe0)</span>
<span id="cb211-10"><a href="#cb211-10"></a> /usr/local/go/src/runtime/panic.go:502 +0x229</span>
<span id="cb211-11"><a href="#cb211-11"></a>monkey/vm.(*VM).Run(0xc420050eb8, 0x800, 0x800)</span>
<span id="cb211-12"><a href="#cb211-12"></a> /Users/mrnugget/code/05/src/monkey/vm/vm.go:47 +0x47c</span>
<span id="cb211-13"><a href="#cb211-13"></a>monkey/vm.runVmTests(0xc4200c83c0, 0xc420073f38, 0x3, 0x3)</span>
<span id="cb211-14"><a href="#cb211-14"></a> /Users/mrnugget/code/05/src/monkey/vm/vm_test.go:115 +0x3c1</span>
<span id="cb211-15"><a href="#cb211-15"></a>monkey/vm.TestGlobalLetStatements(0xc4200c83c0)</span>
<span id="cb211-16"><a href="#cb211-16"></a> /Users/mrnugget/code/05/src/monkey/vm/vm_test.go:94 +0xb5</span>
<span id="cb211-17"><a href="#cb211-17"></a>testing.tRunner(0xc4200c83c0, 0x114b5b8)</span>
<span id="cb211-18"><a href="#cb211-18"></a> /usr/local/go/src/testing/testing.go:777 +0xd0</span>
<span id="cb211-19"><a href="#cb211-19"></a>created by testing.(*T).Run</span>
<span id="cb211-20"><a href="#cb211-20"></a> /usr/local/go/src/testing/testing.go:824 +0x2e0</span>
<span id="cb211-21"><a href="#cb211-21"></a>FAIL    monkey/vm   0.011s</span></code></pre></div>
<p>We’ve seen this before. The VM doesn’t know how to handle the new opcodes and skips them. But since it doesn’t know how far it has to skip in order to jump over the operands, it ends up trying to decode the operands as opcodes. That leads to this nonsense here.</p>
<p>Before we clean that up, though, and properly decode and execute <code>OpSetGlobal</code> and <code>OpGetGlobal</code> instructions, we need a place to store globals.</p>
<p>Since the operand of both opcodes is 16 bits wide, we have an upper limit on the number of global bindings our VM can support. That’s good, because a limit allows us to pre-allocate all the memory we will use:</p>
<div class="sourceCode" id="cb212"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb212-1"><a href="#cb212-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb212-2"><a href="#cb212-2"></a></span>
<span id="cb212-3"><a href="#cb212-3"></a><span class="kw">const</span> GlobalsSize = <span class="dv">65536</span></span>
<span id="cb212-4"><a href="#cb212-4"></a></span>
<span id="cb212-5"><a href="#cb212-5"></a><span class="kw">type</span> VM <span class="kw">struct</span> {</span>
<span id="cb212-6"><a href="#cb212-6"></a><span class="co">// [...]</span></span>
<span id="cb212-7"><a href="#cb212-7"></a></span>
<span id="cb212-8"><a href="#cb212-8"></a>    globals []object.Object</span>
<span id="cb212-9"><a href="#cb212-9"></a>}</span>
<span id="cb212-10"><a href="#cb212-10"></a></span>
<span id="cb212-11"><a href="#cb212-11"></a><span class="kw">func</span> New(bytecode *compiler.Bytecode) *VM {</span>
<span id="cb212-12"><a href="#cb212-12"></a>    <span class="kw">return</span> &amp;VM{</span>
<span id="cb212-13"><a href="#cb212-13"></a><span class="co">// [...]</span></span>
<span id="cb212-14"><a href="#cb212-14"></a></span>
<span id="cb212-15"><a href="#cb212-15"></a>        globals: <span class="bu">make</span>([]object.Object, GlobalsSize),</span>
<span id="cb212-16"><a href="#cb212-16"></a>    }</span>
<span id="cb212-17"><a href="#cb212-17"></a>}</span></code></pre></div>
<p>This new <code>globals</code> field of <code>VM</code> is the “globals store”. We use a slice as the underlying data structure, because it gives us direct index-based access to single elements without any overhead.</p>
<p>Now we can implement <code>OpSetGlobal</code>:</p>
<div class="sourceCode" id="cb213"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb213-1"><a href="#cb213-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb213-2"><a href="#cb213-2"></a></span>
<span id="cb213-3"><a href="#cb213-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb213-4"><a href="#cb213-4"></a>    <span class="co">// [...]</span></span>
<span id="cb213-5"><a href="#cb213-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb213-6"><a href="#cb213-6"></a>        <span class="co">// [...]</span></span>
<span id="cb213-7"><a href="#cb213-7"></a></span>
<span id="cb213-8"><a href="#cb213-8"></a>        <span class="kw">case</span> code.OpSetGlobal:</span>
<span id="cb213-9"><a href="#cb213-9"></a>            globalIndex := code.ReadUint16(vm.instructions[ip+<span class="dv">1</span>:])</span>
<span id="cb213-10"><a href="#cb213-10"></a>            ip += <span class="dv">2</span></span>
<span id="cb213-11"><a href="#cb213-11"></a></span>
<span id="cb213-12"><a href="#cb213-12"></a>            vm.globals[globalIndex] = vm.pop()</span>
<span id="cb213-13"><a href="#cb213-13"></a></span>
<span id="cb213-14"><a href="#cb213-14"></a>        <span class="co">// [...]</span></span>
<span id="cb213-15"><a href="#cb213-15"></a>        }</span>
<span id="cb213-16"><a href="#cb213-16"></a>    <span class="co">// [...]</span></span>
<span id="cb213-17"><a href="#cb213-17"></a>}</span></code></pre></div>
<p>The first thing we do is decode the operand, <code>globalIndex</code>, and increment the VM’s instruction pointer, <code>ip</code>, by two bytes. Then we <code>pop</code> the top element off the stack, which is the value that should be bound to a name, and save it to the new <code>globals</code> store under the specified index. There it’s easy to retrieve when we need to push it on to the stack again:</p>
<div class="sourceCode" id="cb214"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb214-1"><a href="#cb214-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb214-2"><a href="#cb214-2"></a></span>
<span id="cb214-3"><a href="#cb214-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb214-4"><a href="#cb214-4"></a>    <span class="co">// [...]</span></span>
<span id="cb214-5"><a href="#cb214-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb214-6"><a href="#cb214-6"></a>        <span class="co">// [...]</span></span>
<span id="cb214-7"><a href="#cb214-7"></a></span>
<span id="cb214-8"><a href="#cb214-8"></a>        <span class="kw">case</span> code.OpGetGlobal:</span>
<span id="cb214-9"><a href="#cb214-9"></a>            globalIndex := code.ReadUint16(vm.instructions[ip+<span class="dv">1</span>:])</span>
<span id="cb214-10"><a href="#cb214-10"></a>            ip += <span class="dv">2</span></span>
<span id="cb214-11"><a href="#cb214-11"></a></span>
<span id="cb214-12"><a href="#cb214-12"></a>            err := vm.push(vm.globals[globalIndex])</span>
<span id="cb214-13"><a href="#cb214-13"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb214-14"><a href="#cb214-14"></a>                <span class="kw">return</span> err</span>
<span id="cb214-15"><a href="#cb214-15"></a>            }</span>
<span id="cb214-16"><a href="#cb214-16"></a></span>
<span id="cb214-17"><a href="#cb214-17"></a>        <span class="co">// [...]</span></span>
<span id="cb214-18"><a href="#cb214-18"></a>        }</span>
<span id="cb214-19"><a href="#cb214-19"></a>    <span class="co">// [...]</span></span>
<span id="cb214-20"><a href="#cb214-20"></a>}</span></code></pre></div>
<p>Again, we decode the operand, <code>globalIndex</code>, and increment the <code>ip</code>. Then we fetch the value from <code>vm.globals</code> and push it back on to the stack. Gone is the panic:</p>
<div class="sourceCode" id="cb215"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb215-1"><a href="#cb215-1"></a>$ go test ./vm</span>
<span id="cb215-2"><a href="#cb215-2"></a>ok      monkey/vm   0.030s</span></code></pre></div>
<p>Instead, we get an enthusiastic <code>"ok"</code> to let us know us that we successfully taught our compiler and our VM to handle global let statements. Look at this:</p>
<div class="sourceCode" id="cb216"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb216-1"><a href="#cb216-1"></a>$ go build -o monkey . &amp;&amp; ./monkey</span>
<span id="cb216-2"><a href="#cb216-2"></a>Hello mrnugget! This is the Monkey programming language!</span>
<span id="cb216-3"><a href="#cb216-3"></a>Feel free to type in commands</span>
<span id="cb216-4"><a href="#cb216-4"></a>&gt;&gt; let a = 1;</span>
<span id="cb216-5"><a href="#cb216-5"></a>1</span>
<span id="cb216-6"><a href="#cb216-6"></a>&gt;&gt; let b = 2;</span>
<span id="cb216-7"><a href="#cb216-7"></a>2</span>
<span id="cb216-8"><a href="#cb216-8"></a>&gt;&gt; let c = a + b;</span>
<span id="cb216-9"><a href="#cb216-9"></a>Woops! Compilation failed:</span>
<span id="cb216-10"><a href="#cb216-10"></a> undefined variable a</span>
<span id="cb216-11"><a href="#cb216-11"></a>&gt;&gt;</span></code></pre></div>
<p>What? This is tested behaviour, why doesn’t it work in the REPL? Ah! Of course! In our REPL we create a new compiler and a new VM in <em>each iteration of its main loop</em>. That means we also create a new symbol table and a new globals store every time we type a new line. Easy to fix.</p>
<p>All we need are new constructor functions for our compiler and VM that allow us to keep global state in the REPL:</p>
<div class="sourceCode" id="cb217"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb217-1"><a href="#cb217-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb217-2"><a href="#cb217-2"></a></span>
<span id="cb217-3"><a href="#cb217-3"></a><span class="kw">func</span> NewWithState(s *SymbolTable, constants []object.Object) *Compiler {</span>
<span id="cb217-4"><a href="#cb217-4"></a>    compiler := New()</span>
<span id="cb217-5"><a href="#cb217-5"></a>    compiler.symbolTable = s</span>
<span id="cb217-6"><a href="#cb217-6"></a>    compiler.constants = constants</span>
<span id="cb217-7"><a href="#cb217-7"></a>    <span class="kw">return</span> compiler</span>
<span id="cb217-8"><a href="#cb217-8"></a>}</span></code></pre></div>
<p>This new constructor for <code>Compiler</code> now accepts a <code>*SymbolTable</code> and an <code>[]object.Object</code> slice containing the constants of a previous compilation. In order to get out of our current predicament we would only need the <code>*SymbolTable</code>, but soon we’d run into errors where the line that was just typed into the REPL would need to access the constants that were previously entered. This is the correct and future-proof approach.</p>
<p>Yes, we create duplicate allocations. We first call <code>New()</code> in this new constructor and then throw away the symbol table and constants slice it allocated by overwriting them. That’s fine, I think. Especially for our use case, the REPL. It’s not a problem for Go’s GC and when compared to the effort needed to implement it without those allocations, it’s the most efficient approach.</p>
<p>Here is the new constructor for the <code>VM</code>:</p>
<div class="sourceCode" id="cb218"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb218-1"><a href="#cb218-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb218-2"><a href="#cb218-2"></a></span>
<span id="cb218-3"><a href="#cb218-3"></a><span class="kw">func</span> NewWithGlobalsStore(bytecode *compiler.Bytecode, s []object.Object) *VM {</span>
<span id="cb218-4"><a href="#cb218-4"></a>    vm := New(bytecode)</span>
<span id="cb218-5"><a href="#cb218-5"></a>    vm.globals = s</span>
<span id="cb218-6"><a href="#cb218-6"></a>    <span class="kw">return</span> vm</span>
<span id="cb218-7"><a href="#cb218-7"></a>}</span></code></pre></div>
<p>Now we need to modify the main loop of our REPL so it keeps the global state around – the globals store, the symbol table, the constants – and passes it to new instances of the compiler and the VM:</p>
<div class="sourceCode" id="cb219"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb219-1"><a href="#cb219-1"></a><span class="co">// repl/repl.go</span></span>
<span id="cb219-2"><a href="#cb219-2"></a></span>
<span id="cb219-3"><a href="#cb219-3"></a><span class="kw">import</span> (</span>
<span id="cb219-4"><a href="#cb219-4"></a>    <span class="co">// [...]</span></span>
<span id="cb219-5"><a href="#cb219-5"></a>    <span class="st">&quot;monkey/object&quot;</span></span>
<span id="cb219-6"><a href="#cb219-6"></a>    <span class="co">// [...]</span></span>
<span id="cb219-7"><a href="#cb219-7"></a>)</span>
<span id="cb219-8"><a href="#cb219-8"></a></span>
<span id="cb219-9"><a href="#cb219-9"></a><span class="kw">func</span> Start(in io.Reader, out io.Writer) {</span>
<span id="cb219-10"><a href="#cb219-10"></a>    scanner := bufio.NewScanner(in)</span>
<span id="cb219-11"><a href="#cb219-11"></a></span>
<span id="cb219-12"><a href="#cb219-12"></a>    constants := []object.Object{}</span>
<span id="cb219-13"><a href="#cb219-13"></a>    globals := <span class="bu">make</span>([]object.Object, vm.GlobalsSize)</span>
<span id="cb219-14"><a href="#cb219-14"></a>    symbolTable := compiler.NewSymbolTable()</span>
<span id="cb219-15"><a href="#cb219-15"></a></span>
<span id="cb219-16"><a href="#cb219-16"></a>    <span class="kw">for</span> {</span>
<span id="cb219-17"><a href="#cb219-17"></a>        <span class="co">// [...]</span></span>
<span id="cb219-18"><a href="#cb219-18"></a></span>
<span id="cb219-19"><a href="#cb219-19"></a>        comp := compiler.NewWithState(symbolTable, constants)</span>
<span id="cb219-20"><a href="#cb219-20"></a>        err := comp.Compile(program)</span>
<span id="cb219-21"><a href="#cb219-21"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb219-22"><a href="#cb219-22"></a>            fmt.Fprintf(out, <span class="st">&quot;Woops! Compilation failed:</span><span class="ch">\n</span><span class="st"> %s</span><span class="ch">\n</span><span class="st">&quot;</span>, err)</span>
<span id="cb219-23"><a href="#cb219-23"></a>            <span class="kw">continue</span></span>
<span id="cb219-24"><a href="#cb219-24"></a>        }</span>
<span id="cb219-25"><a href="#cb219-25"></a></span>
<span id="cb219-26"><a href="#cb219-26"></a>        code := comp.Bytecode()</span>
<span id="cb219-27"><a href="#cb219-27"></a>        constants = code.Constants</span>
<span id="cb219-28"><a href="#cb219-28"></a></span>
<span id="cb219-29"><a href="#cb219-29"></a>        machine := vm.NewWithGlobalsStore(code, globals)</span>
<span id="cb219-30"><a href="#cb219-30"></a>        <span class="co">// [...]</span></span>
<span id="cb219-31"><a href="#cb219-31"></a>    }</span>
<span id="cb219-32"><a href="#cb219-32"></a>}</span></code></pre></div>
<p>We allocate a slice for <code>constants</code>, a <code>globals</code> store and a <code>symbolTable</code>. Then, in each iteration of the loop, we pass the <code>symbolTable</code> and the <code>constants</code> to the compiler, so it <em>continues</em> its work, rather than beginning anew. After the compiler is done, we update the <code>constants</code> reference. That’s necessary because the compiler uses <code>append</code> internally and our previously allocated <code>constants</code> slice is not what comes out the other end. Since the <code>constants</code> are included in the bytecode, we don’t need to explicitly pass them to the VM’s constructor, but just the <code>globals</code>.</p>
<p>Now we have global state in the REPL, which allows us to treat each line entered into it as a part of one program, even though we start the compilation and execution process every time we hit return. Problem fixed. We can now play around with global bindings in the REPL:</p>
<div class="sourceCode" id="cb220"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb220-1"><a href="#cb220-1"></a>$ go build -o monkey . &amp;&amp; ./monkey</span>
<span id="cb220-2"><a href="#cb220-2"></a>Hello mrnugget! This is the Monkey programming language!</span>
<span id="cb220-3"><a href="#cb220-3"></a>Feel free to type in commands</span>
<span id="cb220-4"><a href="#cb220-4"></a>&gt;&gt; let a = 1;</span>
<span id="cb220-5"><a href="#cb220-5"></a>1</span>
<span id="cb220-6"><a href="#cb220-6"></a>&gt;&gt; let b = 2;</span>
<span id="cb220-7"><a href="#cb220-7"></a>2</span>
<span id="cb220-8"><a href="#cb220-8"></a>&gt;&gt; let c = a + b;</span>
<span id="cb220-9"><a href="#cb220-9"></a>3</span>
<span id="cb220-10"><a href="#cb220-10"></a>&gt;&gt; c</span>
<span id="cb220-11"><a href="#cb220-11"></a>3</span></code></pre></div>
<p>It’s time to lean back and take a big breath, because in the upcoming chapters we’ll build upon and combine everything we’ve done so far. It’s going to be amazing.</p>
<h1 id="string-array-and-hash">String, Array and Hash</h1>
<p>In their current form our compiler and VM only support three of Monkey’s data types: integers, booleans and null. But there are three more: strings, arrays and hashes. We implemented all of them in the previous book and now it’s time for us to also add them to our new Monkey implementation.</p>
<p>That doesn’t mean we have to redo all of what we did in <em>Writing An Interpreter In Go</em>. The object system representations of the data types are still there – <code>object.String</code>, <code>object.Array</code> and <code>object.Hash</code> – and we can reuse them, which means we can concentrate on the novel parts of the implementation.</p>
<p>The goal for this chapter is to add the string, array and hash data types to the compiler and the VM so that, in the end, we can execute this piece of Monkey code:</p>
<div class="sourceCode" id="cb221"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb221-1"><a href="#cb221-1"></a>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>][<span class="dv">1</span>]</span>
<span id="cb221-2"><a href="#cb221-2"></a><span class="co">// =&gt; 2</span></span>
<span id="cb221-3"><a href="#cb221-3"></a></span>
<span id="cb221-4"><a href="#cb221-4"></a>{<span class="st">&quot;one&quot;</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;two&quot;</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span> <span class="st">&quot;three&quot;</span><span class="op">:</span> <span class="dv">3</span>}[<span class="st">&quot;o&quot;</span> <span class="op">+</span> <span class="st">&quot;ne&quot;</span>]</span>
<span id="cb221-5"><a href="#cb221-5"></a><span class="co">// =&gt; 1</span></span></code></pre></div>
<p>As you can see, besides adding support for literals and the data types themselves, we also need to implement string concatenation and the index operator for arrays and hashes to get this snippet working.</p>
<p>We’re going to start by implementing support for <code>object.String</code>.</p>
<h2 id="string">String</h2>
<p>Since the value of string literals doesn’t change between compile and run time, we can treat them as constant expressions. Similar to our implementation of integer literals, we can turn them into <code>*object.String</code> at compile time and add them to the constant pool in <code>compiler.Bytecode</code>.</p>
<p>From integer literals we also know that this doesn’t take more than a handful of lines of code in the compiler. So why not keep things challenging? Instead of only implementing string literals, we’ll also make it a goal for this section to implement string concatenation, which allows us to concatenate two strings with the <code>+</code> operator.</p>
<p>Our first compiler test in this chapter expects both to work:</p>
<div class="sourceCode" id="cb222"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb222-1"><a href="#cb222-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb222-2"><a href="#cb222-2"></a></span>
<span id="cb222-3"><a href="#cb222-3"></a><span class="kw">func</span> TestStringExpressions(t *testing.T) {</span>
<span id="cb222-4"><a href="#cb222-4"></a>    tests := []compilerTestCase{</span>
<span id="cb222-5"><a href="#cb222-5"></a>        {</span>
<span id="cb222-6"><a href="#cb222-6"></a>            input:             <span class="st">`&quot;monkey&quot;`</span>,</span>
<span id="cb222-7"><a href="#cb222-7"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="st">&quot;monkey&quot;</span>},</span>
<span id="cb222-8"><a href="#cb222-8"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb222-9"><a href="#cb222-9"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb222-10"><a href="#cb222-10"></a>                code.Make(code.OpPop),</span>
<span id="cb222-11"><a href="#cb222-11"></a>            },</span>
<span id="cb222-12"><a href="#cb222-12"></a>        },</span>
<span id="cb222-13"><a href="#cb222-13"></a>        {</span>
<span id="cb222-14"><a href="#cb222-14"></a>            input:             <span class="st">`&quot;mon&quot; + &quot;key&quot;`</span>,</span>
<span id="cb222-15"><a href="#cb222-15"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="st">&quot;mon&quot;</span>, <span class="st">&quot;key&quot;</span>},</span>
<span id="cb222-16"><a href="#cb222-16"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb222-17"><a href="#cb222-17"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb222-18"><a href="#cb222-18"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb222-19"><a href="#cb222-19"></a>                code.Make(code.OpAdd),</span>
<span id="cb222-20"><a href="#cb222-20"></a>                code.Make(code.OpPop),</span>
<span id="cb222-21"><a href="#cb222-21"></a>            },</span>
<span id="cb222-22"><a href="#cb222-22"></a>        },</span>
<span id="cb222-23"><a href="#cb222-23"></a>    }</span>
<span id="cb222-24"><a href="#cb222-24"></a></span>
<span id="cb222-25"><a href="#cb222-25"></a>    runCompilerTests(t, tests)</span>
<span id="cb222-26"><a href="#cb222-26"></a>}</span></code></pre></div>
<p>The first of these two test cases makes sure that the compiler knows how to treat string literals as constants; the second test asserts that it’s possible to concatenate them with the <code>+</code> infix operator.</p>
<p>Of note is that we do not expect any new opcodes. We already have those we need in place: we have an opcode to load a constant expression on to the stack, <code>OpConstant</code>, and we have an opcode to add two things together: <code>OpAdd</code>.</p>
<p>The usage of both opcodes is also unchanged. The operand of <code>OpConstant</code> is still the index of the constant in the constant pool and <code>OpAdd</code> still expects its two operands to sit on top of the stack – it doesn’t matter if those are <code>*object.Integer</code>s or <code>*object.String</code>s.</p>
<p>What’s new is that we now expect strings in the constant pool. That means we need to test that the <code>bytecode.Constants</code> contains the correct <code>*object.String</code>s and in order to do that, we need to add another <code>case</code> branch to the <code>testConstants</code> function:</p>
<div class="sourceCode" id="cb223"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb223-1"><a href="#cb223-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb223-2"><a href="#cb223-2"></a></span>
<span id="cb223-3"><a href="#cb223-3"></a><span class="kw">func</span> testConstants(</span>
<span id="cb223-4"><a href="#cb223-4"></a>    t *testing.T,</span>
<span id="cb223-5"><a href="#cb223-5"></a>    expected []<span class="kw">interface</span>{},</span>
<span id="cb223-6"><a href="#cb223-6"></a>    actual []object.Object,</span>
<span id="cb223-7"><a href="#cb223-7"></a>) <span class="dt">error</span> {</span>
<span id="cb223-8"><a href="#cb223-8"></a>    <span class="co">// [...]</span></span>
<span id="cb223-9"><a href="#cb223-9"></a></span>
<span id="cb223-10"><a href="#cb223-10"></a>    <span class="kw">for</span> i, constant := <span class="kw">range</span> expected {</span>
<span id="cb223-11"><a href="#cb223-11"></a>        <span class="kw">switch</span> constant := constant.(<span class="kw">type</span>) {</span>
<span id="cb223-12"><a href="#cb223-12"></a>        <span class="co">// [...]</span></span>
<span id="cb223-13"><a href="#cb223-13"></a></span>
<span id="cb223-14"><a href="#cb223-14"></a>        <span class="kw">case</span> <span class="dt">string</span>:</span>
<span id="cb223-15"><a href="#cb223-15"></a>            err := testStringObject(constant, actual[i])</span>
<span id="cb223-16"><a href="#cb223-16"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb223-17"><a href="#cb223-17"></a>                <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;constant %d - testStringObject failed: %s&quot;</span>,</span>
<span id="cb223-18"><a href="#cb223-18"></a>                    i, err)</span>
<span id="cb223-19"><a href="#cb223-19"></a>            }</span>
<span id="cb223-20"><a href="#cb223-20"></a>        }</span>
<span id="cb223-21"><a href="#cb223-21"></a>    }</span>
<span id="cb223-22"><a href="#cb223-22"></a></span>
<span id="cb223-23"><a href="#cb223-23"></a>    <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb223-24"><a href="#cb223-24"></a>}</span>
<span id="cb223-25"><a href="#cb223-25"></a></span>
<span id="cb223-26"><a href="#cb223-26"></a><span class="kw">func</span> testStringObject(expected <span class="dt">string</span>, actual object.Object) <span class="dt">error</span> {</span>
<span id="cb223-27"><a href="#cb223-27"></a>    result, ok := actual.(*object.String)</span>
<span id="cb223-28"><a href="#cb223-28"></a>    <span class="kw">if</span> !ok {</span>
<span id="cb223-29"><a href="#cb223-29"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;object is not String. got=%T (%+v)&quot;</span>,</span>
<span id="cb223-30"><a href="#cb223-30"></a>            actual, actual)</span>
<span id="cb223-31"><a href="#cb223-31"></a>    }</span>
<span id="cb223-32"><a href="#cb223-32"></a></span>
<span id="cb223-33"><a href="#cb223-33"></a>    <span class="kw">if</span> result.Value != expected {</span>
<span id="cb223-34"><a href="#cb223-34"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;object has wrong value. got=%q, want=%q&quot;</span>,</span>
<span id="cb223-35"><a href="#cb223-35"></a>            result.Value, expected)</span>
<span id="cb223-36"><a href="#cb223-36"></a>    }</span>
<span id="cb223-37"><a href="#cb223-37"></a></span>
<span id="cb223-38"><a href="#cb223-38"></a>    <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb223-39"><a href="#cb223-39"></a>}</span></code></pre></div>
<p>The new <code>case string</code> branch in <code>testConstants</code> is accompanied by the new <code>testStringObject</code> function, which mirrors the existing <code>testIntegerObject</code> and makes sure that the constants are the strings we expect them to be.</p>
<p>When we now run the tests, we can see that the expected constants are not the issue (yet), but the instructions are:</p>
<div class="sourceCode" id="cb224"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb224-1"><a href="#cb224-1"></a>$ go test ./compiler</span>
<span id="cb224-2"><a href="#cb224-2"></a>--- FAIL: TestStringExpressions (0.00s)</span>
<span id="cb224-3"><a href="#cb224-3"></a> compiler_test.go:410: testInstructions failed: wrong instructions length.</span>
<span id="cb224-4"><a href="#cb224-4"></a>  want=&quot;0000 OpConstant 0\n0003 OpPop\n&quot;</span>
<span id="cb224-5"><a href="#cb224-5"></a>  got =&quot;0000 OpPop\n&quot;</span>
<span id="cb224-6"><a href="#cb224-6"></a>FAIL</span>
<span id="cb224-7"><a href="#cb224-7"></a>FAIL    monkey/compiler 0.009s</span></code></pre></div>
<p>It’s not like we didn’t expect that. We need to emit <code>OpConstant</code> instructions when compiling string literals. To do that, we have to change the <code>Compile</code> method of the compiler to handle <code>*ast.StringLiteral</code>s and create <code>*object.String</code> out of them:</p>
<div class="sourceCode" id="cb225"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb225-1"><a href="#cb225-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb225-2"><a href="#cb225-2"></a></span>
<span id="cb225-3"><a href="#cb225-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb225-4"><a href="#cb225-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb225-5"><a href="#cb225-5"></a>    <span class="co">// [...]</span></span>
<span id="cb225-6"><a href="#cb225-6"></a></span>
<span id="cb225-7"><a href="#cb225-7"></a>    <span class="kw">case</span> *ast.StringLiteral:</span>
<span id="cb225-8"><a href="#cb225-8"></a>        str := &amp;object.String{Value: node.Value}</span>
<span id="cb225-9"><a href="#cb225-9"></a>        c.emit(code.OpConstant, c.addConstant(str))</span>
<span id="cb225-10"><a href="#cb225-10"></a></span>
<span id="cb225-11"><a href="#cb225-11"></a>    <span class="co">// [...]</span></span>
<span id="cb225-12"><a href="#cb225-12"></a>    }</span>
<span id="cb225-13"><a href="#cb225-13"></a></span>
<span id="cb225-14"><a href="#cb225-14"></a>    <span class="co">// [...]</span></span>
<span id="cb225-15"><a href="#cb225-15"></a>}</span></code></pre></div>
<p>Except for one variable name and one identifier, this is a copy of the <code>case</code> branch for <code>*ast.IntegerLiterals</code>. We take the value out of the AST node, we create an object, and we add it to the constant pool.</p>
<p>A step into the right direction:</p>
<div class="sourceCode" id="cb226"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb226-1"><a href="#cb226-1"></a>$ go test ./compiler</span>
<span id="cb226-2"><a href="#cb226-2"></a>ok      monkey/compiler 0.009s</span></code></pre></div>
<p>Sweet, both tests pass. And notice that we didn’t have to do anything special to emit the <code>OpAdd</code> instruction for the concatenation to work. The compiler already takes care of <code>*ast.InfixExpression</code>s by compiling their <code>Left</code> and <code>Right</code> nodes. In the test case these are <code>*ast.StringLiteral</code>s, which we can now successfully compile.</p>
<p>Next, we write a test for the VM to make sure that the same Monkey code can be executed by the VM once it’s compiled to bytecode instructions:</p>
<div class="sourceCode" id="cb227"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb227-1"><a href="#cb227-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb227-2"><a href="#cb227-2"></a></span>
<span id="cb227-3"><a href="#cb227-3"></a><span class="kw">func</span> TestStringExpressions(t *testing.T) {</span>
<span id="cb227-4"><a href="#cb227-4"></a>    tests := []vmTestCase{</span>
<span id="cb227-5"><a href="#cb227-5"></a>        {<span class="st">`&quot;monkey&quot;`</span>, <span class="st">&quot;monkey&quot;</span>},</span>
<span id="cb227-6"><a href="#cb227-6"></a>        {<span class="st">`&quot;mon&quot; + &quot;key&quot;`</span>, <span class="st">&quot;monkey&quot;</span>},</span>
<span id="cb227-7"><a href="#cb227-7"></a>        {<span class="st">`&quot;mon&quot; + &quot;key&quot; + &quot;banana&quot;`</span>, <span class="st">&quot;monkeybanana&quot;</span>},</span>
<span id="cb227-8"><a href="#cb227-8"></a>    }</span>
<span id="cb227-9"><a href="#cb227-9"></a></span>
<span id="cb227-10"><a href="#cb227-10"></a>    runVmTests(t, tests)</span>
<span id="cb227-11"><a href="#cb227-11"></a>}</span></code></pre></div>
<p>These test cases are the same as in the compiler test, except for the additional assertion that adding more than two strings together should also work – because why not?</p>
<p>Here, too, we need a new <code>testStringObject</code> helper function to make sure that it’s <code>*object.String</code>s that end up on the VM’s stack. It’s also a copy of its <code>testIntegerObject</code> counterpart and makes sure that the strings produced by the VM are the ones we expect:</p>
<div class="sourceCode" id="cb228"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb228-1"><a href="#cb228-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb228-2"><a href="#cb228-2"></a></span>
<span id="cb228-3"><a href="#cb228-3"></a><span class="kw">func</span> testExpectedObject(</span>
<span id="cb228-4"><a href="#cb228-4"></a>    t *testing.T,</span>
<span id="cb228-5"><a href="#cb228-5"></a>    expected <span class="kw">interface</span>{},</span>
<span id="cb228-6"><a href="#cb228-6"></a>    actual object.Object,</span>
<span id="cb228-7"><a href="#cb228-7"></a>) {</span>
<span id="cb228-8"><a href="#cb228-8"></a>    t.Helper()</span>
<span id="cb228-9"><a href="#cb228-9"></a></span>
<span id="cb228-10"><a href="#cb228-10"></a>    <span class="kw">switch</span> expected := expected.(<span class="kw">type</span>) {</span>
<span id="cb228-11"><a href="#cb228-11"></a>    <span class="co">// [...]</span></span>
<span id="cb228-12"><a href="#cb228-12"></a></span>
<span id="cb228-13"><a href="#cb228-13"></a>    <span class="kw">case</span> <span class="dt">string</span>:</span>
<span id="cb228-14"><a href="#cb228-14"></a>        err := testStringObject(expected, actual)</span>
<span id="cb228-15"><a href="#cb228-15"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb228-16"><a href="#cb228-16"></a>            t.Errorf(<span class="st">&quot;testStringObject failed: %s&quot;</span>, err)</span>
<span id="cb228-17"><a href="#cb228-17"></a>        }</span>
<span id="cb228-18"><a href="#cb228-18"></a></span>
<span id="cb228-19"><a href="#cb228-19"></a>    }</span>
<span id="cb228-20"><a href="#cb228-20"></a>}</span>
<span id="cb228-21"><a href="#cb228-21"></a></span>
<span id="cb228-22"><a href="#cb228-22"></a><span class="kw">func</span> testStringObject(expected <span class="dt">string</span>, actual object.Object) <span class="dt">error</span> {</span>
<span id="cb228-23"><a href="#cb228-23"></a>    result, ok := actual.(*object.String)</span>
<span id="cb228-24"><a href="#cb228-24"></a>    <span class="kw">if</span> !ok {</span>
<span id="cb228-25"><a href="#cb228-25"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;object is not String. got=%T (%+v)&quot;</span>,</span>
<span id="cb228-26"><a href="#cb228-26"></a>            actual, actual)</span>
<span id="cb228-27"><a href="#cb228-27"></a>    }</span>
<span id="cb228-28"><a href="#cb228-28"></a></span>
<span id="cb228-29"><a href="#cb228-29"></a>    <span class="kw">if</span> result.Value != expected {</span>
<span id="cb228-30"><a href="#cb228-30"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;object has wrong value. got=%q, want=%q&quot;</span>,</span>
<span id="cb228-31"><a href="#cb228-31"></a>            result.Value, expected)</span>
<span id="cb228-32"><a href="#cb228-32"></a>    }</span>
<span id="cb228-33"><a href="#cb228-33"></a></span>
<span id="cb228-34"><a href="#cb228-34"></a>    <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb228-35"><a href="#cb228-35"></a>}</span></code></pre></div>
<p>Running the tests shows us that loading strings on to the stack is already working fine, but concatenation is not:</p>
<div class="sourceCode" id="cb229"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb229-1"><a href="#cb229-1"></a>$ go test ./vm</span>
<span id="cb229-2"><a href="#cb229-2"></a>--- FAIL: TestStringExpressions (0.00s)</span>
<span id="cb229-3"><a href="#cb229-3"></a> vm_test.go:222: vm error:\</span>
<span id="cb229-4"><a href="#cb229-4"></a>   unsupported types for binary operation: STRING STRING</span>
<span id="cb229-5"><a href="#cb229-5"></a>FAIL</span>
<span id="cb229-6"><a href="#cb229-6"></a>FAIL    monkey/vm   0.029s</span></code></pre></div>
<p>Technically speaking, this <em>could</em> have been working without us doing anything. We <em>could</em> have made our previous implementation of <code>OpAdd</code> in the VM so generic that it would work with any <code>object.Object</code> that has an <code>Add</code> method, or something like that. But we didn’t. Instead, we added type checks to be explicit about which data type we support and which not. Now we have to extend the check:</p>
<div class="sourceCode" id="cb230"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb230-1"><a href="#cb230-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb230-2"><a href="#cb230-2"></a></span>
<span id="cb230-3"><a href="#cb230-3"></a><span class="kw">func</span> (vm *VM) executeBinaryOperation(op code.Opcode) <span class="dt">error</span> {</span>
<span id="cb230-4"><a href="#cb230-4"></a>    right := vm.pop()</span>
<span id="cb230-5"><a href="#cb230-5"></a>    left := vm.pop()</span>
<span id="cb230-6"><a href="#cb230-6"></a></span>
<span id="cb230-7"><a href="#cb230-7"></a>    leftType := left.Type()</span>
<span id="cb230-8"><a href="#cb230-8"></a>    rightType := right.Type()</span>
<span id="cb230-9"><a href="#cb230-9"></a></span>
<span id="cb230-10"><a href="#cb230-10"></a>    <span class="kw">switch</span> {</span>
<span id="cb230-11"><a href="#cb230-11"></a>    <span class="kw">case</span> leftType == object.INTEGER_OBJ &amp;&amp; rightType == object.INTEGER_OBJ:</span>
<span id="cb230-12"><a href="#cb230-12"></a>        <span class="kw">return</span> vm.executeBinaryIntegerOperation(op, left, right)</span>
<span id="cb230-13"><a href="#cb230-13"></a>    <span class="kw">case</span> leftType == object.STRING_OBJ &amp;&amp; rightType == object.STRING_OBJ:</span>
<span id="cb230-14"><a href="#cb230-14"></a>        <span class="kw">return</span> vm.executeBinaryStringOperation(op, left, right)</span>
<span id="cb230-15"><a href="#cb230-15"></a>    <span class="kw">default</span>:</span>
<span id="cb230-16"><a href="#cb230-16"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;unsupported types for binary operation: %s %s&quot;</span>,</span>
<span id="cb230-17"><a href="#cb230-17"></a>            leftType, rightType)</span>
<span id="cb230-18"><a href="#cb230-18"></a>    }</span>
<span id="cb230-19"><a href="#cb230-19"></a>}</span>
<span id="cb230-20"><a href="#cb230-20"></a></span>
<span id="cb230-21"><a href="#cb230-21"></a><span class="kw">func</span> (vm *VM) executeBinaryStringOperation(</span>
<span id="cb230-22"><a href="#cb230-22"></a>    op code.Opcode,</span>
<span id="cb230-23"><a href="#cb230-23"></a>    left, right object.Object,</span>
<span id="cb230-24"><a href="#cb230-24"></a>) <span class="dt">error</span> {</span>
<span id="cb230-25"><a href="#cb230-25"></a>    <span class="kw">if</span> op != code.OpAdd {</span>
<span id="cb230-26"><a href="#cb230-26"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;unknown string operator: %d&quot;</span>, op)</span>
<span id="cb230-27"><a href="#cb230-27"></a>    }</span>
<span id="cb230-28"><a href="#cb230-28"></a></span>
<span id="cb230-29"><a href="#cb230-29"></a>    leftValue := left.(*object.String).Value</span>
<span id="cb230-30"><a href="#cb230-30"></a>    rightValue := right.(*object.String).Value</span>
<span id="cb230-31"><a href="#cb230-31"></a></span>
<span id="cb230-32"><a href="#cb230-32"></a>    <span class="kw">return</span> vm.push(&amp;object.String{Value: leftValue + rightValue})</span>
<span id="cb230-33"><a href="#cb230-33"></a>}</span></code></pre></div>
<p>In <code>executeBinaryOperation</code> the conditional has been changed into a <code>switch</code> statement with a new <code>case</code> branch for strings. There, we delegate the actual adding of two strings to <code>executeBinaryStringOperation</code>, which unwraps the <code>*object.String</code>s, concatenates the underlying Go <code>string</code>s and pushes the result back on to the VM’s stack.</p>
<p>And that’s it:</p>
<div class="sourceCode" id="cb231"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb231-1"><a href="#cb231-1"></a>$ go test ./vm</span>
<span id="cb231-2"><a href="#cb231-2"></a>ok      monkey/vm   0.028s</span></code></pre></div>
<p>Monkey strings are now fully implemented, including string concatenation. Next up: arrays.</p>
<h2 id="array">Array</h2>
<p>Arrays are the first <a href="https://en.wikipedia.org/wiki/Composite_data_type">composite data type</a> we’re adding to this Monkey implementation. That means, roughly speaking, arrays are <em>composed</em> out of other data types. The practical consequence for us is that we can’t treat array literals as constant expressions.</p>
<p>Since an array is made up of multiple elements and an array literal consists of multiple expressions that produce these elements, the value of the array literal itself might change between compile and run time. Here’s an example:</p>
<div class="sourceCode" id="cb232"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb232-1"><a href="#cb232-1"></a>[<span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">6</span>]</span></code></pre></div>
<p>Don’t be distracted by these integer expressions. They’re so simple, an optimizing compiler could pre-compute them, yes, but the point is that these could be <em>any</em> type of expression – integer literal, string concatenation, function literal, function call, and so on. Only at run time can we reliably determine what they evaluate to.</p>
<p>Coming from integer and string literals, we now have to change our approach a tiny bit. Instead of building an array at compile time and passing it to the VM in the constant pool, we’ll instead tell the VM how to build it on its own.</p>
<p>To that end, we define a new opcode, called <code>OpArray</code>, with one operand: the number of elements in an array literal. When we then compile an <code>*ast.ArrayLiteral</code>, we first compile all of its elements. Since these are <code>ast.Expression</code>s, compiling them results in instructions that leave N values on the VM’s stack, where N is the number of elements in the array literal. Then, we’re going to emit an <code>OpArray</code> instruction with the operand being N, the number of elements. Compilation done.</p>
<p>When the VM then executes the <code>OpArray</code> instruction it takes the N elements off the stack, builds an <code>*object.Array</code> out of them, and pushes that on to the stack. Done. We told the VM how to build an array.</p>
<p>Let’s put this plan right into practice. Here is the definition of <code>OpArray</code>:</p>
<div class="sourceCode" id="cb233"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb233-1"><a href="#cb233-1"></a><span class="co">// code/code.go</span></span>
<span id="cb233-2"><a href="#cb233-2"></a></span>
<span id="cb233-3"><a href="#cb233-3"></a><span class="kw">const</span> (</span>
<span id="cb233-4"><a href="#cb233-4"></a>    <span class="co">// [...]</span></span>
<span id="cb233-5"><a href="#cb233-5"></a></span>
<span id="cb233-6"><a href="#cb233-6"></a>    OpArray</span>
<span id="cb233-7"><a href="#cb233-7"></a>)</span>
<span id="cb233-8"><a href="#cb233-8"></a></span>
<span id="cb233-9"><a href="#cb233-9"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb233-10"><a href="#cb233-10"></a>    <span class="co">// [...]</span></span>
<span id="cb233-11"><a href="#cb233-11"></a></span>
<span id="cb233-12"><a href="#cb233-12"></a>    OpArray: {<span class="st">&quot;OpArray&quot;</span>, []<span class="dt">int</span>{<span class="dv">2</span>}},</span>
<span id="cb233-13"><a href="#cb233-13"></a>}</span></code></pre></div>
<p>The single operand is two bytes wide. That gives us 65535 as the highest possible number of elements in an array literal. If you have a Monkey program that needs more than that, please let me know.</p>
<p>Before we translate our plan for this new opcode into compiler code, we need to write a test, as always:</p>
<div class="sourceCode" id="cb234"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb234-1"><a href="#cb234-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb234-2"><a href="#cb234-2"></a></span>
<span id="cb234-3"><a href="#cb234-3"></a><span class="kw">func</span> TestArrayLiterals(t *testing.T) {</span>
<span id="cb234-4"><a href="#cb234-4"></a>    tests := []compilerTestCase{</span>
<span id="cb234-5"><a href="#cb234-5"></a>        {</span>
<span id="cb234-6"><a href="#cb234-6"></a>            input:             <span class="st">&quot;[]&quot;</span>,</span>
<span id="cb234-7"><a href="#cb234-7"></a>            expectedConstants: []<span class="kw">interface</span>{}{},</span>
<span id="cb234-8"><a href="#cb234-8"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb234-9"><a href="#cb234-9"></a>                code.Make(code.OpArray, <span class="dv">0</span>),</span>
<span id="cb234-10"><a href="#cb234-10"></a>                code.Make(code.OpPop),</span>
<span id="cb234-11"><a href="#cb234-11"></a>            },</span>
<span id="cb234-12"><a href="#cb234-12"></a>        },</span>
<span id="cb234-13"><a href="#cb234-13"></a>        {</span>
<span id="cb234-14"><a href="#cb234-14"></a>            input:             <span class="st">&quot;[1, 2, 3]&quot;</span>,</span>
<span id="cb234-15"><a href="#cb234-15"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>},</span>
<span id="cb234-16"><a href="#cb234-16"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb234-17"><a href="#cb234-17"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb234-18"><a href="#cb234-18"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb234-19"><a href="#cb234-19"></a>                code.Make(code.OpConstant, <span class="dv">2</span>),</span>
<span id="cb234-20"><a href="#cb234-20"></a>                code.Make(code.OpArray, <span class="dv">3</span>),</span>
<span id="cb234-21"><a href="#cb234-21"></a>                code.Make(code.OpPop),</span>
<span id="cb234-22"><a href="#cb234-22"></a>            },</span>
<span id="cb234-23"><a href="#cb234-23"></a>        },</span>
<span id="cb234-24"><a href="#cb234-24"></a>        {</span>
<span id="cb234-25"><a href="#cb234-25"></a>            input:             <span class="st">&quot;[1 + 2, 3 - 4, 5 * 6]&quot;</span>,</span>
<span id="cb234-26"><a href="#cb234-26"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>},</span>
<span id="cb234-27"><a href="#cb234-27"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb234-28"><a href="#cb234-28"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb234-29"><a href="#cb234-29"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb234-30"><a href="#cb234-30"></a>                code.Make(code.OpAdd),</span>
<span id="cb234-31"><a href="#cb234-31"></a>                code.Make(code.OpConstant, <span class="dv">2</span>),</span>
<span id="cb234-32"><a href="#cb234-32"></a>                code.Make(code.OpConstant, <span class="dv">3</span>),</span>
<span id="cb234-33"><a href="#cb234-33"></a>                code.Make(code.OpSub),</span>
<span id="cb234-34"><a href="#cb234-34"></a>                code.Make(code.OpConstant, <span class="dv">4</span>),</span>
<span id="cb234-35"><a href="#cb234-35"></a>                code.Make(code.OpConstant, <span class="dv">5</span>),</span>
<span id="cb234-36"><a href="#cb234-36"></a>                code.Make(code.OpMul),</span>
<span id="cb234-37"><a href="#cb234-37"></a>                code.Make(code.OpArray, <span class="dv">3</span>),</span>
<span id="cb234-38"><a href="#cb234-38"></a>                code.Make(code.OpPop),</span>
<span id="cb234-39"><a href="#cb234-39"></a>            },</span>
<span id="cb234-40"><a href="#cb234-40"></a>        },</span>
<span id="cb234-41"><a href="#cb234-41"></a>    }</span>
<span id="cb234-42"><a href="#cb234-42"></a></span>
<span id="cb234-43"><a href="#cb234-43"></a>    runCompilerTests(t, tests)</span>
<span id="cb234-44"><a href="#cb234-44"></a>}</span></code></pre></div>
<p>This is also a translation of our plan, only it’s expressed in assertions, not yet in working code. We expect the compiler to compile the elements in the array literal into instructions that leave values on the stack and we expect it to emit an <code>OpArray</code> instruction with the operand being the number of elements in the array literal.</p>
<p>Unsurprisingly, that doesn’t happen yet:</p>
<div class="sourceCode" id="cb235"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb235-1"><a href="#cb235-1"></a>$ go test ./compiler</span>
<span id="cb235-2"><a href="#cb235-2"></a>--- FAIL: TestArrayLiterals (0.00s)</span>
<span id="cb235-3"><a href="#cb235-3"></a> compiler_test.go:477: testInstructions failed: wrong instructions length.</span>
<span id="cb235-4"><a href="#cb235-4"></a>  want=&quot;0000 OpArray 0\n0003 OpPop\n&quot;</span>
<span id="cb235-5"><a href="#cb235-5"></a>  got =&quot;0000 OpPop\n&quot;</span>
<span id="cb235-6"><a href="#cb235-6"></a>FAIL</span>
<span id="cb235-7"><a href="#cb235-7"></a>FAIL    monkey/compiler 0.009s</span></code></pre></div>
<p>Thankfully, the fix for this test is not much longer than the prose necessary to explain it:</p>
<div class="sourceCode" id="cb236"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb236-1"><a href="#cb236-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb236-2"><a href="#cb236-2"></a></span>
<span id="cb236-3"><a href="#cb236-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb236-4"><a href="#cb236-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb236-5"><a href="#cb236-5"></a>    <span class="co">// [...]</span></span>
<span id="cb236-6"><a href="#cb236-6"></a></span>
<span id="cb236-7"><a href="#cb236-7"></a>    <span class="kw">case</span> *ast.ArrayLiteral:</span>
<span id="cb236-8"><a href="#cb236-8"></a>        <span class="kw">for</span> _, el := <span class="kw">range</span> node.Elements {</span>
<span id="cb236-9"><a href="#cb236-9"></a>            err := c.Compile(el)</span>
<span id="cb236-10"><a href="#cb236-10"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb236-11"><a href="#cb236-11"></a>                <span class="kw">return</span> err</span>
<span id="cb236-12"><a href="#cb236-12"></a>            }</span>
<span id="cb236-13"><a href="#cb236-13"></a>        }</span>
<span id="cb236-14"><a href="#cb236-14"></a></span>
<span id="cb236-15"><a href="#cb236-15"></a>        c.emit(code.OpArray, <span class="bu">len</span>(node.Elements))</span>
<span id="cb236-16"><a href="#cb236-16"></a></span>
<span id="cb236-17"><a href="#cb236-17"></a>    <span class="co">// [...]</span></span>
<span id="cb236-18"><a href="#cb236-18"></a>    }</span>
<span id="cb236-19"><a href="#cb236-19"></a></span>
<span id="cb236-20"><a href="#cb236-20"></a>    <span class="co">// [...]</span></span>
<span id="cb236-21"><a href="#cb236-21"></a>}</span></code></pre></div>
<p>Just like we planned:</p>
<div class="sourceCode" id="cb237"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb237-1"><a href="#cb237-1"></a>$ go test ./compiler</span>
<span id="cb237-2"><a href="#cb237-2"></a>ok      monkey/compiler 0.011s</span></code></pre></div>
<p>The next part of our plan includes the VM, where we need to implement <code>OpArray</code>, too. We start with a test:</p>
<div class="sourceCode" id="cb238"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb238-1"><a href="#cb238-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb238-2"><a href="#cb238-2"></a></span>
<span id="cb238-3"><a href="#cb238-3"></a><span class="kw">func</span> TestArrayLiterals(t *testing.T) {</span>
<span id="cb238-4"><a href="#cb238-4"></a>    tests := []vmTestCase{</span>
<span id="cb238-5"><a href="#cb238-5"></a>        {<span class="st">&quot;[]&quot;</span>, []<span class="dt">int</span>{}},</span>
<span id="cb238-6"><a href="#cb238-6"></a>        {<span class="st">&quot;[1, 2, 3]&quot;</span>, []<span class="dt">int</span>{<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>}},</span>
<span id="cb238-7"><a href="#cb238-7"></a>        {<span class="st">&quot;[1 + 2, 3 * 4, 5 + 6]&quot;</span>, []<span class="dt">int</span>{<span class="dv">3</span>, <span class="dv">12</span>, <span class="dv">11</span>}},</span>
<span id="cb238-8"><a href="#cb238-8"></a>    }</span>
<span id="cb238-9"><a href="#cb238-9"></a></span>
<span id="cb238-10"><a href="#cb238-10"></a>    runVmTests(t, tests)</span>
<span id="cb238-11"><a href="#cb238-11"></a>}</span>
<span id="cb238-12"><a href="#cb238-12"></a></span>
<span id="cb238-13"><a href="#cb238-13"></a><span class="kw">func</span> testExpectedObject(</span>
<span id="cb238-14"><a href="#cb238-14"></a>    t *testing.T,</span>
<span id="cb238-15"><a href="#cb238-15"></a>    expected <span class="kw">interface</span>{},</span>
<span id="cb238-16"><a href="#cb238-16"></a>    actual object.Object,</span>
<span id="cb238-17"><a href="#cb238-17"></a>) {</span>
<span id="cb238-18"><a href="#cb238-18"></a>    t.Helper()</span>
<span id="cb238-19"><a href="#cb238-19"></a></span>
<span id="cb238-20"><a href="#cb238-20"></a>    <span class="kw">switch</span> expected := expected.(<span class="kw">type</span>) {</span>
<span id="cb238-21"><a href="#cb238-21"></a>    <span class="co">// [...]</span></span>
<span id="cb238-22"><a href="#cb238-22"></a></span>
<span id="cb238-23"><a href="#cb238-23"></a>    <span class="kw">case</span> []<span class="dt">int</span>:</span>
<span id="cb238-24"><a href="#cb238-24"></a>        array, ok := actual.(*object.Array)</span>
<span id="cb238-25"><a href="#cb238-25"></a>        <span class="kw">if</span> !ok {</span>
<span id="cb238-26"><a href="#cb238-26"></a>            t.Errorf(<span class="st">&quot;object not Array: %T (%+v)&quot;</span>, actual, actual)</span>
<span id="cb238-27"><a href="#cb238-27"></a>            <span class="kw">return</span></span>
<span id="cb238-28"><a href="#cb238-28"></a>        }</span>
<span id="cb238-29"><a href="#cb238-29"></a></span>
<span id="cb238-30"><a href="#cb238-30"></a>        <span class="kw">if</span> <span class="bu">len</span>(array.Elements) != <span class="bu">len</span>(expected) {</span>
<span id="cb238-31"><a href="#cb238-31"></a>            t.Errorf(<span class="st">&quot;wrong num of elements. want=%d, got=%d&quot;</span>,</span>
<span id="cb238-32"><a href="#cb238-32"></a>                <span class="bu">len</span>(expected), <span class="bu">len</span>(array.Elements))</span>
<span id="cb238-33"><a href="#cb238-33"></a>            <span class="kw">return</span></span>
<span id="cb238-34"><a href="#cb238-34"></a>        }</span>
<span id="cb238-35"><a href="#cb238-35"></a></span>
<span id="cb238-36"><a href="#cb238-36"></a>        <span class="kw">for</span> i, expectedElem := <span class="kw">range</span> expected {</span>
<span id="cb238-37"><a href="#cb238-37"></a>            err := testIntegerObject(<span class="dt">int64</span>(expectedElem), array.Elements[i])</span>
<span id="cb238-38"><a href="#cb238-38"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb238-39"><a href="#cb238-39"></a>                t.Errorf(<span class="st">&quot;testIntegerObject failed: %s&quot;</span>, err)</span>
<span id="cb238-40"><a href="#cb238-40"></a>            }</span>
<span id="cb238-41"><a href="#cb238-41"></a>        }</span>
<span id="cb238-42"><a href="#cb238-42"></a></span>
<span id="cb238-43"><a href="#cb238-43"></a>    }</span>
<span id="cb238-44"><a href="#cb238-44"></a>}</span></code></pre></div>
<p>The Monkey code in these test cases is exactly the same as in the compiler test. Here, though, it’s even more important to make sure that an empty array literal works, because it’s far easier to run into an off-by-one error in the VM than in the compiler.</p>
<p>And to make sure that an <code>*object.Array</code> is what ends up on the VM’s stack, we extend the <code>testExpectedObject</code> with a new <code>case []int</code> branch that turns our expected <code>[]int</code> slices into expectations about an <code>*object.Array</code>.</p>
<p>Neat and reusable! I like it. The bad news is that if we run the tests, we don’t get a helpful error message, but a <code>panic</code> – I’ll spare you the stack trace. The reason the VM <code>panic</code>s is because it doesn’t know about <code>OpArray</code> and its operand yet, and interprets the operand as another instruction. Nonsense guaranteed.</p>
<p>But regardless of whether we get a <code>panic</code> or a nice, readable error message from a failing test, it’s clear that we have to implement <code>OpArray</code> in the VM. Decode the operand, take the specified number of elements off the stack, construct an <code>*object.Array</code>, push it back on to the stack. We can do all of that with one <code>case</code> branch and one method:</p>
<div class="sourceCode" id="cb239"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb239-1"><a href="#cb239-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb239-2"><a href="#cb239-2"></a></span>
<span id="cb239-3"><a href="#cb239-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb239-4"><a href="#cb239-4"></a>    <span class="co">// [...]</span></span>
<span id="cb239-5"><a href="#cb239-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb239-6"><a href="#cb239-6"></a>        <span class="co">// [...]</span></span>
<span id="cb239-7"><a href="#cb239-7"></a></span>
<span id="cb239-8"><a href="#cb239-8"></a>        <span class="kw">case</span> code.OpArray:</span>
<span id="cb239-9"><a href="#cb239-9"></a>            numElements := <span class="dt">int</span>(code.ReadUint16(vm.instructions[ip+<span class="dv">1</span>:]))</span>
<span id="cb239-10"><a href="#cb239-10"></a>            ip += <span class="dv">2</span></span>
<span id="cb239-11"><a href="#cb239-11"></a></span>
<span id="cb239-12"><a href="#cb239-12"></a>            array := vm.buildArray(vm.sp-numElements, vm.sp)</span>
<span id="cb239-13"><a href="#cb239-13"></a>            vm.sp = vm.sp - numElements</span>
<span id="cb239-14"><a href="#cb239-14"></a></span>
<span id="cb239-15"><a href="#cb239-15"></a>            err := vm.push(array)</span>
<span id="cb239-16"><a href="#cb239-16"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb239-17"><a href="#cb239-17"></a>                <span class="kw">return</span> err</span>
<span id="cb239-18"><a href="#cb239-18"></a>            }</span>
<span id="cb239-19"><a href="#cb239-19"></a></span>
<span id="cb239-20"><a href="#cb239-20"></a>        <span class="co">// [...]</span></span>
<span id="cb239-21"><a href="#cb239-21"></a>        }</span>
<span id="cb239-22"><a href="#cb239-22"></a>    <span class="co">// [...]</span></span>
<span id="cb239-23"><a href="#cb239-23"></a>}</span>
<span id="cb239-24"><a href="#cb239-24"></a></span>
<span id="cb239-25"><a href="#cb239-25"></a><span class="kw">func</span> (vm *VM) buildArray(startIndex, endIndex <span class="dt">int</span>) object.Object {</span>
<span id="cb239-26"><a href="#cb239-26"></a>    elements := <span class="bu">make</span>([]object.Object, endIndex-startIndex)</span>
<span id="cb239-27"><a href="#cb239-27"></a></span>
<span id="cb239-28"><a href="#cb239-28"></a>    <span class="kw">for</span> i := startIndex; i &lt; endIndex; i++ {</span>
<span id="cb239-29"><a href="#cb239-29"></a>        elements[i-startIndex] = vm.stack[i]</span>
<span id="cb239-30"><a href="#cb239-30"></a>    }</span>
<span id="cb239-31"><a href="#cb239-31"></a></span>
<span id="cb239-32"><a href="#cb239-32"></a>    <span class="kw">return</span> &amp;object.Array{Elements: elements}</span>
<span id="cb239-33"><a href="#cb239-33"></a>}</span></code></pre></div>
<p>The <code>case</code> branch for <code>code.OpArray</code> takes care of decoding the operand, incrementing the <code>ip</code> and telling the new <code>buildArray</code> method where it can find the array elements on the stack.</p>
<p><code>buildArray</code> then iterates through the elements in the specified section of the stack, adding each to a newly-built <code>*object.Array</code>. This array is then pushed on to the stack, but only – and this is important – after the elements have been taken off. What we end up with is an <code>*object.Array</code> sitting on the stack, containing the specified number of elements:</p>
<div class="sourceCode" id="cb240"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb240-1"><a href="#cb240-1"></a>$ go test ./vm</span>
<span id="cb240-2"><a href="#cb240-2"></a>ok      monkey/vm   0.031s</span></code></pre></div>
<p>Alright! Another one in the bag: we’ve fully implemented array literals!</p>
<h2 id="hash">Hash</h2>
<p>In order to implement Monkey’s hash data structure we again need a new opcode. Just like an array, its final value can’t be determined at compile time. Doubly so, actually, because instead of having N elements, a hash in Monkey has N keys and N values and all of them are created by expressions:</p>
<div class="sourceCode" id="cb241"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb241-1"><a href="#cb241-1"></a>{<span class="dv">1</span> <span class="op">+</span> <span class="dv">1</span><span class="op">:</span> <span class="dv">2</span> <span class="op">*</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span> <span class="op">+</span> <span class="dv">3</span><span class="op">:</span> <span class="dv">4</span> <span class="op">*</span> <span class="dv">4</span>}</span></code></pre></div>
<p>That’s equivalent to this hash literal:</p>
<div class="sourceCode" id="cb242"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb242-1"><a href="#cb242-1"></a>{<span class="dv">2</span><span class="op">:</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">6</span><span class="op">:</span> <span class="dv">16</span>}</span></code></pre></div>
<p>You and me, we wouldn’t write the first version, I know that, but we still need to make it work. To do that, we follow the same strategy we used for array literals: teaching the VM how to build hash literals.</p>
<p>And again, our first step is to define a new opcode. This one is called <code>OpHash</code> and also has one operand:</p>
<div class="sourceCode" id="cb243"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb243-1"><a href="#cb243-1"></a><span class="co">// code/code.go</span></span>
<span id="cb243-2"><a href="#cb243-2"></a></span>
<span id="cb243-3"><a href="#cb243-3"></a><span class="kw">const</span> (</span>
<span id="cb243-4"><a href="#cb243-4"></a>    <span class="co">// [...]</span></span>
<span id="cb243-5"><a href="#cb243-5"></a></span>
<span id="cb243-6"><a href="#cb243-6"></a>    OpHash</span>
<span id="cb243-7"><a href="#cb243-7"></a>)</span>
<span id="cb243-8"><a href="#cb243-8"></a></span>
<span id="cb243-9"><a href="#cb243-9"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb243-10"><a href="#cb243-10"></a>    <span class="co">// [...]</span></span>
<span id="cb243-11"><a href="#cb243-11"></a></span>
<span id="cb243-12"><a href="#cb243-12"></a>    OpHash:  {<span class="st">&quot;OpHash&quot;</span>, []<span class="dt">int</span>{<span class="dv">2</span>}},</span>
<span id="cb243-13"><a href="#cb243-13"></a>}</span></code></pre></div>
<p>The operand specifies the number of keys <em>and</em> values sitting on the stack. It’s equally feasible to use the number of pairs, but then we’d have to double it in the VM to get the number of values sitting on the stack. If we can pre-calculate that in the compiler, why not?</p>
<p>With the operand the VM can take the correct number of elements off the stack, create <code>object.HashPair</code>s out of them and build an <code>*object.Hash</code>, which it pushes on to the stack. Again, that’s the DIY strategy we used for our implementation of Monkey’s array, except that building the <code>*object.Hash</code> is slightly more elaborate.</p>
<p>Before we get to that, though, we first need to write a test to make sure our compiler can output <code>OpHash</code> instructions:</p>
<div class="sourceCode" id="cb244"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb244-1"><a href="#cb244-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb244-2"><a href="#cb244-2"></a></span>
<span id="cb244-3"><a href="#cb244-3"></a><span class="kw">func</span> TestHashLiterals(t *testing.T) {</span>
<span id="cb244-4"><a href="#cb244-4"></a>    tests := []compilerTestCase{</span>
<span id="cb244-5"><a href="#cb244-5"></a>        {</span>
<span id="cb244-6"><a href="#cb244-6"></a>            input:             <span class="st">&quot;{}&quot;</span>,</span>
<span id="cb244-7"><a href="#cb244-7"></a>            expectedConstants: []<span class="kw">interface</span>{}{},</span>
<span id="cb244-8"><a href="#cb244-8"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb244-9"><a href="#cb244-9"></a>                code.Make(code.OpHash, <span class="dv">0</span>),</span>
<span id="cb244-10"><a href="#cb244-10"></a>                code.Make(code.OpPop),</span>
<span id="cb244-11"><a href="#cb244-11"></a>            },</span>
<span id="cb244-12"><a href="#cb244-12"></a>        },</span>
<span id="cb244-13"><a href="#cb244-13"></a>        {</span>
<span id="cb244-14"><a href="#cb244-14"></a>            input:             <span class="st">&quot;{1: 2, 3: 4, 5: 6}&quot;</span>,</span>
<span id="cb244-15"><a href="#cb244-15"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>},</span>
<span id="cb244-16"><a href="#cb244-16"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb244-17"><a href="#cb244-17"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb244-18"><a href="#cb244-18"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb244-19"><a href="#cb244-19"></a>                code.Make(code.OpConstant, <span class="dv">2</span>),</span>
<span id="cb244-20"><a href="#cb244-20"></a>                code.Make(code.OpConstant, <span class="dv">3</span>),</span>
<span id="cb244-21"><a href="#cb244-21"></a>                code.Make(code.OpConstant, <span class="dv">4</span>),</span>
<span id="cb244-22"><a href="#cb244-22"></a>                code.Make(code.OpConstant, <span class="dv">5</span>),</span>
<span id="cb244-23"><a href="#cb244-23"></a>                code.Make(code.OpHash, <span class="dv">6</span>),</span>
<span id="cb244-24"><a href="#cb244-24"></a>                code.Make(code.OpPop),</span>
<span id="cb244-25"><a href="#cb244-25"></a>            },</span>
<span id="cb244-26"><a href="#cb244-26"></a>        },</span>
<span id="cb244-27"><a href="#cb244-27"></a>        {</span>
<span id="cb244-28"><a href="#cb244-28"></a>            input:             <span class="st">&quot;{1: 2 + 3, 4: 5 * 6}&quot;</span>,</span>
<span id="cb244-29"><a href="#cb244-29"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>},</span>
<span id="cb244-30"><a href="#cb244-30"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb244-31"><a href="#cb244-31"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb244-32"><a href="#cb244-32"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb244-33"><a href="#cb244-33"></a>                code.Make(code.OpConstant, <span class="dv">2</span>),</span>
<span id="cb244-34"><a href="#cb244-34"></a>                code.Make(code.OpAdd),</span>
<span id="cb244-35"><a href="#cb244-35"></a>                code.Make(code.OpConstant, <span class="dv">3</span>),</span>
<span id="cb244-36"><a href="#cb244-36"></a>                code.Make(code.OpConstant, <span class="dv">4</span>),</span>
<span id="cb244-37"><a href="#cb244-37"></a>                code.Make(code.OpConstant, <span class="dv">5</span>),</span>
<span id="cb244-38"><a href="#cb244-38"></a>                code.Make(code.OpMul),</span>
<span id="cb244-39"><a href="#cb244-39"></a>                code.Make(code.OpHash, <span class="dv">4</span>),</span>
<span id="cb244-40"><a href="#cb244-40"></a>                code.Make(code.OpPop),</span>
<span id="cb244-41"><a href="#cb244-41"></a>            },</span>
<span id="cb244-42"><a href="#cb244-42"></a>        },</span>
<span id="cb244-43"><a href="#cb244-43"></a>    }</span>
<span id="cb244-44"><a href="#cb244-44"></a></span>
<span id="cb244-45"><a href="#cb244-45"></a>    runCompilerTests(t, tests)</span>
<span id="cb244-46"><a href="#cb244-46"></a>}</span></code></pre></div>
<p>That looks like a lot of bytecode, but that’s mainly due to the expressions in the hash literals. We want to be sure that they’re compiled correctly, with the resulting instructions leaving a value on the stack. After that, we expect an <code>OpHash</code> instruction with the operand specifying the number of keys <em>and</em> values sitting on the stack.</p>
<p>The tests fails and tell us that we’re missing <code>OpHash</code> instructions:</p>
<div class="sourceCode" id="cb245"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb245-1"><a href="#cb245-1"></a>$ go test ./compiler</span>
<span id="cb245-2"><a href="#cb245-2"></a>--- FAIL: TestHashLiterals (0.00s)</span>
<span id="cb245-3"><a href="#cb245-3"></a> compiler_test.go:336: testInstructions failed: wrong instructions length.</span>
<span id="cb245-4"><a href="#cb245-4"></a>  want=&quot;0000 OpHash 0\n0003 OpPop\n&quot;</span>
<span id="cb245-5"><a href="#cb245-5"></a>  got =&quot;0000 OpPop\n&quot;</span>
<span id="cb245-6"><a href="#cb245-6"></a>FAIL</span>
<span id="cb245-7"><a href="#cb245-7"></a>FAIL    monkey/compiler 0.009s</span></code></pre></div>
<p>As I said, building <code>*object.Hash</code>es in the VM takes a little more effort than building <code>*object.Array</code>s. But compiling them also requires a little trick to work reliably:</p>
<div class="sourceCode" id="cb246"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb246-1"><a href="#cb246-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb246-2"><a href="#cb246-2"></a></span>
<span id="cb246-3"><a href="#cb246-3"></a><span class="kw">import</span> (</span>
<span id="cb246-4"><a href="#cb246-4"></a>    <span class="co">// [...]</span></span>
<span id="cb246-5"><a href="#cb246-5"></a>    <span class="st">&quot;sort&quot;</span></span>
<span id="cb246-6"><a href="#cb246-6"></a>)</span>
<span id="cb246-7"><a href="#cb246-7"></a></span>
<span id="cb246-8"><a href="#cb246-8"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb246-9"><a href="#cb246-9"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb246-10"><a href="#cb246-10"></a>    <span class="co">// [...]</span></span>
<span id="cb246-11"><a href="#cb246-11"></a></span>
<span id="cb246-12"><a href="#cb246-12"></a>    <span class="kw">case</span> *ast.HashLiteral:</span>
<span id="cb246-13"><a href="#cb246-13"></a>        keys := []ast.Expression{}</span>
<span id="cb246-14"><a href="#cb246-14"></a>        <span class="kw">for</span> k := <span class="kw">range</span> node.Pairs {</span>
<span id="cb246-15"><a href="#cb246-15"></a>            keys = <span class="bu">append</span>(keys, k)</span>
<span id="cb246-16"><a href="#cb246-16"></a>        }</span>
<span id="cb246-17"><a href="#cb246-17"></a>        sort.Slice(keys, <span class="kw">func</span>(i, j <span class="dt">int</span>) <span class="dt">bool</span> {</span>
<span id="cb246-18"><a href="#cb246-18"></a>            <span class="kw">return</span> keys[i].String() &lt; keys[j].String()</span>
<span id="cb246-19"><a href="#cb246-19"></a>        })</span>
<span id="cb246-20"><a href="#cb246-20"></a></span>
<span id="cb246-21"><a href="#cb246-21"></a>        <span class="kw">for</span> _, k := <span class="kw">range</span> keys {</span>
<span id="cb246-22"><a href="#cb246-22"></a>            err := c.Compile(k)</span>
<span id="cb246-23"><a href="#cb246-23"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb246-24"><a href="#cb246-24"></a>                <span class="kw">return</span> err</span>
<span id="cb246-25"><a href="#cb246-25"></a>            }</span>
<span id="cb246-26"><a href="#cb246-26"></a>            err = c.Compile(node.Pairs[k])</span>
<span id="cb246-27"><a href="#cb246-27"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb246-28"><a href="#cb246-28"></a>                <span class="kw">return</span> err</span>
<span id="cb246-29"><a href="#cb246-29"></a>            }</span>
<span id="cb246-30"><a href="#cb246-30"></a>        }</span>
<span id="cb246-31"><a href="#cb246-31"></a></span>
<span id="cb246-32"><a href="#cb246-32"></a>        c.emit(code.OpHash, <span class="bu">len</span>(node.Pairs)*<span class="dv">2</span>)</span>
<span id="cb246-33"><a href="#cb246-33"></a></span>
<span id="cb246-34"><a href="#cb246-34"></a>    <span class="co">// [...]</span></span>
<span id="cb246-35"><a href="#cb246-35"></a>    }</span>
<span id="cb246-36"><a href="#cb246-36"></a></span>
<span id="cb246-37"><a href="#cb246-37"></a>    <span class="co">// [...]</span></span>
<span id="cb246-38"><a href="#cb246-38"></a>}</span></code></pre></div>
<p>Since <code>node.Pairs</code> is a <code>map[ast.Expression]ast.Expression</code> and Go does not guarantee a consistent order when iterating through the keys and values of a <code>map</code>, we need to manually sort the <code>keys</code> before we can compile them. If we didn’t do that, the emitted instructions would be in random order.</p>
<p>That’s not an issue per se and, in fact, our compiler and VM would work fine without the sorting. Our tests, though, would break randomly. They have assertions about the constants in a certain order. Not for order’s sake, of course, but because we want to make sure we have the right ones.</p>
<p>In order to stop our tests’ success rate from depending on the mercy of randomness, we need to guarantee a specific arrangement of elements by sorting the keys first. Since we don’t really care about which order exactly, as long there is one, we sort them by their <code>String</code> representation.</p>
<p>After that, we iterate through the keys, compile them, fetch the corresponding value from <code>node.Pairs</code> and compile that, too. The order of key first and then the value <em>is</em> important, because we’ll need to reconstruct it in the VM.</p>
<p>As the last step in this <code>case</code> branch we emit an <code>OpHash</code> instruction, its operand being the number of keys and values.</p>
<p>When we now run our tests…</p>
<div class="sourceCode" id="cb247"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb247-1"><a href="#cb247-1"></a>$ go test ./compiler</span>
<span id="cb247-2"><a href="#cb247-2"></a>ok      monkey/compiler 0.009s</span></code></pre></div>
<p>… we can see that it’s time to move on to the VM.</p>
<p>It’s not hard to build <code>*object.Hash</code>es in the VM, but we need to do a few different things to make it work and it’s good to have tests to rely on:</p>
<div class="sourceCode" id="cb248"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb248-1"><a href="#cb248-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb248-2"><a href="#cb248-2"></a></span>
<span id="cb248-3"><a href="#cb248-3"></a><span class="kw">func</span> TestHashLiterals(t *testing.T) {</span>
<span id="cb248-4"><a href="#cb248-4"></a>    tests := []vmTestCase{</span>
<span id="cb248-5"><a href="#cb248-5"></a>        {</span>
<span id="cb248-6"><a href="#cb248-6"></a>            <span class="st">&quot;{}&quot;</span>, <span class="kw">map</span>[object.HashKey]<span class="dt">int64</span>{},</span>
<span id="cb248-7"><a href="#cb248-7"></a>        },</span>
<span id="cb248-8"><a href="#cb248-8"></a>        {</span>
<span id="cb248-9"><a href="#cb248-9"></a>            <span class="st">&quot;{1: 2, 2: 3}&quot;</span>,</span>
<span id="cb248-10"><a href="#cb248-10"></a>            <span class="kw">map</span>[object.HashKey]<span class="dt">int64</span>{</span>
<span id="cb248-11"><a href="#cb248-11"></a>                (&amp;object.Integer{Value: <span class="dv">1</span>}).HashKey(): <span class="dv">2</span>,</span>
<span id="cb248-12"><a href="#cb248-12"></a>                (&amp;object.Integer{Value: <span class="dv">2</span>}).HashKey(): <span class="dv">3</span>,</span>
<span id="cb248-13"><a href="#cb248-13"></a>            },</span>
<span id="cb248-14"><a href="#cb248-14"></a>        },</span>
<span id="cb248-15"><a href="#cb248-15"></a>        {</span>
<span id="cb248-16"><a href="#cb248-16"></a>            <span class="st">&quot;{1 + 1: 2 * 2, 3 + 3: 4 * 4}&quot;</span>,</span>
<span id="cb248-17"><a href="#cb248-17"></a>            <span class="kw">map</span>[object.HashKey]<span class="dt">int64</span>{</span>
<span id="cb248-18"><a href="#cb248-18"></a>                (&amp;object.Integer{Value: <span class="dv">2</span>}).HashKey(): <span class="dv">4</span>,</span>
<span id="cb248-19"><a href="#cb248-19"></a>                (&amp;object.Integer{Value: <span class="dv">6</span>}).HashKey(): <span class="dv">16</span>,</span>
<span id="cb248-20"><a href="#cb248-20"></a>            },</span>
<span id="cb248-21"><a href="#cb248-21"></a>        },</span>
<span id="cb248-22"><a href="#cb248-22"></a>    }</span>
<span id="cb248-23"><a href="#cb248-23"></a></span>
<span id="cb248-24"><a href="#cb248-24"></a>    runVmTests(t, tests)</span>
<span id="cb248-25"><a href="#cb248-25"></a>}</span>
<span id="cb248-26"><a href="#cb248-26"></a></span>
<span id="cb248-27"><a href="#cb248-27"></a><span class="kw">func</span> testExpectedObject(</span>
<span id="cb248-28"><a href="#cb248-28"></a>    t *testing.T,</span>
<span id="cb248-29"><a href="#cb248-29"></a>    expected <span class="kw">interface</span>{},</span>
<span id="cb248-30"><a href="#cb248-30"></a>    actual object.Object,</span>
<span id="cb248-31"><a href="#cb248-31"></a>) {</span>
<span id="cb248-32"><a href="#cb248-32"></a>    t.Helper()</span>
<span id="cb248-33"><a href="#cb248-33"></a></span>
<span id="cb248-34"><a href="#cb248-34"></a>    <span class="kw">switch</span> expected := expected.(<span class="kw">type</span>) {</span>
<span id="cb248-35"><a href="#cb248-35"></a>    <span class="co">// [...]</span></span>
<span id="cb248-36"><a href="#cb248-36"></a></span>
<span id="cb248-37"><a href="#cb248-37"></a>    <span class="kw">case</span> <span class="kw">map</span>[object.HashKey]<span class="dt">int64</span>:</span>
<span id="cb248-38"><a href="#cb248-38"></a>        hash, ok := actual.(*object.Hash)</span>
<span id="cb248-39"><a href="#cb248-39"></a>        <span class="kw">if</span> !ok {</span>
<span id="cb248-40"><a href="#cb248-40"></a>            t.Errorf(<span class="st">&quot;object is not Hash. got=%T (%+v)&quot;</span>, actual, actual)</span>
<span id="cb248-41"><a href="#cb248-41"></a>            <span class="kw">return</span></span>
<span id="cb248-42"><a href="#cb248-42"></a>        }</span>
<span id="cb248-43"><a href="#cb248-43"></a></span>
<span id="cb248-44"><a href="#cb248-44"></a>        <span class="kw">if</span> <span class="bu">len</span>(hash.Pairs) != <span class="bu">len</span>(expected) {</span>
<span id="cb248-45"><a href="#cb248-45"></a>            t.Errorf(<span class="st">&quot;hash has wrong number of Pairs. want=%d, got=%d&quot;</span>,</span>
<span id="cb248-46"><a href="#cb248-46"></a>                <span class="bu">len</span>(expected), <span class="bu">len</span>(hash.Pairs))</span>
<span id="cb248-47"><a href="#cb248-47"></a>            <span class="kw">return</span></span>
<span id="cb248-48"><a href="#cb248-48"></a>        }</span>
<span id="cb248-49"><a href="#cb248-49"></a></span>
<span id="cb248-50"><a href="#cb248-50"></a>        <span class="kw">for</span> expectedKey, expectedValue := <span class="kw">range</span> expected {</span>
<span id="cb248-51"><a href="#cb248-51"></a>            pair, ok := hash.Pairs[expectedKey]</span>
<span id="cb248-52"><a href="#cb248-52"></a>            <span class="kw">if</span> !ok {</span>
<span id="cb248-53"><a href="#cb248-53"></a>                t.Errorf(<span class="st">&quot;no pair for given key in Pairs&quot;</span>)</span>
<span id="cb248-54"><a href="#cb248-54"></a>            }</span>
<span id="cb248-55"><a href="#cb248-55"></a></span>
<span id="cb248-56"><a href="#cb248-56"></a>            err := testIntegerObject(expectedValue, pair.Value)</span>
<span id="cb248-57"><a href="#cb248-57"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb248-58"><a href="#cb248-58"></a>                t.Errorf(<span class="st">&quot;testIntegerObject failed: %s&quot;</span>, err)</span>
<span id="cb248-59"><a href="#cb248-59"></a>            }</span>
<span id="cb248-60"><a href="#cb248-60"></a>        }</span>
<span id="cb248-61"><a href="#cb248-61"></a></span>
<span id="cb248-62"><a href="#cb248-62"></a>    }</span>
<span id="cb248-63"><a href="#cb248-63"></a>}</span></code></pre></div>
<p>This test and the accompanying new <code>case</code> branch in <code>testExpectedObject</code> not only make sure that the VM knows how to build <code>*object.Hash</code>es, but also give us a refresher of how <code>*object.Hash</code> works.</p>
<p><code>object.Hash</code> has a <code>Pairs</code> field that contains a <code>map[HashKey]HashPair</code>. A <code>HashKey</code> can be created by calling the <code>HashKey</code> method of an <code>object.Hashable</code>, an interface that <code>*object.String</code>, <code>*object.Boolean</code> and <code>*object.Integer</code> implement. A <code>HashPair</code> then has a <code>Key</code> and a <code>Value</code> field, both containing an <code>object.Object</code>. This is where the real key and the real value are stored. But the <code>HashKey</code> is necessary to have consistent hashing of Monkey objects. Read through the <code>HashKey</code> methods in the <code>object</code> package to get a more detailed refresher of how that works.</p>
<p>We expect the VM to store the correct <code>HashPair</code>s under the correct <code>HashKey</code>s. We do not really care about <em>what</em> gets stored; we mostly care about the <em>how</em>, which is why we use boring integers and why the expected hash in each test case is a <code>map[object.HashKey]int64</code>. That way we can concentrate on finding the correct value under the correct hash key.</p>
<p>When we run the tests now, we run into the same problem we previously faced when running the array test for the first time: a <code>panic</code>. I’ll again refrain from showing you this unsightly mess, but rest assured that its cause, again, is the fact that our VM doesn’t know about <code>OpHash</code> nor its operand yet. Let’s fix that.</p>
<div class="sourceCode" id="cb249"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb249-1"><a href="#cb249-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb249-2"><a href="#cb249-2"></a></span>
<span id="cb249-3"><a href="#cb249-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb249-4"><a href="#cb249-4"></a>    <span class="co">// [...]</span></span>
<span id="cb249-5"><a href="#cb249-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb249-6"><a href="#cb249-6"></a>        <span class="co">// [...]</span></span>
<span id="cb249-7"><a href="#cb249-7"></a></span>
<span id="cb249-8"><a href="#cb249-8"></a>        <span class="kw">case</span> code.OpHash:</span>
<span id="cb249-9"><a href="#cb249-9"></a>            numElements := <span class="dt">int</span>(code.ReadUint16(vm.instructions[ip+<span class="dv">1</span>:]))</span>
<span id="cb249-10"><a href="#cb249-10"></a>            ip += <span class="dv">2</span></span>
<span id="cb249-11"><a href="#cb249-11"></a></span>
<span id="cb249-12"><a href="#cb249-12"></a>            hash, err := vm.buildHash(vm.sp-numElements, vm.sp)</span>
<span id="cb249-13"><a href="#cb249-13"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb249-14"><a href="#cb249-14"></a>                <span class="kw">return</span> err</span>
<span id="cb249-15"><a href="#cb249-15"></a>            }</span>
<span id="cb249-16"><a href="#cb249-16"></a>            vm.sp = vm.sp - numElements</span>
<span id="cb249-17"><a href="#cb249-17"></a></span>
<span id="cb249-18"><a href="#cb249-18"></a>            err = vm.push(hash)</span>
<span id="cb249-19"><a href="#cb249-19"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb249-20"><a href="#cb249-20"></a>                <span class="kw">return</span> err</span>
<span id="cb249-21"><a href="#cb249-21"></a>            }</span>
<span id="cb249-22"><a href="#cb249-22"></a></span>
<span id="cb249-23"><a href="#cb249-23"></a>        <span class="co">// [...]</span></span>
<span id="cb249-24"><a href="#cb249-24"></a>        }</span>
<span id="cb249-25"><a href="#cb249-25"></a>    <span class="co">// [...]</span></span>
<span id="cb249-26"><a href="#cb249-26"></a>}</span></code></pre></div>
<p>This is also remarkably close to the <code>case</code> branch for <code>OpArray</code>, except that now we’re using the new <code>buildHash</code> to build a hash instead of an array. And <code>buildHash</code> might return an error:</p>
<div class="sourceCode" id="cb250"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb250-1"><a href="#cb250-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb250-2"><a href="#cb250-2"></a></span>
<span id="cb250-3"><a href="#cb250-3"></a><span class="kw">func</span> (vm *VM) buildHash(startIndex, endIndex <span class="dt">int</span>) (object.Object, <span class="dt">error</span>) {</span>
<span id="cb250-4"><a href="#cb250-4"></a>    hashedPairs := <span class="bu">make</span>(<span class="kw">map</span>[object.HashKey]object.HashPair)</span>
<span id="cb250-5"><a href="#cb250-5"></a></span>
<span id="cb250-6"><a href="#cb250-6"></a>    <span class="kw">for</span> i := startIndex; i &lt; endIndex; i += <span class="dv">2</span> {</span>
<span id="cb250-7"><a href="#cb250-7"></a>        key := vm.stack[i]</span>
<span id="cb250-8"><a href="#cb250-8"></a>        value := vm.stack[i+<span class="dv">1</span>]</span>
<span id="cb250-9"><a href="#cb250-9"></a></span>
<span id="cb250-10"><a href="#cb250-10"></a>        pair := object.HashPair{Key: key, Value: value}</span>
<span id="cb250-11"><a href="#cb250-11"></a></span>
<span id="cb250-12"><a href="#cb250-12"></a>        hashKey, ok := key.(object.Hashable)</span>
<span id="cb250-13"><a href="#cb250-13"></a>        <span class="kw">if</span> !ok {</span>
<span id="cb250-14"><a href="#cb250-14"></a>            <span class="kw">return</span> <span class="ot">nil</span>, fmt.Errorf(<span class="st">&quot;unusable as hash key: %s&quot;</span>, key.Type())</span>
<span id="cb250-15"><a href="#cb250-15"></a>        }</span>
<span id="cb250-16"><a href="#cb250-16"></a></span>
<span id="cb250-17"><a href="#cb250-17"></a>        hashedPairs[hashKey.HashKey()] = pair</span>
<span id="cb250-18"><a href="#cb250-18"></a>    }</span>
<span id="cb250-19"><a href="#cb250-19"></a></span>
<span id="cb250-20"><a href="#cb250-20"></a>    <span class="kw">return</span> &amp;object.Hash{Pairs: hashedPairs}, <span class="ot">nil</span></span>
<span id="cb250-21"><a href="#cb250-21"></a>}</span></code></pre></div>
<p>Similar to <code>buildArray</code>, <code>buildHash</code> also takes in the <code>startIndex</code> and <code>endIndex</code> of the elements sitting on the stack. It then iterates through them in pairs, <code>key</code> and <code>value</code>, creating an <code>object.HashPair</code> out of each. For each pair it generates an <code>object.HashKey</code> and adds the pair to <code>hashedPairs</code>. As its final act, it builds the <code>*object.Hash</code> and returns it.</p>
<p>In the <code>case code.OpHash</code> branch of <code>vm.Run</code> this newly built <code>*object.Hash</code> is then pushed on to the stack, but only after the elements have been taken off.</p>
<p>And that’s how our VM builds hashes:</p>
<div class="sourceCode" id="cb251"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb251-1"><a href="#cb251-1"></a>$ go test ./vm</span>
<span id="cb251-2"><a href="#cb251-2"></a>ok      monkey/vm   0.033s</span></code></pre></div>
<p>Look at that! We’ve implemented hashes! That completes our implementation of Monkey data types. The only problem is that we can’t really do anything with them yet.</p>
<h2 id="adding-the-index-operator">Adding the index operator</h2>
<p>As we said at the beginning of the chapter, our goal is to make this piece of Monkey code work:</p>
<div class="sourceCode" id="cb252"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb252-1"><a href="#cb252-1"></a>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>][<span class="dv">1</span>]</span>
<span id="cb252-2"><a href="#cb252-2"></a>{<span class="st">&quot;one&quot;</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;two&quot;</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span> <span class="st">&quot;three&quot;</span><span class="op">:</span> <span class="dv">3</span>}[<span class="st">&quot;o&quot;</span> <span class="op">+</span> <span class="st">&quot;ne&quot;</span>]</span></code></pre></div>
<p>We’re nearly there: we already support array literals, hash literals, and also string concatenation. What we don’t have yet is the index operator, which allows us to retrieve a single element from an array or a hash.</p>
<p>What’s interesting about the index operator is that it’s quite generic. While we only want to use it with arrays and hashes, its syntactic form allows for much more:</p>
<div class="sourceCode" id="cb253"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb253-1"><a href="#cb253-1"></a><span class="op">&lt;</span>expression<span class="op">&gt;</span>[<span class="op">&lt;</span>expression<span class="op">&gt;</span>]</span></code></pre></div>
<p>The data structure being indexed and the index itself can be produced by any expression. And since a Monkey expression can produce any Monkey object that means, on a semantic level, that the index operator can work with any <code>object.Object</code> either as the index or as the indexed data structure.</p>
<p>That’s exactly how we’re going to implement it. Instead of treating the index operator in combination with a specific data structure as a special case, we’ll build a generic index operator into the compiler and VM. The first step, as so often, is to define a new opcode.</p>
<p>It’s called <code>OpIndex</code> and has no operands. Instead, for <code>OpIndex</code> to work, there need to be two values sitting on the top of the stack: the object to be indexed and, above that, the object serving as the index. When the VM executes <code>OpIndex</code> it should take both off the stack, perform the index operation, and put the result back on.</p>
<p>That’s generic enough to allow for arrays and hashes to be used as the indexed data structure, while also being easy to implement, due to its usage of the stack.</p>
<p>Here is the definition of <code>OpIndex</code>:</p>
<div class="sourceCode" id="cb254"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb254-1"><a href="#cb254-1"></a><span class="co">// code/code.go</span></span>
<span id="cb254-2"><a href="#cb254-2"></a></span>
<span id="cb254-3"><a href="#cb254-3"></a><span class="kw">const</span> (</span>
<span id="cb254-4"><a href="#cb254-4"></a>    <span class="co">// [...]</span></span>
<span id="cb254-5"><a href="#cb254-5"></a></span>
<span id="cb254-6"><a href="#cb254-6"></a>    OpIndex</span>
<span id="cb254-7"><a href="#cb254-7"></a>)</span>
<span id="cb254-8"><a href="#cb254-8"></a></span>
<span id="cb254-9"><a href="#cb254-9"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb254-10"><a href="#cb254-10"></a>    <span class="co">// [...]</span></span>
<span id="cb254-11"><a href="#cb254-11"></a></span>
<span id="cb254-12"><a href="#cb254-12"></a>    OpIndex: {<span class="st">&quot;OpIndex&quot;</span>, []<span class="dt">int</span>{}},</span>
<span id="cb254-13"><a href="#cb254-13"></a>}</span></code></pre></div>
<p>Now we write a compiler test in which we expect <code>OpIndex</code> instructions:</p>
<div class="sourceCode" id="cb255"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb255-1"><a href="#cb255-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb255-2"><a href="#cb255-2"></a></span>
<span id="cb255-3"><a href="#cb255-3"></a><span class="kw">func</span> TestIndexExpressions(t *testing.T) {</span>
<span id="cb255-4"><a href="#cb255-4"></a>    tests := []compilerTestCase{</span>
<span id="cb255-5"><a href="#cb255-5"></a>        {</span>
<span id="cb255-6"><a href="#cb255-6"></a>            input:             <span class="st">&quot;[1, 2, 3][1 + 1]&quot;</span>,</span>
<span id="cb255-7"><a href="#cb255-7"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">1</span>},</span>
<span id="cb255-8"><a href="#cb255-8"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb255-9"><a href="#cb255-9"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb255-10"><a href="#cb255-10"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb255-11"><a href="#cb255-11"></a>                code.Make(code.OpConstant, <span class="dv">2</span>),</span>
<span id="cb255-12"><a href="#cb255-12"></a>                code.Make(code.OpArray, <span class="dv">3</span>),</span>
<span id="cb255-13"><a href="#cb255-13"></a>                code.Make(code.OpConstant, <span class="dv">3</span>),</span>
<span id="cb255-14"><a href="#cb255-14"></a>                code.Make(code.OpConstant, <span class="dv">4</span>),</span>
<span id="cb255-15"><a href="#cb255-15"></a>                code.Make(code.OpAdd),</span>
<span id="cb255-16"><a href="#cb255-16"></a>                code.Make(code.OpIndex),</span>
<span id="cb255-17"><a href="#cb255-17"></a>                code.Make(code.OpPop),</span>
<span id="cb255-18"><a href="#cb255-18"></a>            },</span>
<span id="cb255-19"><a href="#cb255-19"></a>        },</span>
<span id="cb255-20"><a href="#cb255-20"></a>        {</span>
<span id="cb255-21"><a href="#cb255-21"></a>            input:             <span class="st">&quot;{1: 2}[2 - 1]&quot;</span>,</span>
<span id="cb255-22"><a href="#cb255-22"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">1</span>},</span>
<span id="cb255-23"><a href="#cb255-23"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb255-24"><a href="#cb255-24"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb255-25"><a href="#cb255-25"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb255-26"><a href="#cb255-26"></a>                code.Make(code.OpHash, <span class="dv">2</span>),</span>
<span id="cb255-27"><a href="#cb255-27"></a>                code.Make(code.OpConstant, <span class="dv">2</span>),</span>
<span id="cb255-28"><a href="#cb255-28"></a>                code.Make(code.OpConstant, <span class="dv">3</span>),</span>
<span id="cb255-29"><a href="#cb255-29"></a>                code.Make(code.OpSub),</span>
<span id="cb255-30"><a href="#cb255-30"></a>                code.Make(code.OpIndex),</span>
<span id="cb255-31"><a href="#cb255-31"></a>                code.Make(code.OpPop),</span>
<span id="cb255-32"><a href="#cb255-32"></a>            },</span>
<span id="cb255-33"><a href="#cb255-33"></a>        },</span>
<span id="cb255-34"><a href="#cb255-34"></a>    }</span>
<span id="cb255-35"><a href="#cb255-35"></a></span>
<span id="cb255-36"><a href="#cb255-36"></a>    runCompilerTests(t, tests)</span>
<span id="cb255-37"><a href="#cb255-37"></a>}</span></code></pre></div>
<p>What we’re making sure of here is that we can compile both array and hash literals as part of an index-operator expression and that the index itself can be any expression.</p>
<p>It’s important to note that the compiler doesn’t have to care about what is being indexed, what the index is or whether or not the whole operation is valid. That’s the job of the VM and also the reason why we don’t have any test cases for empty arrays or non-existent indexes here. All we need to do in the compiler is to compile two expression and emit an <code>OpIndex</code> instruction:</p>
<div class="sourceCode" id="cb256"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb256-1"><a href="#cb256-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb256-2"><a href="#cb256-2"></a></span>
<span id="cb256-3"><a href="#cb256-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb256-4"><a href="#cb256-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb256-5"><a href="#cb256-5"></a>    <span class="co">// [...]</span></span>
<span id="cb256-6"><a href="#cb256-6"></a></span>
<span id="cb256-7"><a href="#cb256-7"></a>    <span class="kw">case</span> *ast.IndexExpression:</span>
<span id="cb256-8"><a href="#cb256-8"></a>        err := c.Compile(node.Left)</span>
<span id="cb256-9"><a href="#cb256-9"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb256-10"><a href="#cb256-10"></a>            <span class="kw">return</span> err</span>
<span id="cb256-11"><a href="#cb256-11"></a>        }</span>
<span id="cb256-12"><a href="#cb256-12"></a></span>
<span id="cb256-13"><a href="#cb256-13"></a>        err = c.Compile(node.Index)</span>
<span id="cb256-14"><a href="#cb256-14"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb256-15"><a href="#cb256-15"></a>            <span class="kw">return</span> err</span>
<span id="cb256-16"><a href="#cb256-16"></a>        }</span>
<span id="cb256-17"><a href="#cb256-17"></a></span>
<span id="cb256-18"><a href="#cb256-18"></a>        c.emit(code.OpIndex)</span>
<span id="cb256-19"><a href="#cb256-19"></a></span>
<span id="cb256-20"><a href="#cb256-20"></a>    <span class="co">// [...]</span></span>
<span id="cb256-21"><a href="#cb256-21"></a>    }</span>
<span id="cb256-22"><a href="#cb256-22"></a></span>
<span id="cb256-23"><a href="#cb256-23"></a>    <span class="co">// [...]</span></span>
<span id="cb256-24"><a href="#cb256-24"></a>}</span></code></pre></div>
<p>We first compile the object being indexed, <code>node.Left</code>, and then the <code>node.Index</code>. Both are <code>ast.Expression</code>s, which means that we don’t have to worry about what they are exactly – other parts of <code>Compile</code> already take care of that:</p>
<div class="sourceCode" id="cb257"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb257-1"><a href="#cb257-1"></a>$ go test ./compiler</span>
<span id="cb257-2"><a href="#cb257-2"></a>ok      monkey/compiler 0.009s</span></code></pre></div>
<p>And <em>now</em> we can start to worry about edge cases, because we can move on to the VM and write tests there:</p>
<div class="sourceCode" id="cb258"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb258-1"><a href="#cb258-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb258-2"><a href="#cb258-2"></a></span>
<span id="cb258-3"><a href="#cb258-3"></a><span class="kw">func</span> TestIndexExpressions(t *testing.T) {</span>
<span id="cb258-4"><a href="#cb258-4"></a>    tests := []vmTestCase{</span>
<span id="cb258-5"><a href="#cb258-5"></a>        {<span class="st">&quot;[1, 2, 3][1]&quot;</span>, <span class="dv">2</span>},</span>
<span id="cb258-6"><a href="#cb258-6"></a>        {<span class="st">&quot;[1, 2, 3][0 + 2]&quot;</span>, <span class="dv">3</span>},</span>
<span id="cb258-7"><a href="#cb258-7"></a>        {<span class="st">&quot;[[1, 1, 1]][0][0]&quot;</span>, <span class="dv">1</span>},</span>
<span id="cb258-8"><a href="#cb258-8"></a>        {<span class="st">&quot;[][0]&quot;</span>, Null},</span>
<span id="cb258-9"><a href="#cb258-9"></a>        {<span class="st">&quot;[1, 2, 3][99]&quot;</span>, Null},</span>
<span id="cb258-10"><a href="#cb258-10"></a>        {<span class="st">&quot;[1][-1]&quot;</span>, Null},</span>
<span id="cb258-11"><a href="#cb258-11"></a>        {<span class="st">&quot;{1: 1, 2: 2}[1]&quot;</span>, <span class="dv">1</span>},</span>
<span id="cb258-12"><a href="#cb258-12"></a>        {<span class="st">&quot;{1: 1, 2: 2}[2]&quot;</span>, <span class="dv">2</span>},</span>
<span id="cb258-13"><a href="#cb258-13"></a>        {<span class="st">&quot;{1: 1}[0]&quot;</span>, Null},</span>
<span id="cb258-14"><a href="#cb258-14"></a>        {<span class="st">&quot;{}[0]&quot;</span>, Null},</span>
<span id="cb258-15"><a href="#cb258-15"></a>    }</span>
<span id="cb258-16"><a href="#cb258-16"></a></span>
<span id="cb258-17"><a href="#cb258-17"></a>    runVmTests(t, tests)</span>
<span id="cb258-18"><a href="#cb258-18"></a>}</span></code></pre></div>
<p>Here we can find all the things that didn’t make an appearance in the compiler test: valid indexes, invalid indexes, arrays within arrays, empty hashes, empty arrays – it’s all there and it all needs to work.</p>
<p>The essence is that with a valid index we expect the corresponding element to end up on the stack and in the cases where the index is invalid we expect <code>vm.Null</code> instead:</p>
<div class="sourceCode" id="cb259"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb259-1"><a href="#cb259-1"></a>$ go test ./vm</span>
<span id="cb259-2"><a href="#cb259-2"></a>--- FAIL: TestIndexExpressions (0.00s)</span>
<span id="cb259-3"><a href="#cb259-3"></a> vm_test.go:400: testIntegerObject failed: object has wrong value.\</span>
<span id="cb259-4"><a href="#cb259-4"></a>   got=1, want=2</span>
<span id="cb259-5"><a href="#cb259-5"></a> vm_test.go:400: testIntegerObject failed: object has wrong value.\</span>
<span id="cb259-6"><a href="#cb259-6"></a>   got=2, want=3</span>
<span id="cb259-7"><a href="#cb259-7"></a> vm_test.go:400: testIntegerObject failed: object has wrong value.\</span>
<span id="cb259-8"><a href="#cb259-8"></a>   got=0, want=1</span>
<span id="cb259-9"><a href="#cb259-9"></a> vm_test.go:404: object is not Null: *object.Integer (&amp;{Value:0})</span>
<span id="cb259-10"><a href="#cb259-10"></a> vm_test.go:404: object is not Null: *object.Integer (&amp;{Value:99})</span>
<span id="cb259-11"><a href="#cb259-11"></a> vm_test.go:404: object is not Null: *object.Integer (&amp;{Value:-1})</span>
<span id="cb259-12"><a href="#cb259-12"></a> vm_test.go:404: object is not Null: *object.Integer (&amp;{Value:0})</span>
<span id="cb259-13"><a href="#cb259-13"></a> vm_test.go:404: object is not Null: *object.Integer (&amp;{Value:0})</span>
<span id="cb259-14"><a href="#cb259-14"></a>FAIL</span>
<span id="cb259-15"><a href="#cb259-15"></a>FAIL    monkey/vm   0.036s</span></code></pre></div>
<p>While these error messages are nice, they’re not what we’re after. What we want is for our VM to decode and execute <code>OpIndex</code> instructions:</p>
<div class="sourceCode" id="cb260"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb260-1"><a href="#cb260-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb260-2"><a href="#cb260-2"></a></span>
<span id="cb260-3"><a href="#cb260-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb260-4"><a href="#cb260-4"></a>    <span class="co">// [...]</span></span>
<span id="cb260-5"><a href="#cb260-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb260-6"><a href="#cb260-6"></a>        <span class="co">// [...]</span></span>
<span id="cb260-7"><a href="#cb260-7"></a></span>
<span id="cb260-8"><a href="#cb260-8"></a>        <span class="kw">case</span> code.OpIndex:</span>
<span id="cb260-9"><a href="#cb260-9"></a>            index := vm.pop()</span>
<span id="cb260-10"><a href="#cb260-10"></a>            left := vm.pop()</span>
<span id="cb260-11"><a href="#cb260-11"></a></span>
<span id="cb260-12"><a href="#cb260-12"></a>            err := vm.executeIndexExpression(left, index)</span>
<span id="cb260-13"><a href="#cb260-13"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb260-14"><a href="#cb260-14"></a>                <span class="kw">return</span> err</span>
<span id="cb260-15"><a href="#cb260-15"></a>            }</span>
<span id="cb260-16"><a href="#cb260-16"></a></span>
<span id="cb260-17"><a href="#cb260-17"></a>        <span class="co">// [...]</span></span>
<span id="cb260-18"><a href="#cb260-18"></a>        }</span>
<span id="cb260-19"><a href="#cb260-19"></a>    <span class="co">// [...]</span></span>
<span id="cb260-20"><a href="#cb260-20"></a>}</span></code></pre></div>
<p>The topmost element on the stack is supposed to be the <code>index</code>, so we pop that off first. Then we pop off the <code>left</code> side of the index operator, the object being indexed. Again, it’s important that the order matches the one used in the compiler – you can imagine what happens when we mix it up.</p>
<p>Once we have <code>index</code> and <code>left</code> and are ready to do some indexing, we delegate to <code>executeIndexExpression</code>:</p>
<div class="sourceCode" id="cb261"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb261-1"><a href="#cb261-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb261-2"><a href="#cb261-2"></a></span>
<span id="cb261-3"><a href="#cb261-3"></a><span class="kw">func</span> (vm *VM) executeIndexExpression(left, index object.Object) <span class="dt">error</span> {</span>
<span id="cb261-4"><a href="#cb261-4"></a>    <span class="kw">switch</span> {</span>
<span id="cb261-5"><a href="#cb261-5"></a>    <span class="kw">case</span> left.Type() == object.ARRAY_OBJ &amp;&amp; index.Type() == object.INTEGER_OBJ:</span>
<span id="cb261-6"><a href="#cb261-6"></a>        <span class="kw">return</span> vm.executeArrayIndex(left, index)</span>
<span id="cb261-7"><a href="#cb261-7"></a>    <span class="kw">case</span> left.Type() == object.HASH_OBJ:</span>
<span id="cb261-8"><a href="#cb261-8"></a>        <span class="kw">return</span> vm.executeHashIndex(left, index)</span>
<span id="cb261-9"><a href="#cb261-9"></a>    <span class="kw">default</span>:</span>
<span id="cb261-10"><a href="#cb261-10"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;index operator not supported: %s&quot;</span>, left.Type())</span>
<span id="cb261-11"><a href="#cb261-11"></a>    }</span>
<span id="cb261-12"><a href="#cb261-12"></a>}</span></code></pre></div>
<p>That’s close to the <code>executeBinaryOperation</code> method we already have. It performs type checking of the <code>left</code> and <code>index</code>, but also delegates the actual indexing to other methods. The first of these is <code>executeArrayIndex</code>, which does what its name promises:</p>
<div class="sourceCode" id="cb262"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb262-1"><a href="#cb262-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb262-2"><a href="#cb262-2"></a></span>
<span id="cb262-3"><a href="#cb262-3"></a><span class="kw">func</span> (vm *VM) executeArrayIndex(array, index object.Object) <span class="dt">error</span> {</span>
<span id="cb262-4"><a href="#cb262-4"></a>    arrayObject := array.(*object.Array)</span>
<span id="cb262-5"><a href="#cb262-5"></a>    i := index.(*object.Integer).Value</span>
<span id="cb262-6"><a href="#cb262-6"></a>    max := <span class="dt">int64</span>(<span class="bu">len</span>(arrayObject.Elements) - <span class="dv">1</span>)</span>
<span id="cb262-7"><a href="#cb262-7"></a></span>
<span id="cb262-8"><a href="#cb262-8"></a>    <span class="kw">if</span> i &lt; <span class="dv">0</span> || i &gt; max {</span>
<span id="cb262-9"><a href="#cb262-9"></a>        <span class="kw">return</span> vm.push(Null)</span>
<span id="cb262-10"><a href="#cb262-10"></a>    }</span>
<span id="cb262-11"><a href="#cb262-11"></a></span>
<span id="cb262-12"><a href="#cb262-12"></a>    <span class="kw">return</span> vm.push(arrayObject.Elements[i])</span>
<span id="cb262-13"><a href="#cb262-13"></a>}</span></code></pre></div>
<p>If it weren’t for the bounds checking, this method could be much shorter. But we do want to check that the index is within the bounds of the array being indexed – that’s what we expect in our tests. If the index does not match an element in the array, we push <code>Null</code> on to the stack. And if it does match, we push the element.</p>
<p>In <code>executeHashIndex</code> we do not have to do bounds checking, but we have to check whether the given index can be used as an <code>object.HashKey</code>:</p>
<div class="sourceCode" id="cb263"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb263-1"><a href="#cb263-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb263-2"><a href="#cb263-2"></a></span>
<span id="cb263-3"><a href="#cb263-3"></a><span class="kw">func</span> (vm *VM) executeHashIndex(hash, index object.Object) <span class="dt">error</span> {</span>
<span id="cb263-4"><a href="#cb263-4"></a>    hashObject := hash.(*object.Hash)</span>
<span id="cb263-5"><a href="#cb263-5"></a></span>
<span id="cb263-6"><a href="#cb263-6"></a>    key, ok := index.(object.Hashable)</span>
<span id="cb263-7"><a href="#cb263-7"></a>    <span class="kw">if</span> !ok {</span>
<span id="cb263-8"><a href="#cb263-8"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;unusable as hash key: %s&quot;</span>, index.Type())</span>
<span id="cb263-9"><a href="#cb263-9"></a>    }</span>
<span id="cb263-10"><a href="#cb263-10"></a></span>
<span id="cb263-11"><a href="#cb263-11"></a>    pair, ok := hashObject.Pairs[key.HashKey()]</span>
<span id="cb263-12"><a href="#cb263-12"></a>    <span class="kw">if</span> !ok {</span>
<span id="cb263-13"><a href="#cb263-13"></a>        <span class="kw">return</span> vm.push(Null)</span>
<span id="cb263-14"><a href="#cb263-14"></a>    }</span>
<span id="cb263-15"><a href="#cb263-15"></a></span>
<span id="cb263-16"><a href="#cb263-16"></a>    <span class="kw">return</span> vm.push(pair.Value)</span>
<span id="cb263-17"><a href="#cb263-17"></a>}</span></code></pre></div>
<p>If the given <code>index</code> can be turned into an <code>object.Hashable</code>, we try to fetch the matching element from <code>hashObject.Pairs</code>. And here, too, we push the element if we were successful and if not, we push <code>vm.Null</code>. That also matches our test expectations.</p>
<p>Let’s take a look at the tests themselves now:</p>
<div class="sourceCode" id="cb264"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb264-1"><a href="#cb264-1"></a>$ go test ./vm</span>
<span id="cb264-2"><a href="#cb264-2"></a>ok      monkey/vm   0.036s</span></code></pre></div>
<p>That means, we made it! We’ve reached our goal. We can now successfully execute what we set out to implement:</p>
<div class="sourceCode" id="cb265"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb265-1"><a href="#cb265-1"></a>$ go build -o monkey . &amp;&amp; ./monkey</span>
<span id="cb265-2"><a href="#cb265-2"></a>Hello mrnugget! This is the Monkey programming language!</span>
<span id="cb265-3"><a href="#cb265-3"></a>Feel free to type in commands</span>
<span id="cb265-4"><a href="#cb265-4"></a>&gt;&gt; [1, 2, 3][1]</span>
<span id="cb265-5"><a href="#cb265-5"></a>2</span>
<span id="cb265-6"><a href="#cb265-6"></a>&gt;&gt; {&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3}[&quot;o&quot; + &quot;ne&quot;]</span>
<span id="cb265-7"><a href="#cb265-7"></a>1</span>
<span id="cb265-8"><a href="#cb265-8"></a>&gt;&gt;</span></code></pre></div>
<p>We’ve reached the end of the chapter. We can construct strings, arrays, hashes, concatenate strings and now also access elements in our compound data types – but, sadly, no more than that.</p>
<p>In <em>Writing An Interpreter In Go</em> we had additional, built-in functions to perform operations with the data structures: accessing the first and last elements, getting the number of elements, and so on. They are very useful and we’re going implement them in our new Monkey compiler and virtual machine too. But before we can add built-in functions, we need to implement functions.</p>
<h1 id="functions">Functions</h1>
<p>This is one of the most demanding chapters in the book. At its end, we’ll have implemented functions and function calls, complete with local bindings and function-call arguments. But to get there, we have to do a lot of thinking and make many tiny changes that look innocent but have great impact on our Monkey implementation. We’ll come across more than one challenge along the way. Because, you see, the problem with implementing functions is this: it’s not just one problem.</p>
<p>The first one is the question of how to represent functions. The naive assumption is that functions are a series of instructions. But in Monkey functions are also first-class citizens that can be passed around and returned from other functions. How do we represent a series of instructions that can be passed around?</p>
<p>Once we answer that, there’s the issue of control flow. How do we get our VM to execute the instructions of a function? And, let’s say, we managed to do that, how do we get it to <em>return back</em> to the instructions it was previously executing? And while we’re at it: how do we get it to pass <em>arguments to functions</em>?</p>
<p>These are the big questions – followed by a myriad of smaller ones, that are hard to ignore. Rest assured, we’ll answer all of them. Just not all at once. Instead, we’re going to weave many different parts into a coherent whole by taking well-considered baby steps, which is also what makes this chapter incredible fun.</p>
<h2 id="dipping-our-toes-a-simple-function">Dipping Our Toes: a Simple Function</h2>
<p>Our goal for this first section is to “only” get this seemingly-simple piece of Monkey code compiled and executed:</p>
<div class="sourceCode" id="cb266"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb266-1"><a href="#cb266-1"></a><span class="kw">let</span> fivePlusTen <span class="op">=</span> fn() { <span class="dv">5</span> <span class="op">+</span> <span class="dv">10</span> }<span class="op">;</span></span>
<span id="cb266-2"><a href="#cb266-2"></a>fivePlusTen()<span class="op">;</span></span></code></pre></div>
<p>This function has no parameters. It doesn’t use local bindings. It’s called without arguments and doesn’t access global bindings. While I’d wager that there aren’t many highly-complex Monkey programs in existence, this one is definitely one of the simpler ones. Still, it poses multiple challenges.</p>
<h3 id="representing-functions">Representing Functions</h3>
<p>Before we can even think about compiling or executing this function, we run into the first challenge: how do we represent functions?</p>
<p>We know that a function consists of Monkey code. We also know that we compile Monkey code to Monkey bytecode. It follows that our compiler should turn functions into <em>at least</em> a series of Monkey bytecode instructions. The question is, then, where do we store this series of instructions and how do we hand it to the VM?</p>
<p>We already pass the instructions of the main program to the VM, but we can’t just mix those with the instructions of a function. If we did that, we would have to untangle them again in the VM in order to execute them one by one. It’s best to keep them separate from the start.</p>
<p>The answer to our question lies in the fact that Monkey functions are Monkey values. They can be bound to names, returned from other functions, passed to other functions as arguments and much more – just like any other Monkey value. And like other values, they’re also produced by expressions.</p>
<p>These expressions are the function literals, the <em>literal</em> representation of functions in Monkey code. In the example above, the function literal is this part:</p>
<div class="sourceCode" id="cb267"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb267-1"><a href="#cb267-1"></a>fn() { <span class="dv">5</span> <span class="op">+</span> <span class="dv">10</span> }</span></code></pre></div>
<p>The curious thing about function literals is that the value they produce doesn’t change. Ever. It’s constant. And that’s the last hint we need.</p>
<p>We’ll treat function literals like the other literals that produce constant values and pass them to the VM as – here it comes – constants. We’ll compile them into sequences of instructions and add those to the compiler’s pool of constants. An <code>OpConstant</code> instruction then takes care of putting the compiled function on to the stack – just like any other value.</p>
<p>Now, the remaining question is how to exactly represent these sequences of instructions, so they can be added to the constant pool and loaded on to the stack.</p>
<p>In <em>Writing An Interpreter In Go</em> we defined <code>object.Function</code>, a Monkey object that represents evaluated function literals which itself can be evaluated. Now we need an updated version of that: a function object that holds bytecode instead of AST nodes.</p>
<p>For that, we open up our <code>object</code> package and introduce the new <code>object.CompiledFunction</code>:</p>
<div class="sourceCode" id="cb268"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb268-1"><a href="#cb268-1"></a><span class="co">// object/object.go</span></span>
<span id="cb268-2"><a href="#cb268-2"></a></span>
<span id="cb268-3"><a href="#cb268-3"></a><span class="kw">import</span> (</span>
<span id="cb268-4"><a href="#cb268-4"></a>    <span class="co">// [...]</span></span>
<span id="cb268-5"><a href="#cb268-5"></a>    <span class="st">&quot;monkey/code&quot;</span></span>
<span id="cb268-6"><a href="#cb268-6"></a>    <span class="co">// [...]</span></span>
<span id="cb268-7"><a href="#cb268-7"></a>)</span>
<span id="cb268-8"><a href="#cb268-8"></a></span>
<span id="cb268-9"><a href="#cb268-9"></a><span class="kw">const</span> (</span>
<span id="cb268-10"><a href="#cb268-10"></a>    <span class="co">// [...]</span></span>
<span id="cb268-11"><a href="#cb268-11"></a></span>
<span id="cb268-12"><a href="#cb268-12"></a>    COMPILED_FUNCTION_OBJ = <span class="st">&quot;COMPILED_FUNCTION_OBJ&quot;</span></span>
<span id="cb268-13"><a href="#cb268-13"></a>)</span>
<span id="cb268-14"><a href="#cb268-14"></a></span>
<span id="cb268-15"><a href="#cb268-15"></a><span class="kw">type</span> CompiledFunction <span class="kw">struct</span> {</span>
<span id="cb268-16"><a href="#cb268-16"></a>    Instructions code.Instructions</span>
<span id="cb268-17"><a href="#cb268-17"></a>}</span>
<span id="cb268-18"><a href="#cb268-18"></a></span>
<span id="cb268-19"><a href="#cb268-19"></a><span class="kw">func</span> (cf *CompiledFunction) Type() ObjectType { <span class="kw">return</span> COMPILED_FUNCTION_OBJ }</span>
<span id="cb268-20"><a href="#cb268-20"></a><span class="kw">func</span> (cf *CompiledFunction) Inspect() <span class="dt">string</span> {</span>
<span id="cb268-21"><a href="#cb268-21"></a>    <span class="kw">return</span> fmt.Sprintf(<span class="st">&quot;CompiledFunction[%p]&quot;</span>, cf)</span>
<span id="cb268-22"><a href="#cb268-22"></a>}</span></code></pre></div>
<p><code>object.CompiledFunction</code> is everything we need: it can hold the <code>code.Instructions</code> we get from the compilation of a function literal and it’s an <code>object.Object</code>, which means we can add it as a constant to our <code>compiler.Bytecode</code> and load it in the VM.</p>
<p>First problem solved. Let’s start thinking about compilation.</p>
<h3 id="opcodes-to-execute-functions">Opcodes to Execute Functions</h3>
<p>The first question we have to ask ourselves is whether we need new opcodes to achieve our goal of compiling and executing the snippet of Monkey code from above.</p>
<p>Let’s start with what we <em>don’t</em> need: an opcode for function literals. Since we decided to compile them to <code>*object.CompiledFunction</code>s and treat those as constants, they can be loaded on to the stack of the VM with our existing <code>OpConstant</code> instructions.</p>
<p>So, in terms of opcodes, we can cross off the first line of the snippet:</p>
<div class="sourceCode" id="cb269"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb269-1"><a href="#cb269-1"></a><span class="kw">let</span> fivePlusTen <span class="op">=</span> fn() { <span class="dv">5</span> <span class="op">+</span> <span class="dv">10</span> }<span class="op">;</span></span>
<span id="cb269-2"><a href="#cb269-2"></a>fivePlusTen()<span class="op">;</span></span></code></pre></div>
<p>Once we have compiled the function literal to an <code>*object.CompiledFunction</code> we already know how to bind it to the <code>fivePlusTen</code> name. We have global bindings in place and they work with any <code>object.Object</code>.</p>
<p>But we do need an opcode for the second line: <code>fivePlusTen()</code>. That’s a call expression, represented in our AST by <code>*ast.CallExpression</code>, and it must be compiled to an instruction that tells the VM to execute the function in question.</p>
<p>Since we don’t have an opcode that fits this need, we need to define a new one now. It’s called <code>OpCall</code> and it doesn’t have any operands:</p>
<div class="sourceCode" id="cb270"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb270-1"><a href="#cb270-1"></a><span class="co">// code/code.go</span></span>
<span id="cb270-2"><a href="#cb270-2"></a></span>
<span id="cb270-3"><a href="#cb270-3"></a><span class="kw">const</span> (</span>
<span id="cb270-4"><a href="#cb270-4"></a>    <span class="co">// [...]</span></span>
<span id="cb270-5"><a href="#cb270-5"></a></span>
<span id="cb270-6"><a href="#cb270-6"></a>    OpCall</span>
<span id="cb270-7"><a href="#cb270-7"></a>)</span>
<span id="cb270-8"><a href="#cb270-8"></a></span>
<span id="cb270-9"><a href="#cb270-9"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb270-10"><a href="#cb270-10"></a>    <span class="co">// [...]</span></span>
<span id="cb270-11"><a href="#cb270-11"></a></span>
<span id="cb270-12"><a href="#cb270-12"></a>    OpCall: {<span class="st">&quot;OpCall&quot;</span>, []<span class="dt">int</span>{}},</span>
<span id="cb270-13"><a href="#cb270-13"></a>}</span></code></pre></div>
<p>Here’s how it will be used. First, we get the function we want to call on to the stack. For example, with an <code>OpConstant</code> instruction. Then, we issue an <code>OpCall</code> instruction. That tells the VM to execute the function on top of the stack and off we go.</p>
<p>This little instruction manual for <code>OpCall</code> is what’s called a <em>calling convention</em>. Once we add support for function call arguments it will have to change, but for now, it’s just two steps: put the function you want to call on to the stack, issue an <code>OpCall</code> instruction.</p>
<p>With <code>OpCall</code> defined, we are now – in theory – able to get a function on to the stack of our VM and call it. What we still need is a way to tell the VM to return from a called function.</p>
<p>More specifically, we need to differentiate between two cases where the VM has to return from a function. The first case is a function actually returning <em>something</em>, implicitly or explicitly. The second one is when the execution of a function ends without anything being returned, e.g. the function has an empty function body.</p>
<p>Let’s talk about the former case first, the explicit and implicit returning of values. Monkey supports both:</p>
<div class="sourceCode" id="cb271"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb271-1"><a href="#cb271-1"></a><span class="kw">let</span> explicitReturn <span class="op">=</span> fn() { <span class="cf">return</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">10</span><span class="op">;</span> }<span class="op">;</span></span>
<span id="cb271-2"><a href="#cb271-2"></a><span class="kw">let</span> implicitReturn <span class="op">=</span> fn() { <span class="dv">5</span> <span class="op">+</span> <span class="dv">10</span><span class="op">;</span> }<span class="op">;</span></span></code></pre></div>
<p>An explicit return statement stops the execution of the rest of the function and returns the value produced by the expression following the <code>return</code> keyword. In the case above, that’s the infix expression <code>5 + 10</code>.</p>
<p>Without a <code>return</code> statement, a function call evaluates to the last value produced inside the function. That’s what’s called <em>implicit return</em>.</p>
<p>In the evaluator we built in <em>Writing An Interpreter In Go</em> the implicit returning of values was the default case. Explicit return statements were an additional feature we had to build.</p>
<p>This time, though, the implicit return will be a slight variation of the explicit return. Or, in other words, these two will compile to the same bytecode:</p>
<div class="sourceCode" id="cb272"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb272-1"><a href="#cb272-1"></a>fn() { <span class="dv">5</span> <span class="op">+</span> <span class="dv">10</span> }</span>
<span id="cb272-2"><a href="#cb272-2"></a>fn() { <span class="cf">return</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">10</span> }</span></code></pre></div>
<p>That means, for one, that both implicit and explicit returns are the same under the hood – always a joy to us programmers. But it also means we have to implement both mechanisms in order to get the <code>fivePlusTen</code> function from above compiled and running. No shortcuts, even if we only use implicit returns. But this increased effort in the compiler <em>now</em> will make things a lot easier in the VM later on.</p>
<p>Since they’re both compiled down to the same bytecode, implicit and explicit returns will also be represented by the same opcode. It’s called <code>OpReturnValue</code> and tells the VM to return from the function <em>with a return value</em>:</p>
<div class="sourceCode" id="cb273"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb273-1"><a href="#cb273-1"></a><span class="co">// code/code.go</span></span>
<span id="cb273-2"><a href="#cb273-2"></a></span>
<span id="cb273-3"><a href="#cb273-3"></a><span class="kw">const</span> (</span>
<span id="cb273-4"><a href="#cb273-4"></a>    <span class="co">// [...]</span></span>
<span id="cb273-5"><a href="#cb273-5"></a></span>
<span id="cb273-6"><a href="#cb273-6"></a>    OpReturnValue</span>
<span id="cb273-7"><a href="#cb273-7"></a>)</span>
<span id="cb273-8"><a href="#cb273-8"></a></span>
<span id="cb273-9"><a href="#cb273-9"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb273-10"><a href="#cb273-10"></a>    <span class="co">// [...]</span></span>
<span id="cb273-11"><a href="#cb273-11"></a></span>
<span id="cb273-12"><a href="#cb273-12"></a>    OpReturnValue: {<span class="st">&quot;OpReturnValue&quot;</span>, []<span class="dt">int</span>{}},</span>
<span id="cb273-13"><a href="#cb273-13"></a>}</span></code></pre></div>
<p>It doesn’t have any arguments. The value to be returned has to sit on top of the stack.</p>
<p>It’s clear when and how to emit this opcode in the case of explicit returns. First, compile the return statement so the return value will end up on the stack, then emit an <code>OpReturnValue</code>. No puzzles here, just like we want it.</p>
<p>Implementing implicit returning of values takes slightly more effort, since it also means returning the value produced by an expression statement – if it was the last executed statement in a function’s body. But previously we made sure that an expression statement does not leave a value behind. We explicitly emit an <code>OpPop</code> instructions to get rid of it. If we now want to return the value, we need to find a way to combine our need for a clean stack with our desire for implicit returns. But we’ll do, you’ll see. For now, though, put this issue in the back of your mind.</p>
<p>Let’s talk about the second and much rarer case when returning from a function: a function returning nothing. Neither explicitly nor implicitly. Since nearly everything in Monkey is an expression that produces a value, it’s an achievement to even come up with such a function, but they do exist. Here’s one:</p>
<div class="sourceCode" id="cb274"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb274-1"><a href="#cb274-1"></a>fn() { }</span></code></pre></div>
<p>That’s a function with an empty body. Compiling it would produce a valid <code>*object.CompiledFunction</code> that can be called, but doesn’t have any instructions. Another example, which we’ll meet later on again, when we talk about local bindings, is this one:</p>
<div class="sourceCode" id="cb275"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb275-1"><a href="#cb275-1"></a>fn() { <span class="kw">let</span> a <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> }</span></code></pre></div>
<p>Granted, a function that returns nothing is an edge case. We didn’t even handle it in the first book. But now it sits in front of us, next to an unanswered question: what should these functions produce? Since a function call is an expression and expressions produce values, to be consistent, these functions, too, should produce a value.</p>
<p>We could ignore the whole issue by putting it in a file called <code>undefined_behaviour.txt</code> and calling it a day. We could. Or we could make these functions return <code>*object.Null</code>. Since in Monkey an <code>*object.Null</code> signifies the absence of a value, it does make sense for a function that didn’t produce a value to return it.</p>
<p>Decision made, which means we need to tell our VM to return <code>vm.Null</code> from a function in case it has no <code>OpReturnValue</code> instruction at its end. We’ll do that by introducing another opcode.</p>
<p>The previously-defined <code>OpReturnValue</code> tells the VM to return the value sitting on top of the stack. The new opcode, which we’ll call <code>OpReturn</code>, will also tell the VM to return from the current function, except this time, there’s nothing on the stack, no return value, nothing. Just go back to what you were doing before calling this function.</p>
<p>Here is its definition:</p>
<div class="sourceCode" id="cb276"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb276-1"><a href="#cb276-1"></a><span class="co">// code/code.go</span></span>
<span id="cb276-2"><a href="#cb276-2"></a></span>
<span id="cb276-3"><a href="#cb276-3"></a><span class="kw">const</span> (</span>
<span id="cb276-4"><a href="#cb276-4"></a>    <span class="co">// [...]</span></span>
<span id="cb276-5"><a href="#cb276-5"></a></span>
<span id="cb276-6"><a href="#cb276-6"></a>    OpReturn</span>
<span id="cb276-7"><a href="#cb276-7"></a>)</span>
<span id="cb276-8"><a href="#cb276-8"></a></span>
<span id="cb276-9"><a href="#cb276-9"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb276-10"><a href="#cb276-10"></a>    <span class="co">// [...]</span></span>
<span id="cb276-11"><a href="#cb276-11"></a></span>
<span id="cb276-12"><a href="#cb276-12"></a>    OpReturn: {<span class="st">&quot;OpReturn&quot;</span>, []<span class="dt">int</span>{}},</span>
<span id="cb276-13"><a href="#cb276-13"></a>}</span></code></pre></div>
<p>That makes three new opcodes – enough to get started in the compiler.</p>
<h3 id="compiling-function-literals">Compiling Function Literals</h3>
<p>Before we start opening our <code>compiler/compiler_test.go</code> file, a little inventory check. We now have in place:</p>
<ul>
<li><code>object.CompiledFunction</code> to hold the instructions of a compiled function and to pass them from the compiler to the VM as part of the bytecode, as a constant.</li>
<li><code>code.OpCall</code> to tell the VM to start executing the <code>*object.CompiledFunction</code> sitting on top of the stack.</li>
<li><code>code.OpReturnValue</code> to tell the VM to return the value on top of the stack to the calling context and to resume execution there.</li>
<li><code>code.OpReturn</code>, which is similar to <code>code.OpReturnValue</code>, except that there is no explicit value to return but an implicit <code>vm.Null</code>.</li>
</ul>
<p>That’s enough for us to start compiling. But, again, baby steps. Before we can start compiling a function <em>call</em>, we’re going to make sure that we can compile the function being called.</p>
<p>That gives us a clear first task: compile function literals. We’ll take this snippet as our starting point:</p>
<div class="sourceCode" id="cb277"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb277-1"><a href="#cb277-1"></a>fn() { <span class="cf">return</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">10</span> }</span></code></pre></div>
<p>A function without arguments, an integer arithmetic expression in the body, and an <em>explicit return statement</em>. The last point is important. We need to turn the function literal into an <code>*object.CompiledFunction</code> with these instructions in its <code>Instructions</code> field:</p>
<!-- ./ascii_drawings/07/functions_op_return_value_bytecode.monopic -->
<figure>
<img src="./images/07/functions_op_return_value_bytecode.svg" style="width:60.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>And in the main program, contained in <code>Bytecode.Instructions</code>, we need an <code>OpConstant</code> instruction that loads this function on to the stack. Followed by an <code>OpPop</code>, of course, since the returned value is unused.</p>
<p>We can do this. Let’s write the test for it.</p>
<div class="sourceCode" id="cb278"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb278-1"><a href="#cb278-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb278-2"><a href="#cb278-2"></a></span>
<span id="cb278-3"><a href="#cb278-3"></a><span class="kw">func</span> TestFunctions(t *testing.T) {</span>
<span id="cb278-4"><a href="#cb278-4"></a>    tests := []compilerTestCase{</span>
<span id="cb278-5"><a href="#cb278-5"></a>        {</span>
<span id="cb278-6"><a href="#cb278-6"></a>            input: <span class="st">`fn() { return 5 + 10 }`</span>,</span>
<span id="cb278-7"><a href="#cb278-7"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb278-8"><a href="#cb278-8"></a>                <span class="dv">5</span>,</span>
<span id="cb278-9"><a href="#cb278-9"></a>                <span class="dv">10</span>,</span>
<span id="cb278-10"><a href="#cb278-10"></a>                []code.Instructions{</span>
<span id="cb278-11"><a href="#cb278-11"></a>                    code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb278-12"><a href="#cb278-12"></a>                    code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb278-13"><a href="#cb278-13"></a>                    code.Make(code.OpAdd),</span>
<span id="cb278-14"><a href="#cb278-14"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb278-15"><a href="#cb278-15"></a>                },</span>
<span id="cb278-16"><a href="#cb278-16"></a>            },</span>
<span id="cb278-17"><a href="#cb278-17"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb278-18"><a href="#cb278-18"></a>                code.Make(code.OpConstant, <span class="dv">2</span>),</span>
<span id="cb278-19"><a href="#cb278-19"></a>                code.Make(code.OpPop),</span>
<span id="cb278-20"><a href="#cb278-20"></a>            },</span>
<span id="cb278-21"><a href="#cb278-21"></a>        },</span>
<span id="cb278-22"><a href="#cb278-22"></a>    }</span>
<span id="cb278-23"><a href="#cb278-23"></a></span>
<span id="cb278-24"><a href="#cb278-24"></a>    runCompilerTests(t, tests)</span>
<span id="cb278-25"><a href="#cb278-25"></a>}</span></code></pre></div>
<p>At first glance, it doesn’t look like there’s anything new in this test, but <code>expectedConstants</code> now also includes <code>[]code.Instructions</code>.</p>
<p>These are the instructions we want to see in the <code>Instructions</code> field of the <code>*object.CompiledFunction</code>, which is passed around as the constant with the index <code>2</code>. We could’ve put an <code>*object.CompiledFunction</code> directly into <code>expectedConstants</code>, but since we’re only interested in the instructions, we might as well skip the outer layer and make the tests more readable.</p>
<p>Nonetheless, we need to update our tooling so it can now make assertions about <code>[]code.Instructions</code> in <code>expectedConstants</code>:</p>
<div class="sourceCode" id="cb279"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb279-1"><a href="#cb279-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb279-2"><a href="#cb279-2"></a></span>
<span id="cb279-3"><a href="#cb279-3"></a><span class="kw">func</span> testConstants(</span>
<span id="cb279-4"><a href="#cb279-4"></a>    t *testing.T,</span>
<span id="cb279-5"><a href="#cb279-5"></a>    expected []<span class="kw">interface</span>{},</span>
<span id="cb279-6"><a href="#cb279-6"></a>    actual []object.Object,</span>
<span id="cb279-7"><a href="#cb279-7"></a>) <span class="dt">error</span> {</span>
<span id="cb279-8"><a href="#cb279-8"></a>    <span class="co">// [...]</span></span>
<span id="cb279-9"><a href="#cb279-9"></a></span>
<span id="cb279-10"><a href="#cb279-10"></a>    <span class="kw">for</span> i, constant := <span class="kw">range</span> expected {</span>
<span id="cb279-11"><a href="#cb279-11"></a>        <span class="kw">switch</span> constant := constant.(<span class="kw">type</span>) {</span>
<span id="cb279-12"><a href="#cb279-12"></a>        <span class="co">// [...]</span></span>
<span id="cb279-13"><a href="#cb279-13"></a></span>
<span id="cb279-14"><a href="#cb279-14"></a>        <span class="kw">case</span> []code.Instructions:</span>
<span id="cb279-15"><a href="#cb279-15"></a>            fn, ok := actual[i].(*object.CompiledFunction)</span>
<span id="cb279-16"><a href="#cb279-16"></a>            <span class="kw">if</span> !ok {</span>
<span id="cb279-17"><a href="#cb279-17"></a>                <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;constant %d - not a function: %T&quot;</span>,</span>
<span id="cb279-18"><a href="#cb279-18"></a>                    i, actual[i])</span>
<span id="cb279-19"><a href="#cb279-19"></a>            }</span>
<span id="cb279-20"><a href="#cb279-20"></a></span>
<span id="cb279-21"><a href="#cb279-21"></a>            err := testInstructions(constant, fn.Instructions)</span>
<span id="cb279-22"><a href="#cb279-22"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb279-23"><a href="#cb279-23"></a>                <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;constant %d - testInstructions failed: %s&quot;</span>,</span>
<span id="cb279-24"><a href="#cb279-24"></a>                    i, err)</span>
<span id="cb279-25"><a href="#cb279-25"></a>            }</span>
<span id="cb279-26"><a href="#cb279-26"></a>        }</span>
<span id="cb279-27"><a href="#cb279-27"></a>    }</span>
<span id="cb279-28"><a href="#cb279-28"></a></span>
<span id="cb279-29"><a href="#cb279-29"></a>    <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb279-30"><a href="#cb279-30"></a>}</span></code></pre></div>
<p>In the new <code>case</code> branch for <code>[]code.Instructions</code> we use <code>testInstructions</code> (which we already had in place), to make sure that the <code>*object.CompiledFunction</code> in the constant pool contains the correct instructions.</p>
<p>And that’s it. Our first test for the compilation of functions. We can now run it and see it fail:</p>
<div class="sourceCode" id="cb280"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb280-1"><a href="#cb280-1"></a>$ go test ./compiler</span>
<span id="cb280-2"><a href="#cb280-2"></a>--- FAIL: TestFunctions (0.00s)</span>
<span id="cb280-3"><a href="#cb280-3"></a> compiler_test.go:296: testInstructions failed: wrong instructions length.</span>
<span id="cb280-4"><a href="#cb280-4"></a>  want=&quot;0000 OpConstant 2\n0003 OpPop\n&quot;</span>
<span id="cb280-5"><a href="#cb280-5"></a>  got =&quot;0000 OpPop\n&quot;</span>
<span id="cb280-6"><a href="#cb280-6"></a>FAIL</span>
<span id="cb280-7"><a href="#cb280-7"></a>FAIL    monkey/compiler 0.008s</span></code></pre></div>
<p>The test doesn’t even get to check the compiled function’s instructions, because the instruction that’s supposed to load the function on to the stack is missing in the main program. And that’s because our compiler does not compile <code>*ast.FunctionLiteral</code>s. Time to change that.</p>
<p>The <code>Body</code> of an <code>*ast.FunctionLiteral</code> is an <code>*ast.BlockStatement</code> and contains a series of <code>ast.Statement</code>s. Since we already know how to compile <code>*ast.BlockStatements</code> from compiling <code>*ast.IfExpression</code>s, compiling the statements in a function’s body shouldn’t be a problem.</p>
<p>But if we were to simply call the compiler’s <code>Compile</code> method with the <code>Body</code> of the <code>*ast.FunctionLiteral</code> at hand, we’d end up with a mess: the resulting instructions would end up being entangled with the instructions of the main program. The solution? Introducing our compiler to the concept of scopes.</p>
<h4 id="adding-scopes">Adding Scopes</h4>
<p>That sounds quite elaborate, but is actually a straightforward change. In practical terms, it means that instead of using a single slice and the two separate fields <code>lastInstruction</code> and <code>previousInstruction</code> to keep track of emitted instructions, we bundle them together in a <em>compilation scope</em> and use <em>a stack of compilation scopes</em>:</p>
<div class="sourceCode" id="cb281"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb281-1"><a href="#cb281-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb281-2"><a href="#cb281-2"></a></span>
<span id="cb281-3"><a href="#cb281-3"></a><span class="kw">type</span> CompilationScope <span class="kw">struct</span> {</span>
<span id="cb281-4"><a href="#cb281-4"></a>    instructions        code.Instructions</span>
<span id="cb281-5"><a href="#cb281-5"></a>    lastInstruction     EmittedInstruction</span>
<span id="cb281-6"><a href="#cb281-6"></a>    previousInstruction EmittedInstruction</span>
<span id="cb281-7"><a href="#cb281-7"></a>}</span>
<span id="cb281-8"><a href="#cb281-8"></a></span>
<span id="cb281-9"><a href="#cb281-9"></a><span class="kw">type</span> Compiler <span class="kw">struct</span> {</span>
<span id="cb281-10"><a href="#cb281-10"></a>    <span class="co">// [...]</span></span>
<span id="cb281-11"><a href="#cb281-11"></a></span>
<span id="cb281-12"><a href="#cb281-12"></a>    scopes     []CompilationScope</span>
<span id="cb281-13"><a href="#cb281-13"></a>    scopeIndex <span class="dt">int</span></span>
<span id="cb281-14"><a href="#cb281-14"></a>}</span></code></pre></div>
<p>Before we start compiling a function’s body, <em>i.e.</em>, enter a new scope, we push a new <code>CompilationScope</code> on to the <code>scopes</code> stack. While compiling inside this scope, the <code>emit</code> method of the compiler will modify only the fields of the current <code>CompilationScope</code>. Once we’re done compiling the function, we leave the scope by popping it off the <code>scopes</code> stack and putting the <code>instructions</code> in a new <code>*object.CompiledFunction</code>.</p>
<p>It sounds way more complicated than it is, I promise. Here’s the test case that shows what we want:</p>
<div class="sourceCode" id="cb282"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb282-1"><a href="#cb282-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb282-2"><a href="#cb282-2"></a></span>
<span id="cb282-3"><a href="#cb282-3"></a><span class="kw">func</span> TestCompilerScopes(t *testing.T) {</span>
<span id="cb282-4"><a href="#cb282-4"></a>    compiler := New()</span>
<span id="cb282-5"><a href="#cb282-5"></a>    <span class="kw">if</span> compiler.scopeIndex != <span class="dv">0</span> {</span>
<span id="cb282-6"><a href="#cb282-6"></a>        t.Errorf(<span class="st">&quot;scopeIndex wrong. got=%d, want=%d&quot;</span>, compiler.scopeIndex, <span class="dv">0</span>)</span>
<span id="cb282-7"><a href="#cb282-7"></a>    }</span>
<span id="cb282-8"><a href="#cb282-8"></a></span>
<span id="cb282-9"><a href="#cb282-9"></a>    compiler.emit(code.OpMul)</span>
<span id="cb282-10"><a href="#cb282-10"></a></span>
<span id="cb282-11"><a href="#cb282-11"></a>    compiler.enterScope()</span>
<span id="cb282-12"><a href="#cb282-12"></a>    <span class="kw">if</span> compiler.scopeIndex != <span class="dv">1</span> {</span>
<span id="cb282-13"><a href="#cb282-13"></a>        t.Errorf(<span class="st">&quot;scopeIndex wrong. got=%d, want=%d&quot;</span>, compiler.scopeIndex, <span class="dv">1</span>)</span>
<span id="cb282-14"><a href="#cb282-14"></a>    }</span>
<span id="cb282-15"><a href="#cb282-15"></a></span>
<span id="cb282-16"><a href="#cb282-16"></a>    compiler.emit(code.OpSub)</span>
<span id="cb282-17"><a href="#cb282-17"></a></span>
<span id="cb282-18"><a href="#cb282-18"></a>    <span class="kw">if</span> <span class="bu">len</span>(compiler.scopes[compiler.scopeIndex].instructions) != <span class="dv">1</span> {</span>
<span id="cb282-19"><a href="#cb282-19"></a>        t.Errorf(<span class="st">&quot;instructions length wrong. got=%d&quot;</span>,</span>
<span id="cb282-20"><a href="#cb282-20"></a>            <span class="bu">len</span>(compiler.scopes[compiler.scopeIndex].instructions))</span>
<span id="cb282-21"><a href="#cb282-21"></a>    }</span>
<span id="cb282-22"><a href="#cb282-22"></a></span>
<span id="cb282-23"><a href="#cb282-23"></a>    last := compiler.scopes[compiler.scopeIndex].lastInstruction</span>
<span id="cb282-24"><a href="#cb282-24"></a>    <span class="kw">if</span> last.Opcode != code.OpSub {</span>
<span id="cb282-25"><a href="#cb282-25"></a>        t.Errorf(<span class="st">&quot;lastInstruction.Opcode wrong. got=%d, want=%d&quot;</span>,</span>
<span id="cb282-26"><a href="#cb282-26"></a>            last.Opcode, code.OpSub)</span>
<span id="cb282-27"><a href="#cb282-27"></a>    }</span>
<span id="cb282-28"><a href="#cb282-28"></a></span>
<span id="cb282-29"><a href="#cb282-29"></a>    compiler.leaveScope()</span>
<span id="cb282-30"><a href="#cb282-30"></a>    <span class="kw">if</span> compiler.scopeIndex != <span class="dv">0</span> {</span>
<span id="cb282-31"><a href="#cb282-31"></a>        t.Errorf(<span class="st">&quot;scopeIndex wrong. got=%d, want=%d&quot;</span>,</span>
<span id="cb282-32"><a href="#cb282-32"></a>            compiler.scopeIndex, <span class="dv">0</span>)</span>
<span id="cb282-33"><a href="#cb282-33"></a>    }</span>
<span id="cb282-34"><a href="#cb282-34"></a></span>
<span id="cb282-35"><a href="#cb282-35"></a>    compiler.emit(code.OpAdd)</span>
<span id="cb282-36"><a href="#cb282-36"></a></span>
<span id="cb282-37"><a href="#cb282-37"></a>    <span class="kw">if</span> <span class="bu">len</span>(compiler.scopes[compiler.scopeIndex].instructions) != <span class="dv">2</span> {</span>
<span id="cb282-38"><a href="#cb282-38"></a>        t.Errorf(<span class="st">&quot;instructions length wrong. got=%d&quot;</span>,</span>
<span id="cb282-39"><a href="#cb282-39"></a>            <span class="bu">len</span>(compiler.scopes[compiler.scopeIndex].instructions))</span>
<span id="cb282-40"><a href="#cb282-40"></a>    }</span>
<span id="cb282-41"><a href="#cb282-41"></a></span>
<span id="cb282-42"><a href="#cb282-42"></a>    last = compiler.scopes[compiler.scopeIndex].lastInstruction</span>
<span id="cb282-43"><a href="#cb282-43"></a>    <span class="kw">if</span> last.Opcode != code.OpAdd {</span>
<span id="cb282-44"><a href="#cb282-44"></a>        t.Errorf(<span class="st">&quot;lastInstruction.Opcode wrong. got=%d, want=%d&quot;</span>,</span>
<span id="cb282-45"><a href="#cb282-45"></a>            last.Opcode, code.OpAdd)</span>
<span id="cb282-46"><a href="#cb282-46"></a>    }</span>
<span id="cb282-47"><a href="#cb282-47"></a></span>
<span id="cb282-48"><a href="#cb282-48"></a>    previous := compiler.scopes[compiler.scopeIndex].previousInstruction</span>
<span id="cb282-49"><a href="#cb282-49"></a>    <span class="kw">if</span> previous.Opcode != code.OpMul {</span>
<span id="cb282-50"><a href="#cb282-50"></a>        t.Errorf(<span class="st">&quot;previousInstruction.Opcode wrong. got=%d, want=%d&quot;</span>,</span>
<span id="cb282-51"><a href="#cb282-51"></a>            previous.Opcode, code.OpMul)</span>
<span id="cb282-52"><a href="#cb282-52"></a>    }</span>
<span id="cb282-53"><a href="#cb282-53"></a>}</span></code></pre></div>
<p>We test two new methods on the <code>compiler</code> here: <code>enterScope</code> and <code>leaveScope</code>. They’re supposed to do what their names promise and change the behaviour of <code>emit</code> by pushing and popping instructions <code>CompilationScope</code>s on the new <code>scopes</code> stack. The main idea behind this test is to make sure that the instructions emitted in one scope should have no effect on the instructions in another scope.</p>
<p>Since the methods do not exist yet, the tests blow up. I’ll spare you the output. Making them pass, though, comes naturally to us since it boils down to using a stack of something and we’re pretty good at that by now.</p>
<p>First, we have to remove the <code>instructions</code>, <code>lastInstruction</code> and <code>previousInstruction</code> fields from the compiler and replace them with a <code>CompilationScope</code> when initializing a new <code>*Compiler</code>:</p>
<div class="sourceCode" id="cb283"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb283-1"><a href="#cb283-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb283-2"><a href="#cb283-2"></a></span>
<span id="cb283-3"><a href="#cb283-3"></a><span class="kw">type</span> Compiler <span class="kw">struct</span> {</span>
<span id="cb283-4"><a href="#cb283-4"></a>    constants []object.Object</span>
<span id="cb283-5"><a href="#cb283-5"></a></span>
<span id="cb283-6"><a href="#cb283-6"></a>    symbolTable *SymbolTable</span>
<span id="cb283-7"><a href="#cb283-7"></a></span>
<span id="cb283-8"><a href="#cb283-8"></a>    scopes     []CompilationScope</span>
<span id="cb283-9"><a href="#cb283-9"></a>    scopeIndex <span class="dt">int</span></span>
<span id="cb283-10"><a href="#cb283-10"></a>}</span>
<span id="cb283-11"><a href="#cb283-11"></a></span>
<span id="cb283-12"><a href="#cb283-12"></a><span class="kw">func</span> New() *Compiler {</span>
<span id="cb283-13"><a href="#cb283-13"></a>    mainScope := CompilationScope{</span>
<span id="cb283-14"><a href="#cb283-14"></a>        instructions:        code.Instructions{},</span>
<span id="cb283-15"><a href="#cb283-15"></a>        lastInstruction:     EmittedInstruction{},</span>
<span id="cb283-16"><a href="#cb283-16"></a>        previousInstruction: EmittedInstruction{},</span>
<span id="cb283-17"><a href="#cb283-17"></a>    }</span>
<span id="cb283-18"><a href="#cb283-18"></a></span>
<span id="cb283-19"><a href="#cb283-19"></a>    <span class="kw">return</span> &amp;Compiler{</span>
<span id="cb283-20"><a href="#cb283-20"></a>        constants:   []object.Object{},</span>
<span id="cb283-21"><a href="#cb283-21"></a>        symbolTable: NewSymbolTable(),</span>
<span id="cb283-22"><a href="#cb283-22"></a>        scopes:      []CompilationScope{mainScope},</span>
<span id="cb283-23"><a href="#cb283-23"></a>        scopeIndex:  <span class="dv">0</span>,</span>
<span id="cb283-24"><a href="#cb283-24"></a>    }</span>
<span id="cb283-25"><a href="#cb283-25"></a>}</span></code></pre></div>
<p>Now we need to update every reference to the removed fields and change them to use the current scope. To help with that we add a new method, called <code>currentInstructions</code>:</p>
<div class="sourceCode" id="cb284"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb284-1"><a href="#cb284-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb284-2"><a href="#cb284-2"></a></span>
<span id="cb284-3"><a href="#cb284-3"></a><span class="kw">func</span> (c *Compiler) currentInstructions() code.Instructions {</span>
<span id="cb284-4"><a href="#cb284-4"></a>    <span class="kw">return</span> c.scopes[c.scopeIndex].instructions</span>
<span id="cb284-5"><a href="#cb284-5"></a>}</span></code></pre></div>
<p>This can now be used in <code>addInstruction</code>, the method <code>emit</code> uses to do its work:</p>
<div class="sourceCode" id="cb285"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb285-1"><a href="#cb285-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb285-2"><a href="#cb285-2"></a></span>
<span id="cb285-3"><a href="#cb285-3"></a><span class="kw">func</span> (c *Compiler) addInstruction(ins []<span class="dt">byte</span>) <span class="dt">int</span> {</span>
<span id="cb285-4"><a href="#cb285-4"></a>    posNewInstruction := <span class="bu">len</span>(c.currentInstructions())</span>
<span id="cb285-5"><a href="#cb285-5"></a>    updatedInstructions := <span class="bu">append</span>(c.currentInstructions(), ins...)</span>
<span id="cb285-6"><a href="#cb285-6"></a></span>
<span id="cb285-7"><a href="#cb285-7"></a>    c.scopes[c.scopeIndex].instructions = updatedInstructions</span>
<span id="cb285-8"><a href="#cb285-8"></a></span>
<span id="cb285-9"><a href="#cb285-9"></a>    <span class="kw">return</span> posNewInstruction</span>
<span id="cb285-10"><a href="#cb285-10"></a>}</span></code></pre></div>
<p>Here we first use <code>c.currentInstructions</code> to get the current slice of instructions and then, in order to mutate them, we replace them on the stack.</p>
<p>In the other helper methods of the compiler where we previously accessed the <code>instructions</code>, <code>lastInstruction</code> and <code>previousInstruction</code> fields directly, we also have to go through the stack now:</p>
<div class="sourceCode" id="cb286"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb286-1"><a href="#cb286-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb286-2"><a href="#cb286-2"></a></span>
<span id="cb286-3"><a href="#cb286-3"></a><span class="kw">func</span> (c *Compiler) setLastInstruction(op code.Opcode, pos <span class="dt">int</span>) {</span>
<span id="cb286-4"><a href="#cb286-4"></a>    previous := c.scopes[c.scopeIndex].lastInstruction</span>
<span id="cb286-5"><a href="#cb286-5"></a>    last := EmittedInstruction{Opcode: op, Position: pos}</span>
<span id="cb286-6"><a href="#cb286-6"></a></span>
<span id="cb286-7"><a href="#cb286-7"></a>    c.scopes[c.scopeIndex].previousInstruction = previous</span>
<span id="cb286-8"><a href="#cb286-8"></a>    c.scopes[c.scopeIndex].lastInstruction = last</span>
<span id="cb286-9"><a href="#cb286-9"></a>}</span>
<span id="cb286-10"><a href="#cb286-10"></a></span>
<span id="cb286-11"><a href="#cb286-11"></a><span class="kw">func</span> (c *Compiler) lastInstructionIsPop() <span class="dt">bool</span> {</span>
<span id="cb286-12"><a href="#cb286-12"></a>    <span class="kw">return</span> c.scopes[c.scopeIndex].lastInstruction.Opcode == code.OpPop</span>
<span id="cb286-13"><a href="#cb286-13"></a>}</span>
<span id="cb286-14"><a href="#cb286-14"></a></span>
<span id="cb286-15"><a href="#cb286-15"></a><span class="kw">func</span> (c *Compiler) removeLastPop() {</span>
<span id="cb286-16"><a href="#cb286-16"></a>    last := c.scopes[c.scopeIndex].lastInstruction</span>
<span id="cb286-17"><a href="#cb286-17"></a>    previous := c.scopes[c.scopeIndex].previousInstruction</span>
<span id="cb286-18"><a href="#cb286-18"></a></span>
<span id="cb286-19"><a href="#cb286-19"></a>    old := c.currentInstructions()</span>
<span id="cb286-20"><a href="#cb286-20"></a>    <span class="bu">new</span> := old[:last.Position]</span>
<span id="cb286-21"><a href="#cb286-21"></a></span>
<span id="cb286-22"><a href="#cb286-22"></a>    c.scopes[c.scopeIndex].instructions = <span class="bu">new</span></span>
<span id="cb286-23"><a href="#cb286-23"></a>    c.scopes[c.scopeIndex].lastInstruction = previous</span>
<span id="cb286-24"><a href="#cb286-24"></a>}</span>
<span id="cb286-25"><a href="#cb286-25"></a></span>
<span id="cb286-26"><a href="#cb286-26"></a><span class="kw">func</span> (c *Compiler) replaceInstruction(pos <span class="dt">int</span>, newInstruction []<span class="dt">byte</span>) {</span>
<span id="cb286-27"><a href="#cb286-27"></a>    ins := c.currentInstructions()</span>
<span id="cb286-28"><a href="#cb286-28"></a></span>
<span id="cb286-29"><a href="#cb286-29"></a>    <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="bu">len</span>(newInstruction); i++ {</span>
<span id="cb286-30"><a href="#cb286-30"></a>        ins[pos+i] = newInstruction[i]</span>
<span id="cb286-31"><a href="#cb286-31"></a>    }</span>
<span id="cb286-32"><a href="#cb286-32"></a>}</span>
<span id="cb286-33"><a href="#cb286-33"></a></span>
<span id="cb286-34"><a href="#cb286-34"></a><span class="kw">func</span> (c *Compiler) changeOperand(opPos <span class="dt">int</span>, operand <span class="dt">int</span>) {</span>
<span id="cb286-35"><a href="#cb286-35"></a>    op := code.Opcode(c.currentInstructions()[opPos])</span>
<span id="cb286-36"><a href="#cb286-36"></a>    newInstruction := code.Make(op, operand)</span>
<span id="cb286-37"><a href="#cb286-37"></a></span>
<span id="cb286-38"><a href="#cb286-38"></a>    c.replaceInstruction(opPos, newInstruction)</span>
<span id="cb286-39"><a href="#cb286-39"></a>}</span></code></pre></div>
<p>Then we need to make a few more delicate changes, in the heart of the <code>Compile</code> method, where we previously accessed <code>c.instructions</code> and now need to switch to <code>c.currentInstructions()</code> call:</p>
<div class="sourceCode" id="cb287"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb287-1"><a href="#cb287-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb287-2"><a href="#cb287-2"></a></span>
<span id="cb287-3"><a href="#cb287-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb287-4"><a href="#cb287-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb287-5"><a href="#cb287-5"></a>    <span class="co">// [...]</span></span>
<span id="cb287-6"><a href="#cb287-6"></a>    <span class="kw">case</span> *ast.IfExpression:</span>
<span id="cb287-7"><a href="#cb287-7"></a>        <span class="co">// [...]</span></span>
<span id="cb287-8"><a href="#cb287-8"></a></span>
<span id="cb287-9"><a href="#cb287-9"></a>        afterConsequencePos := <span class="bu">len</span>(c.currentInstructions())</span>
<span id="cb287-10"><a href="#cb287-10"></a>        c.changeOperand(jumpNotTruthyPos, afterConsequencePos)</span>
<span id="cb287-11"><a href="#cb287-11"></a></span>
<span id="cb287-12"><a href="#cb287-12"></a>        <span class="co">// [...]</span></span>
<span id="cb287-13"><a href="#cb287-13"></a></span>
<span id="cb287-14"><a href="#cb287-14"></a>        afterAlternativePos := <span class="bu">len</span>(c.currentInstructions())</span>
<span id="cb287-15"><a href="#cb287-15"></a>        c.changeOperand(jumpPos, afterAlternativePos)</span>
<span id="cb287-16"><a href="#cb287-16"></a></span>
<span id="cb287-17"><a href="#cb287-17"></a>    <span class="co">// [...]</span></span>
<span id="cb287-18"><a href="#cb287-18"></a>    }</span>
<span id="cb287-19"><a href="#cb287-19"></a></span>
<span id="cb287-20"><a href="#cb287-20"></a>    <span class="co">// [...]</span></span>
<span id="cb287-21"><a href="#cb287-21"></a>}</span></code></pre></div>
<p>We also need to return the current instructions when we want to return the bytecode the compiler produced:</p>
<div class="sourceCode" id="cb288"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb288-1"><a href="#cb288-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb288-2"><a href="#cb288-2"></a></span>
<span id="cb288-3"><a href="#cb288-3"></a><span class="kw">func</span> (c *Compiler) Bytecode() *Bytecode {</span>
<span id="cb288-4"><a href="#cb288-4"></a>    <span class="kw">return</span> &amp;Bytecode{</span>
<span id="cb288-5"><a href="#cb288-5"></a>        Instructions: c.currentInstructions(),</span>
<span id="cb288-6"><a href="#cb288-6"></a>        Constants:    c.constants,</span>
<span id="cb288-7"><a href="#cb288-7"></a>    }</span>
<span id="cb288-8"><a href="#cb288-8"></a>}</span></code></pre></div>
<p>Finally, we’re ready to add the new <code>enterScope</code> and <code>leaveScope</code> methods:</p>
<div class="sourceCode" id="cb289"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb289-1"><a href="#cb289-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb289-2"><a href="#cb289-2"></a></span>
<span id="cb289-3"><a href="#cb289-3"></a><span class="kw">func</span> (c *Compiler) enterScope() {</span>
<span id="cb289-4"><a href="#cb289-4"></a>    scope := CompilationScope{</span>
<span id="cb289-5"><a href="#cb289-5"></a>        instructions:        code.Instructions{},</span>
<span id="cb289-6"><a href="#cb289-6"></a>        lastInstruction:     EmittedInstruction{},</span>
<span id="cb289-7"><a href="#cb289-7"></a>        previousInstruction: EmittedInstruction{},</span>
<span id="cb289-8"><a href="#cb289-8"></a>    }</span>
<span id="cb289-9"><a href="#cb289-9"></a>    c.scopes = <span class="bu">append</span>(c.scopes, scope)</span>
<span id="cb289-10"><a href="#cb289-10"></a>    c.scopeIndex++</span>
<span id="cb289-11"><a href="#cb289-11"></a>}</span>
<span id="cb289-12"><a href="#cb289-12"></a></span>
<span id="cb289-13"><a href="#cb289-13"></a><span class="kw">func</span> (c *Compiler) leaveScope() code.Instructions {</span>
<span id="cb289-14"><a href="#cb289-14"></a>    instructions := c.currentInstructions()</span>
<span id="cb289-15"><a href="#cb289-15"></a></span>
<span id="cb289-16"><a href="#cb289-16"></a>    c.scopes = c.scopes[:<span class="bu">len</span>(c.scopes)-<span class="dv">1</span>]</span>
<span id="cb289-17"><a href="#cb289-17"></a>    c.scopeIndex--</span>
<span id="cb289-18"><a href="#cb289-18"></a></span>
<span id="cb289-19"><a href="#cb289-19"></a>    <span class="kw">return</span> instructions</span>
<span id="cb289-20"><a href="#cb289-20"></a>}</span></code></pre></div>
<p>I’ll spare you an in-depth explanation. We’ve seen this before with all of the other stacks we’ve implemented, except that now it’s whole <code>code.Instructions</code> that we push and pop.</p>
<p>The tests are happy:</p>
<div class="sourceCode" id="cb290"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb290-1"><a href="#cb290-1"></a>$ go test -run TestCompilerScopes ./compiler</span>
<span id="cb290-2"><a href="#cb290-2"></a>ok      monkey/compiler 0.008s</span></code></pre></div>
<p>At least the <code>TestCompilerScopes</code> function. What’s not happy is the test that brought us here:</p>
<div class="sourceCode" id="cb291"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb291-1"><a href="#cb291-1"></a>$ go test ./compiler</span>
<span id="cb291-2"><a href="#cb291-2"></a>--- FAIL: TestFunctions (0.00s)</span>
<span id="cb291-3"><a href="#cb291-3"></a> compiler_test.go:396: testInstructions failed: wrong instructions length.</span>
<span id="cb291-4"><a href="#cb291-4"></a>  want=&quot;0000 OpConstant 2\n0003 OpPop\n&quot;</span>
<span id="cb291-5"><a href="#cb291-5"></a>  got =&quot;0000 OpPop\n&quot;</span>
<span id="cb291-6"><a href="#cb291-6"></a>FAIL</span>
<span id="cb291-7"><a href="#cb291-7"></a>FAIL    monkey/compiler 0.008s</span></code></pre></div>
<p>Now, though, we’re in a position to fix it.</p>
<h4 id="compiling-with-scopes">Compiling With Scopes</h4>
<p>Our compiler knows about scopes and we know how to use them – we can now compile <code>*ast.FunctionLiteral</code>s:</p>
<div class="sourceCode" id="cb292"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb292-1"><a href="#cb292-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb292-2"><a href="#cb292-2"></a></span>
<span id="cb292-3"><a href="#cb292-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb292-4"><a href="#cb292-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb292-5"><a href="#cb292-5"></a>    <span class="co">// [...]</span></span>
<span id="cb292-6"><a href="#cb292-6"></a></span>
<span id="cb292-7"><a href="#cb292-7"></a>    <span class="kw">case</span> *ast.FunctionLiteral:</span>
<span id="cb292-8"><a href="#cb292-8"></a>        c.enterScope()</span>
<span id="cb292-9"><a href="#cb292-9"></a></span>
<span id="cb292-10"><a href="#cb292-10"></a>        err := c.Compile(node.Body)</span>
<span id="cb292-11"><a href="#cb292-11"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb292-12"><a href="#cb292-12"></a>            <span class="kw">return</span> err</span>
<span id="cb292-13"><a href="#cb292-13"></a>        }</span>
<span id="cb292-14"><a href="#cb292-14"></a></span>
<span id="cb292-15"><a href="#cb292-15"></a>        instructions := c.leaveScope()</span>
<span id="cb292-16"><a href="#cb292-16"></a></span>
<span id="cb292-17"><a href="#cb292-17"></a>        compiledFn := &amp;object.CompiledFunction{Instructions: instructions}</span>
<span id="cb292-18"><a href="#cb292-18"></a>        c.emit(code.OpConstant, c.addConstant(compiledFn))</span>
<span id="cb292-19"><a href="#cb292-19"></a></span>
<span id="cb292-20"><a href="#cb292-20"></a>    <span class="co">// [...]</span></span>
<span id="cb292-21"><a href="#cb292-21"></a>    }</span>
<span id="cb292-22"><a href="#cb292-22"></a></span>
<span id="cb292-23"><a href="#cb292-23"></a>    <span class="co">// [...]</span></span>
<span id="cb292-24"><a href="#cb292-24"></a>}</span></code></pre></div>
<p>This snippet of code revolves around one idea: change where emitted instructions are stored when compiling a function.</p>
<p>So, when we come across an <code>*ast.FunctionLiteral</code> the first thing we do is enter a new scope by calling <code>c.enterScope</code>. Then we compile the <code>node.Body</code>, the AST nodes making up the function’s body. After that, we take the just-filled slice of <code>instructions</code> off the stack of <code>CompilationScope</code>s by calling <code>c.leaveScope</code>, create a new <code>*object.CompiledFunction</code> that holds these instructions, and add that function to the constant pool.</p>
<p>Done, function compiled:</p>
<div class="sourceCode" id="cb293"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb293-1"><a href="#cb293-1"></a>$ go test ./compiler</span>
<span id="cb293-2"><a href="#cb293-2"></a>--- FAIL: TestFunctions (0.00s)</span>
<span id="cb293-3"><a href="#cb293-3"></a> compiler_test.go:654: testInstructions failed: wrong instruction at 2.</span>
<span id="cb293-4"><a href="#cb293-4"></a>  want=&quot;0000 OpConstant 2\n0003 OpPop\n&quot;</span>
<span id="cb293-5"><a href="#cb293-5"></a>  got =&quot;0000 OpConstant 0\n0003 OpPop\n&quot;</span>
<span id="cb293-6"><a href="#cb293-6"></a>FAIL</span>
<span id="cb293-7"><a href="#cb293-7"></a>FAIL    monkey/compiler 0.008s</span></code></pre></div>
<p>Oh, well. It turns out that we <em>do</em> know how to compile function literals, but we don’t know how to compile <code>*ast.ReturnStatement</code>s. And since the body of the function in the test is nothing more than a single return statement, we do not compile anything of that function. We only create an <code>*object.CompiledFunction</code> constant with no instructions.</p>
<p>Our testing infrastructure is just not advanced enough to point us to the origin of the problem with a precise error message. You can trust me, though, I’ve done the digging for both of us.</p>
<p>So, compiling <code>*ast.ReturnStatement</code>s it is. Since we made a plan, we already know which opcode should come out the other end: <code>OpReturnValue</code>.</p>
<div class="sourceCode" id="cb294"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb294-1"><a href="#cb294-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb294-2"><a href="#cb294-2"></a></span>
<span id="cb294-3"><a href="#cb294-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb294-4"><a href="#cb294-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb294-5"><a href="#cb294-5"></a>    <span class="co">// [...]</span></span>
<span id="cb294-6"><a href="#cb294-6"></a></span>
<span id="cb294-7"><a href="#cb294-7"></a>    <span class="kw">case</span> *ast.ReturnStatement:</span>
<span id="cb294-8"><a href="#cb294-8"></a>        err := c.Compile(node.ReturnValue)</span>
<span id="cb294-9"><a href="#cb294-9"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb294-10"><a href="#cb294-10"></a>            <span class="kw">return</span> err</span>
<span id="cb294-11"><a href="#cb294-11"></a>        }</span>
<span id="cb294-12"><a href="#cb294-12"></a></span>
<span id="cb294-13"><a href="#cb294-13"></a>        c.emit(code.OpReturnValue)</span>
<span id="cb294-14"><a href="#cb294-14"></a></span>
<span id="cb294-15"><a href="#cb294-15"></a>    <span class="co">// [...]</span></span>
<span id="cb294-16"><a href="#cb294-16"></a>    }</span>
<span id="cb294-17"><a href="#cb294-17"></a></span>
<span id="cb294-18"><a href="#cb294-18"></a>    <span class="co">// [...]</span></span>
<span id="cb294-19"><a href="#cb294-19"></a>}</span></code></pre></div>
<p>First we compile the return value itself, an expression, to instructions that leave the value on the stack and then we emit an <code>OpReturnValue</code> instruction.</p>
<p>And now, let’s try that again…</p>
<div class="sourceCode" id="cb295"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb295-1"><a href="#cb295-1"></a>$ go test ./compiler</span>
<span id="cb295-2"><a href="#cb295-2"></a>ok      monkey/compiler 0.009s</span></code></pre></div>
<p>Alright, here we go! We’ve successfully turned the body of a function into a series of instructions!</p>
<p>But before we start the official celebration, there’s one last thing we need to take care of. It’s not a big deal, really, since we just implemented a variation of it, but we need to make sure that the implicit returning of a value results in the same bytecode as the explicit return statement.</p>
<p>Writing the test case for this is as easy as duplicating the previous one and removing the <code>return</code> from the Monkey code:</p>
<div class="sourceCode" id="cb296"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb296-1"><a href="#cb296-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb296-2"><a href="#cb296-2"></a></span>
<span id="cb296-3"><a href="#cb296-3"></a><span class="kw">func</span> TestFunctions(t *testing.T) {</span>
<span id="cb296-4"><a href="#cb296-4"></a>    tests := []compilerTestCase{</span>
<span id="cb296-5"><a href="#cb296-5"></a>        <span class="co">// [...]</span></span>
<span id="cb296-6"><a href="#cb296-6"></a>        {</span>
<span id="cb296-7"><a href="#cb296-7"></a>            input: <span class="st">`fn() { 5 + 10 }`</span>,</span>
<span id="cb296-8"><a href="#cb296-8"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb296-9"><a href="#cb296-9"></a>                <span class="dv">5</span>,</span>
<span id="cb296-10"><a href="#cb296-10"></a>                <span class="dv">10</span>,</span>
<span id="cb296-11"><a href="#cb296-11"></a>                []code.Instructions{</span>
<span id="cb296-12"><a href="#cb296-12"></a>                    code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb296-13"><a href="#cb296-13"></a>                    code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb296-14"><a href="#cb296-14"></a>                    code.Make(code.OpAdd),</span>
<span id="cb296-15"><a href="#cb296-15"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb296-16"><a href="#cb296-16"></a>                },</span>
<span id="cb296-17"><a href="#cb296-17"></a>            },</span>
<span id="cb296-18"><a href="#cb296-18"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb296-19"><a href="#cb296-19"></a>                code.Make(code.OpConstant, <span class="dv">2</span>),</span>
<span id="cb296-20"><a href="#cb296-20"></a>                code.Make(code.OpPop),</span>
<span id="cb296-21"><a href="#cb296-21"></a>            },</span>
<span id="cb296-22"><a href="#cb296-22"></a>        },</span>
<span id="cb296-23"><a href="#cb296-23"></a>    }</span>
<span id="cb296-24"><a href="#cb296-24"></a></span>
<span id="cb296-25"><a href="#cb296-25"></a>    runCompilerTests(t, tests)</span>
<span id="cb296-26"><a href="#cb296-26"></a>}</span></code></pre></div>
<p>We already know that solving this involves <code>OpPop</code> instructions, because in this test case we expect the compiler to get rid of the <code>OpPop</code> that it would emit after the last expression statement in a function’s body. We do not want anything to take the implicit return value off the stack. In other cases, though, we still want <code>OpPop</code> instructions around, and before we end up with no <code>OpPop</code> at all, let’s make sure they stay where they are in the cases where we need them and add another test case:</p>
<div class="sourceCode" id="cb297"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb297-1"><a href="#cb297-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb297-2"><a href="#cb297-2"></a></span>
<span id="cb297-3"><a href="#cb297-3"></a><span class="kw">func</span> TestFunctions(t *testing.T) {</span>
<span id="cb297-4"><a href="#cb297-4"></a>    tests := []compilerTestCase{</span>
<span id="cb297-5"><a href="#cb297-5"></a>        <span class="co">// [...]</span></span>
<span id="cb297-6"><a href="#cb297-6"></a>        {</span>
<span id="cb297-7"><a href="#cb297-7"></a>            input: <span class="st">`fn() { 1; 2 }`</span>,</span>
<span id="cb297-8"><a href="#cb297-8"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb297-9"><a href="#cb297-9"></a>                <span class="dv">1</span>,</span>
<span id="cb297-10"><a href="#cb297-10"></a>                <span class="dv">2</span>,</span>
<span id="cb297-11"><a href="#cb297-11"></a>                []code.Instructions{</span>
<span id="cb297-12"><a href="#cb297-12"></a>                    code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb297-13"><a href="#cb297-13"></a>                    code.Make(code.OpPop),</span>
<span id="cb297-14"><a href="#cb297-14"></a>                    code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb297-15"><a href="#cb297-15"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb297-16"><a href="#cb297-16"></a>                },</span>
<span id="cb297-17"><a href="#cb297-17"></a>            },</span>
<span id="cb297-18"><a href="#cb297-18"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb297-19"><a href="#cb297-19"></a>                code.Make(code.OpConstant, <span class="dv">2</span>),</span>
<span id="cb297-20"><a href="#cb297-20"></a>                code.Make(code.OpPop),</span>
<span id="cb297-21"><a href="#cb297-21"></a>            },</span>
<span id="cb297-22"><a href="#cb297-22"></a>        },</span>
<span id="cb297-23"><a href="#cb297-23"></a>    }</span>
<span id="cb297-24"><a href="#cb297-24"></a></span>
<span id="cb297-25"><a href="#cb297-25"></a>    runCompilerTests(t, tests)</span>
<span id="cb297-26"><a href="#cb297-26"></a>}</span></code></pre></div>
<p>This test case now succinctly explains what we want to do with <code>OpPop</code> in the future. The first expression statement, the literal <code>1</code>, should be followed by an <code>OpPop</code> instruction. Same as it ever was. But the second expression statement, the <code>2</code>, is the implicit return value and the <code>OpPop</code> instruction must be replaced by an <code>OpReturnValue</code> instruction.</p>
<p>Now we have two failing test cases to fix and the test output is actually pretty helpful:</p>
<div class="sourceCode" id="cb298"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb298-1"><a href="#cb298-1"></a>$ go test ./compiler</span>
<span id="cb298-2"><a href="#cb298-2"></a>--- FAIL: TestFunctions (0.00s)</span>
<span id="cb298-3"><a href="#cb298-3"></a> compiler_test.go:693: testConstants failed: constant 2 -\</span>
<span id="cb298-4"><a href="#cb298-4"></a>   testInstructions failed: wrong instruction at 7.</span>
<span id="cb298-5"><a href="#cb298-5"></a>  want=&quot;0000 OpConstant 0\n0003 OpConstant 1\n0006 OpAdd\n0007 OpReturnValue\n&quot;</span>
<span id="cb298-6"><a href="#cb298-6"></a>  got =&quot;0000 OpConstant 0\n0003 OpConstant 1\n0006 OpAdd\n0007 OpPop\n&quot;</span>
<span id="cb298-7"><a href="#cb298-7"></a>FAIL</span>
<span id="cb298-8"><a href="#cb298-8"></a>FAIL    monkey/compiler 0.009s</span></code></pre></div>
<p>As expected, the last expression statement in a function is <em>not</em> turned into an implicit return value, but is still followed by an <code>OpPop</code> instruction.</p>
<p>The right time to fix this is <em>after</em> the compilation of a function’s body and <em>before</em> leaving the scope. At that point, we still have access to the just-emitted instructions. We can check whether the last instruction is an <code>OpPop</code> instruction and, if necessary, turn it into an <code>OpReturnValue</code>.</p>
<p>To make the necessary changes easier, we refactor and change our existing <code>lastInstructionIsPop</code> method into a more generic <code>lastInstructionIs</code> with an added defensive check:</p>
<div class="sourceCode" id="cb299"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb299-1"><a href="#cb299-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb299-2"><a href="#cb299-2"></a></span>
<span id="cb299-3"><a href="#cb299-3"></a><span class="kw">func</span> (c *Compiler) lastInstructionIs(op code.Opcode) <span class="dt">bool</span> {</span>
<span id="cb299-4"><a href="#cb299-4"></a>    <span class="kw">if</span> <span class="bu">len</span>(c.currentInstructions()) == <span class="dv">0</span> {</span>
<span id="cb299-5"><a href="#cb299-5"></a>        <span class="kw">return</span> <span class="ot">false</span></span>
<span id="cb299-6"><a href="#cb299-6"></a>    }</span>
<span id="cb299-7"><a href="#cb299-7"></a></span>
<span id="cb299-8"><a href="#cb299-8"></a>    <span class="kw">return</span> c.scopes[c.scopeIndex].lastInstruction.Opcode == op</span>
<span id="cb299-9"><a href="#cb299-9"></a>}</span></code></pre></div>
<p>That requires changing the previous locations in which <code>lastInstructionIsPop</code> was called:</p>
<div class="sourceCode" id="cb300"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb300-1"><a href="#cb300-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb300-2"><a href="#cb300-2"></a></span>
<span id="cb300-3"><a href="#cb300-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb300-4"><a href="#cb300-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb300-5"><a href="#cb300-5"></a>    <span class="co">// [...]</span></span>
<span id="cb300-6"><a href="#cb300-6"></a>    <span class="kw">case</span> *ast.IfExpression:</span>
<span id="cb300-7"><a href="#cb300-7"></a>        <span class="co">// [...]</span></span>
<span id="cb300-8"><a href="#cb300-8"></a></span>
<span id="cb300-9"><a href="#cb300-9"></a>        <span class="kw">if</span> c.lastInstructionIs(code.OpPop) {</span>
<span id="cb300-10"><a href="#cb300-10"></a>            c.removeLastPop()</span>
<span id="cb300-11"><a href="#cb300-11"></a>        }</span>
<span id="cb300-12"><a href="#cb300-12"></a></span>
<span id="cb300-13"><a href="#cb300-13"></a>        <span class="co">// [...]</span></span>
<span id="cb300-14"><a href="#cb300-14"></a></span>
<span id="cb300-15"><a href="#cb300-15"></a>        <span class="kw">if</span> node.Alternative == <span class="ot">nil</span> {</span>
<span id="cb300-16"><a href="#cb300-16"></a>            <span class="co">// [...]</span></span>
<span id="cb300-17"><a href="#cb300-17"></a>        } <span class="kw">else</span> {</span>
<span id="cb300-18"><a href="#cb300-18"></a>            <span class="co">// [...]</span></span>
<span id="cb300-19"><a href="#cb300-19"></a>            <span class="kw">if</span> c.lastInstructionIs(code.OpPop) {</span>
<span id="cb300-20"><a href="#cb300-20"></a>                c.removeLastPop()</span>
<span id="cb300-21"><a href="#cb300-21"></a>            }</span>
<span id="cb300-22"><a href="#cb300-22"></a>            <span class="co">// [...]</span></span>
<span id="cb300-23"><a href="#cb300-23"></a>        }</span>
<span id="cb300-24"><a href="#cb300-24"></a></span>
<span id="cb300-25"><a href="#cb300-25"></a>    <span class="co">// [...]</span></span>
<span id="cb300-26"><a href="#cb300-26"></a>    }</span>
<span id="cb300-27"><a href="#cb300-27"></a></span>
<span id="cb300-28"><a href="#cb300-28"></a>    <span class="co">// [...]</span></span>
<span id="cb300-29"><a href="#cb300-29"></a>}</span></code></pre></div>
<p>We can now change the <code>case *ast.FunctionLiteral</code> branch in the <code>Compile</code> method to use <code>c.lastInstructionIs</code>:</p>
<div class="sourceCode" id="cb301"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb301-1"><a href="#cb301-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb301-2"><a href="#cb301-2"></a></span>
<span id="cb301-3"><a href="#cb301-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb301-4"><a href="#cb301-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb301-5"><a href="#cb301-5"></a>    <span class="co">// [...]</span></span>
<span id="cb301-6"><a href="#cb301-6"></a></span>
<span id="cb301-7"><a href="#cb301-7"></a>    <span class="kw">case</span> *ast.FunctionLiteral:</span>
<span id="cb301-8"><a href="#cb301-8"></a>        c.enterScope()</span>
<span id="cb301-9"><a href="#cb301-9"></a></span>
<span id="cb301-10"><a href="#cb301-10"></a>        err := c.Compile(node.Body)</span>
<span id="cb301-11"><a href="#cb301-11"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb301-12"><a href="#cb301-12"></a>            <span class="kw">return</span> err</span>
<span id="cb301-13"><a href="#cb301-13"></a>        }</span>
<span id="cb301-14"><a href="#cb301-14"></a></span>
<span id="cb301-15"><a href="#cb301-15"></a>        <span class="kw">if</span> c.lastInstructionIs(code.OpPop) {</span>
<span id="cb301-16"><a href="#cb301-16"></a>            c.replaceLastPopWithReturn()</span>
<span id="cb301-17"><a href="#cb301-17"></a>        }</span>
<span id="cb301-18"><a href="#cb301-18"></a></span>
<span id="cb301-19"><a href="#cb301-19"></a>        instructions := c.leaveScope()</span>
<span id="cb301-20"><a href="#cb301-20"></a></span>
<span id="cb301-21"><a href="#cb301-21"></a>        compiledFn := &amp;object.CompiledFunction{Instructions: instructions}</span>
<span id="cb301-22"><a href="#cb301-22"></a>        c.emit(code.OpConstant, c.addConstant(compiledFn))</span>
<span id="cb301-23"><a href="#cb301-23"></a></span>
<span id="cb301-24"><a href="#cb301-24"></a>    <span class="co">// [...]</span></span>
<span id="cb301-25"><a href="#cb301-25"></a>    }</span>
<span id="cb301-26"><a href="#cb301-26"></a></span>
<span id="cb301-27"><a href="#cb301-27"></a>    <span class="co">// [...]</span></span>
<span id="cb301-28"><a href="#cb301-28"></a>}</span>
<span id="cb301-29"><a href="#cb301-29"></a></span>
<span id="cb301-30"><a href="#cb301-30"></a><span class="kw">func</span> (c *Compiler) replaceLastPopWithReturn() {</span>
<span id="cb301-31"><a href="#cb301-31"></a>    lastPos := c.scopes[c.scopeIndex].lastInstruction.Position</span>
<span id="cb301-32"><a href="#cb301-32"></a>    c.replaceInstruction(lastPos, code.Make(code.OpReturnValue))</span>
<span id="cb301-33"><a href="#cb301-33"></a></span>
<span id="cb301-34"><a href="#cb301-34"></a>    c.scopes[c.scopeIndex].lastInstruction.Opcode = code.OpReturnValue</span>
<span id="cb301-35"><a href="#cb301-35"></a>}</span></code></pre></div>
<p>Right after compiling a function’s body, we check whether the last emitted instruction was an <code>OpPop</code> and, if it was, we replace it with an <code>OpReturnValue</code>. A straightforward change and the two new test cases now pass:</p>
<div class="sourceCode" id="cb302"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb302-1"><a href="#cb302-1"></a>$ go test ./compiler</span>
<span id="cb302-2"><a href="#cb302-2"></a>ok      monkey/compiler 0.008s</span></code></pre></div>
<p>But why did we refactor <code>lastInstructionIsPop</code> to <code>lastInstructionIs</code> and add an extra safety check if we only check for <code>OpPop</code> again? Well, because we’re not done yet. There is still this nagging edge case: a function without a body. I promise, though, we’re close to the finish line.</p>
<p>What we want from our compiler is to turn an empty function body into a single <code>OpReturn</code> instruction:</p>
<div class="sourceCode" id="cb303"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb303-1"><a href="#cb303-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb303-2"><a href="#cb303-2"></a></span>
<span id="cb303-3"><a href="#cb303-3"></a><span class="kw">func</span> TestFunctionsWithoutReturnValue(t *testing.T) {</span>
<span id="cb303-4"><a href="#cb303-4"></a>    tests := []compilerTestCase{</span>
<span id="cb303-5"><a href="#cb303-5"></a>        {</span>
<span id="cb303-6"><a href="#cb303-6"></a>            input: <span class="st">`fn() { }`</span>,</span>
<span id="cb303-7"><a href="#cb303-7"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb303-8"><a href="#cb303-8"></a>                []code.Instructions{</span>
<span id="cb303-9"><a href="#cb303-9"></a>                    code.Make(code.OpReturn),</span>
<span id="cb303-10"><a href="#cb303-10"></a>                },</span>
<span id="cb303-11"><a href="#cb303-11"></a>            },</span>
<span id="cb303-12"><a href="#cb303-12"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb303-13"><a href="#cb303-13"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb303-14"><a href="#cb303-14"></a>                code.Make(code.OpPop),</span>
<span id="cb303-15"><a href="#cb303-15"></a>            },</span>
<span id="cb303-16"><a href="#cb303-16"></a>        },</span>
<span id="cb303-17"><a href="#cb303-17"></a>    }</span>
<span id="cb303-18"><a href="#cb303-18"></a></span>
<span id="cb303-19"><a href="#cb303-19"></a>    runCompilerTests(t, tests)</span>
<span id="cb303-20"><a href="#cb303-20"></a>}</span></code></pre></div>
<p>This fails, shall I say, beautifully:</p>
<div class="sourceCode" id="cb304"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb304-1"><a href="#cb304-1"></a>$ go test ./compiler</span>
<span id="cb304-2"><a href="#cb304-2"></a>--- FAIL: TestFunctionsWithoutReturnValue (0.00s)</span>
<span id="cb304-3"><a href="#cb304-3"></a> compiler_test.go:772: testConstants failed: constant 0 -\</span>
<span id="cb304-4"><a href="#cb304-4"></a>  testInstructions failed: wrong instructions length.</span>
<span id="cb304-5"><a href="#cb304-5"></a>  want=&quot;0000 OpReturn\n&quot;</span>
<span id="cb304-6"><a href="#cb304-6"></a>  got =&quot;&quot;</span>
<span id="cb304-7"><a href="#cb304-7"></a>FAIL</span>
<span id="cb304-8"><a href="#cb304-8"></a>FAIL    monkey/compiler 0.009s</span></code></pre></div>
<p>We want an <code>OpReturn</code> instruction, but get nothing. Can’t be more specific than that, right? The fix for this is also quite beautiful, in its own succinct way:</p>
<div class="sourceCode" id="cb305"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb305-1"><a href="#cb305-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb305-2"><a href="#cb305-2"></a></span>
<span id="cb305-3"><a href="#cb305-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb305-4"><a href="#cb305-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb305-5"><a href="#cb305-5"></a>    <span class="co">// [...]</span></span>
<span id="cb305-6"><a href="#cb305-6"></a></span>
<span id="cb305-7"><a href="#cb305-7"></a>    <span class="kw">case</span> *ast.FunctionLiteral:</span>
<span id="cb305-8"><a href="#cb305-8"></a>        <span class="co">// [...]</span></span>
<span id="cb305-9"><a href="#cb305-9"></a></span>
<span id="cb305-10"><a href="#cb305-10"></a>        <span class="kw">if</span> c.lastInstructionIs(code.OpPop) {</span>
<span id="cb305-11"><a href="#cb305-11"></a>            c.replaceLastPopWithReturn()</span>
<span id="cb305-12"><a href="#cb305-12"></a>        }</span>
<span id="cb305-13"><a href="#cb305-13"></a>        <span class="kw">if</span> !c.lastInstructionIs(code.OpReturnValue) {</span>
<span id="cb305-14"><a href="#cb305-14"></a>            c.emit(code.OpReturn)</span>
<span id="cb305-15"><a href="#cb305-15"></a>        }</span>
<span id="cb305-16"><a href="#cb305-16"></a>        <span class="co">// [...]</span></span>
<span id="cb305-17"><a href="#cb305-17"></a></span>
<span id="cb305-18"><a href="#cb305-18"></a>    <span class="co">// [...]</span></span>
<span id="cb305-19"><a href="#cb305-19"></a>    }</span>
<span id="cb305-20"><a href="#cb305-20"></a></span>
<span id="cb305-21"><a href="#cb305-21"></a>    <span class="co">// [...]</span></span>
<span id="cb305-22"><a href="#cb305-22"></a>}</span></code></pre></div>
<p>First the check whether we need to replace an <code>OpPop</code> instruction with an <code>OpReturnValue</code>. We already had that in place. It should turn every last statement in a function’s body into an <code>OpReturnValue</code>. Either because it already was an explicit <code>*ast.ReturnStatement</code> or because we now changed it.</p>
<p>But if that wasn’t the case – and this is new – it means we either didn’t have any statements in the function’s body or only statements that we couldn’t turn into an <code>OpReturnValue</code> instruction. Currently, we’re focused on former, but we’ll talk about the latter soon enough. For now, we emit an <code>OpReturn</code> in both cases.</p>
<p>And now, with this edge case also fixed, we’re finally ready to celebrate:</p>
<div class="sourceCode" id="cb306"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb306-1"><a href="#cb306-1"></a>$ go test ./compiler</span>
<span id="cb306-2"><a href="#cb306-2"></a>ok      monkey/compiler 0.009s</span></code></pre></div>
<p>Cool! We can now correctly compile function literals! That really is a reason to celebrate.</p>
<p>We turn function literals into <code>*object.CompiledFunction</code>, take care of implicit and explicit returns in the function’s body and also emit an <code>OpConstant</code> instruction to load the function on to the stack in the VM. Cheers to that!</p>
<p>We’ve reached the halfway point on the compilation side. The rest of the way is the compilation of function <em>calls</em>.</p>
<h3 id="compiling-function-calls">Compiling Function Calls</h3>
<p>Before we open <code>compiler_test.go</code> and start hammering out test cases, let’s take a step back and think this through. We want to implement function calls. In other words, we need to emit instructions that represent Monkey’s bytecode calling convention, since that’s how you call a function in Monkey bytecode.</p>
<p>At the beginning of this chapter we decided that the start of the calling convention is putting the function you want to call on to the stack. We already know how to do that. Either by using an <code>OpConstant</code> instruction in case it’s a function literal that’s being called, which looks like this:</p>
<div class="sourceCode" id="cb307"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb307-1"><a href="#cb307-1"></a>fn() { <span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span> }()</span></code></pre></div>
<p>Or with an <code>OpGetGlobal</code> instruction, if the function was previously bound to a name:</p>
<div class="sourceCode" id="cb308"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb308-1"><a href="#cb308-1"></a><span class="kw">let</span> onePlusTwo <span class="op">=</span> fn() { <span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span> }<span class="op">;</span></span>
<span id="cb308-2"><a href="#cb308-2"></a>onePlusTwo()<span class="op">;</span></span></code></pre></div>
<p>Both options result in the <code>*object.CompiledFunction</code> we want to call to sit on the stack. In order to now execute its instructions, we need to issue an <code>OpCall</code> instruction.</p>
<p>The VM then executes the function’s instructions and when it’s done, it pops the function itself off the stack and replaces it with the return value. That’s <em>if</em> there is a return value. If not, it only pops the function off the stack, which is fine too.</p>
<p>This whole part of the calling convention – what the VM does with the function once it’s done executing it – is implicit: we do not need to issue an <code>OpPop</code> instruction to get the function off the stack. It’s part of the convention and we’ll build it straight into the VM.</p>
<p>Before you start to scratch your head, please keep in mind that the convention will change once we introduce arguments to function calls. That’s why there’s no mention of them yet.</p>
<p>For now, though, we’re pretty sure about what we need to do. When the compiler comes across an <code>*ast.CallExpression</code> it should do this:</p>
<div class="sourceCode" id="cb309"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb309-1"><a href="#cb309-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb309-2"><a href="#cb309-2"></a></span>
<span id="cb309-3"><a href="#cb309-3"></a><span class="kw">func</span> TestFunctionCalls(t *testing.T) {</span>
<span id="cb309-4"><a href="#cb309-4"></a>    tests := []compilerTestCase{</span>
<span id="cb309-5"><a href="#cb309-5"></a>        {</span>
<span id="cb309-6"><a href="#cb309-6"></a>            input: <span class="st">`fn() { 24 }();`</span>,</span>
<span id="cb309-7"><a href="#cb309-7"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb309-8"><a href="#cb309-8"></a>                <span class="dv">24</span>,</span>
<span id="cb309-9"><a href="#cb309-9"></a>                []code.Instructions{</span>
<span id="cb309-10"><a href="#cb309-10"></a>                    code.Make(code.OpConstant, <span class="dv">0</span>), <span class="co">// The literal &quot;24&quot;</span></span>
<span id="cb309-11"><a href="#cb309-11"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb309-12"><a href="#cb309-12"></a>                },</span>
<span id="cb309-13"><a href="#cb309-13"></a>            },</span>
<span id="cb309-14"><a href="#cb309-14"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb309-15"><a href="#cb309-15"></a>                code.Make(code.OpConstant, <span class="dv">1</span>), <span class="co">// The compiled function</span></span>
<span id="cb309-16"><a href="#cb309-16"></a>                code.Make(code.OpCall),</span>
<span id="cb309-17"><a href="#cb309-17"></a>                code.Make(code.OpPop),</span>
<span id="cb309-18"><a href="#cb309-18"></a>            },</span>
<span id="cb309-19"><a href="#cb309-19"></a>        },</span>
<span id="cb309-20"><a href="#cb309-20"></a>        {</span>
<span id="cb309-21"><a href="#cb309-21"></a>            input: <span class="st">`</span></span>
<span id="cb309-22"><a href="#cb309-22"></a><span class="st">            let noArg = fn() { 24 };</span></span>
<span id="cb309-23"><a href="#cb309-23"></a><span class="st">            noArg();</span></span>
<span id="cb309-24"><a href="#cb309-24"></a><span class="st">            `</span>,</span>
<span id="cb309-25"><a href="#cb309-25"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb309-26"><a href="#cb309-26"></a>                <span class="dv">24</span>,</span>
<span id="cb309-27"><a href="#cb309-27"></a>                []code.Instructions{</span>
<span id="cb309-28"><a href="#cb309-28"></a>                    code.Make(code.OpConstant, <span class="dv">0</span>), <span class="co">// The literal &quot;24&quot;</span></span>
<span id="cb309-29"><a href="#cb309-29"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb309-30"><a href="#cb309-30"></a>                },</span>
<span id="cb309-31"><a href="#cb309-31"></a>            },</span>
<span id="cb309-32"><a href="#cb309-32"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb309-33"><a href="#cb309-33"></a>                code.Make(code.OpConstant, <span class="dv">1</span>), <span class="co">// The compiled function</span></span>
<span id="cb309-34"><a href="#cb309-34"></a>                code.Make(code.OpSetGlobal, <span class="dv">0</span>),</span>
<span id="cb309-35"><a href="#cb309-35"></a>                code.Make(code.OpGetGlobal, <span class="dv">0</span>),</span>
<span id="cb309-36"><a href="#cb309-36"></a>                code.Make(code.OpCall),</span>
<span id="cb309-37"><a href="#cb309-37"></a>                code.Make(code.OpPop),</span>
<span id="cb309-38"><a href="#cb309-38"></a>            },</span>
<span id="cb309-39"><a href="#cb309-39"></a>        },</span>
<span id="cb309-40"><a href="#cb309-40"></a>    }</span>
<span id="cb309-41"><a href="#cb309-41"></a></span>
<span id="cb309-42"><a href="#cb309-42"></a>    runCompilerTests(t, tests)</span>
<span id="cb309-43"><a href="#cb309-43"></a>}</span></code></pre></div>
<p>The function that’s being called in both test cases is intentionally simple, because the focus here is on the <code>OpCall</code> instruction and that it’s preceded by either an <code>OpGetGlobal</code> or an <code>OpConstant</code> instruction.</p>
<p>The test fails because our compiler knows nothing about <code>*ast.CallExpression</code> yet:</p>
<div class="sourceCode" id="cb310"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb310-1"><a href="#cb310-1"></a>$ go test ./compiler</span>
<span id="cb310-2"><a href="#cb310-2"></a>--- FAIL: TestFunctionCalls (0.00s)</span>
<span id="cb310-3"><a href="#cb310-3"></a> compiler_test.go:833: testInstructions failed: wrong instructions length.</span>
<span id="cb310-4"><a href="#cb310-4"></a>  want=&quot;0000 OpConstant 1\n0003 OpCall\n0004 OpPop\n&quot;</span>
<span id="cb310-5"><a href="#cb310-5"></a>  got =&quot;0000 OpPop\n&quot;</span>
<span id="cb310-6"><a href="#cb310-6"></a>FAIL</span>
<span id="cb310-7"><a href="#cb310-7"></a>FAIL    monkey/compiler 0.008s</span></code></pre></div>
<p>The great thing about implementing a fix for these tests is that from the compiler’s perspective it doesn’t matter whether the function to be called is bound to a name or a literal – we already know how to do both.</p>
<p>All we need to do is tell our compiler that when it comes across an <code>*ast.CallExpression</code> it should compile the function being called and then emit an <code>OpCall</code> instruction:</p>
<div class="sourceCode" id="cb311"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb311-1"><a href="#cb311-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb311-2"><a href="#cb311-2"></a></span>
<span id="cb311-3"><a href="#cb311-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb311-4"><a href="#cb311-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb311-5"><a href="#cb311-5"></a>    <span class="co">// [...]</span></span>
<span id="cb311-6"><a href="#cb311-6"></a></span>
<span id="cb311-7"><a href="#cb311-7"></a>    <span class="kw">case</span> *ast.CallExpression:</span>
<span id="cb311-8"><a href="#cb311-8"></a>        err := c.Compile(node.Function)</span>
<span id="cb311-9"><a href="#cb311-9"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb311-10"><a href="#cb311-10"></a>            <span class="kw">return</span> err</span>
<span id="cb311-11"><a href="#cb311-11"></a>        }</span>
<span id="cb311-12"><a href="#cb311-12"></a></span>
<span id="cb311-13"><a href="#cb311-13"></a>        c.emit(code.OpCall)</span>
<span id="cb311-14"><a href="#cb311-14"></a></span>
<span id="cb311-15"><a href="#cb311-15"></a>    <span class="co">// [...]</span></span>
<span id="cb311-16"><a href="#cb311-16"></a>    }</span>
<span id="cb311-17"><a href="#cb311-17"></a></span>
<span id="cb311-18"><a href="#cb311-18"></a>    <span class="co">// [...]</span></span>
<span id="cb311-19"><a href="#cb311-19"></a>}</span></code></pre></div>
<p>You see, when I said that we’re halfway there and that the second half is implementing function calls, I kinda lied a little bit. We were way past the halfway point. And now, we’ve crossed the finish line in the compiler:</p>
<div class="sourceCode" id="cb312"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb312-1"><a href="#cb312-1"></a>$ go test ./compiler</span>
<span id="cb312-2"><a href="#cb312-2"></a>ok      monkey/compiler 0.009s</span></code></pre></div>
<p>Yes, that means that we are correctly compiling function literals <em>and</em> function calls. We’re now <em>really</em> at the halfway point, because now we can head over to the VM and make sure that it knows how to handle functions, the two return instructions and <code>OpCall</code>.</p>
<h3 id="functions-in-the-vm">Functions in the VM</h3>
<p>Here’s the situation and task at hand, put into the vocabulary of our VM:</p>
<p>The bytecode’s <code>Constant</code> field can now contain <code>*object.CompiledFunction</code>s. When we come across an <code>OpCall</code> instruction we need to execute the instructions of the <code>*object.CompiledFunction</code> sitting on top of the stack. We do that until we encounter either an <code>OpReturnValue</code> or an <code>OpReturn</code> instruction. If it’s an <code>OpReturnValue</code>, we need to preserve the value on top of the stack, the return value. Then we have to remove the just executed <code>*object.CompiledFunction</code> from the stack and replace it with the saved return value, if we have one.</p>
<p>Implementing that is our goal for this section and we already know that popping off and pushing things on to the stack are not going to be the issue. We’re pros at that by now. The intriguing question is how do we execute the instructions of a function?</p>
<p>Right now, executing instructions means that the VM’s main loop iterates through the <code>vm.instructions</code> slice by incrementing its instruction pointer, <code>ip</code>, and using it as an index to fetch the next opcode from <code>vm.instructions</code>. It also reads the operands from the same slice. When it comes across a branching instruction, like <code>OpJump</code>, it changes the value of <code>ip</code> manually.</p>
<p>When we execute functions, we do not want to change this mechanism. The only thing we want to change is the <em>data</em> it uses: the instructions and the instruction pointer. If we can change those while the VM is running we can execute functions.</p>
<p>“Changing a slice and an integer? That’s not a challenge!” I know, but that’s not all of it. We also need to change them <em>back</em>. When the function returns we need to restore the old instructions and the old <code>ip</code>. And not just once. We also need to handle nested execution of functions. Consider this:</p>
<div class="sourceCode" id="cb313"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb313-1"><a href="#cb313-1"></a><span class="kw">let</span> one <span class="op">=</span> fn() { <span class="dv">5</span> }<span class="op">;</span></span>
<span id="cb313-2"><a href="#cb313-2"></a><span class="kw">let</span> two <span class="op">=</span> fn() { one() }<span class="op">;</span></span>
<span id="cb313-3"><a href="#cb313-3"></a><span class="kw">let</span> three <span class="op">=</span> fn() { two() }<span class="op">;</span></span>
<span id="cb313-4"><a href="#cb313-4"></a>three()<span class="op">;</span></span></code></pre></div>
<p>When <code>three</code> is called the instructions and the instruction pointer need to be changed. Then <code>two</code> is called, so they need to be changed again. <code>one</code> is called in <code>two</code>, so again, change the instructions and the instruction pointer. And once <code>one</code> is executed, we need to restore the instructions and the instruction pointer as we left them in <code>two</code>, before the call. Then we need to do the same for <code>three</code>, and after <code>three</code> returns we need to do the same for the main program.</p>
<p>If you read the last paragraph and a little bell with “stack” written on it began ringing in your head: you’re on the right track.</p>
<h4 id="adding-frames">Adding Frames</h4>
<p>This is what we know: function calls are nested and execution-relevant data – the instructions and the instruction pointer – is accessed in a last-in-first-out (LIFO) manner. We’re masters of the stack, so this plays into our hands, but juggling two separate pieces of data is never pleasant. The solution is to tie them together and call the resulting bundle a “frame”.</p>
<p>Frame is short for <em>call frame</em>, or <em>stack frame</em>, and is the name for a data structure that holds execution-relevant information. In compiler or interpreter literature this is also sometimes called an <em>activation record</em>.</p>
<p>On real machines – computers – a frame is a not something separate from but a designated part of <em>the stack</em>. It’s where the return address, the arguments to the current function and its local variables are stored. And since it’s on a stack, a frame is easy to pop off after the function has been executed. As we saw in the first chapter, using <em>the stack</em> to save call frames is what turns it from <em>a stack</em> into <em>the stack</em>, and more specifically: the <em>call stack</em>.</p>
<p>In virtual-machine land we don’t have to use the stack. We’re not constrained by standardized calling conventions and other much too real things, like <em>real memory addresses</em> and locations. We, using Go instead of assembly language and building a <em>virtual</em> machine, have more options available to us than the builders and programmers of real machines. We can store frames anywhere we like. Any execution-relevant piece of data, actually.</p>
<p>What’s kept on the stack and what’s not differs from VM to VM. Some keep everything on the stack, others only the return address, some only the local variables, some the local variables and the arguments of the function call. There is no best nor an only choice for these decisions. The implementation depends on the language being implemented, the requirements in regards to concurrency and performance, the host language and much more.</p>
<p>Since we’re here to learn, we choose what’s easiest to build, to understand, to extend and what also allows us to see how it <em>might</em> be changed or implemented differently.</p>
<p>We already use our VM’s stack in parts as a call stack: we save the function to be called and its return value on it. But we’re not going to keep our frames on there. Instead they’ll get their own stack.</p>
<p>But before we build that, here’s what makes up a <code>Frame</code> in our Monkey VM:</p>
<div class="sourceCode" id="cb314"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb314-1"><a href="#cb314-1"></a><span class="co">// vm/frame.go</span></span>
<span id="cb314-2"><a href="#cb314-2"></a></span>
<span id="cb314-3"><a href="#cb314-3"></a><span class="kw">package</span> vm</span>
<span id="cb314-4"><a href="#cb314-4"></a></span>
<span id="cb314-5"><a href="#cb314-5"></a><span class="kw">import</span> (</span>
<span id="cb314-6"><a href="#cb314-6"></a>    <span class="st">&quot;monkey/code&quot;</span></span>
<span id="cb314-7"><a href="#cb314-7"></a>    <span class="st">&quot;monkey/object&quot;</span></span>
<span id="cb314-8"><a href="#cb314-8"></a>)</span>
<span id="cb314-9"><a href="#cb314-9"></a></span>
<span id="cb314-10"><a href="#cb314-10"></a><span class="kw">type</span> Frame <span class="kw">struct</span> {</span>
<span id="cb314-11"><a href="#cb314-11"></a>    fn *object.CompiledFunction</span>
<span id="cb314-12"><a href="#cb314-12"></a>    ip <span class="dt">int</span></span>
<span id="cb314-13"><a href="#cb314-13"></a>}</span>
<span id="cb314-14"><a href="#cb314-14"></a></span>
<span id="cb314-15"><a href="#cb314-15"></a><span class="kw">func</span> NewFrame(fn *object.CompiledFunction) *Frame {</span>
<span id="cb314-16"><a href="#cb314-16"></a>    <span class="kw">return</span> &amp;Frame{fn: fn, ip: <span class="dv">-1</span>}</span>
<span id="cb314-17"><a href="#cb314-17"></a>}</span>
<span id="cb314-18"><a href="#cb314-18"></a></span>
<span id="cb314-19"><a href="#cb314-19"></a><span class="kw">func</span> (f *Frame) Instructions() code.Instructions {</span>
<span id="cb314-20"><a href="#cb314-20"></a>    <span class="kw">return</span> f.fn.Instructions</span>
<span id="cb314-21"><a href="#cb314-21"></a>}</span></code></pre></div>
<p>A <code>Frame</code> has two fields: <code>ip</code> and <code>fn</code>. <code>fn</code> points to the compiled function referenced by the frame, and <code>ip</code> is the instruction pointer in <em>this frame</em>, for <em>this function</em>. With these two fields we have all the data used by the main loop of the VM in one place. And the frame being currently executed is the one sitting on top of the call stack.</p>
<p>This is so tiny that I’m fairly confident in my choice to not write tests for the <code>NewFrame</code> function and <code>Instructions</code> method.</p>
<p>With <code>Frame</code> defined, we find ourselves at a crossroads. We can either go left and decide to bend over backwards by changing our VM to only use frames when calling and executing a function. Or, we can go right and choose a much more elegant and smoother approach, which modifies the VM so that it not only uses frames for functions, but also treats the main program, the <code>bytecode.Instructions</code>, as if it were a function.</p>
<p>Yes, of course we’re going right.</p>
<p>And even better news than the fact that we’re going to build something smooth and elegant is that we don’t even have to write tests, since this is another prime example for the term “implementation detail”: the visible behaviour of the VM should not change one bit when we now change it to use frames. It’s an internal change only. And to make sure that our VM keeps on working the way it currently does, we already have our test suite.</p>
<p>So, let’s build a stack for frames:</p>
<div class="sourceCode" id="cb315"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb315-1"><a href="#cb315-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb315-2"><a href="#cb315-2"></a></span>
<span id="cb315-3"><a href="#cb315-3"></a><span class="kw">type</span> VM <span class="kw">struct</span> {</span>
<span id="cb315-4"><a href="#cb315-4"></a>    <span class="co">// [...]</span></span>
<span id="cb315-5"><a href="#cb315-5"></a></span>
<span id="cb315-6"><a href="#cb315-6"></a>    frames      []*Frame</span>
<span id="cb315-7"><a href="#cb315-7"></a>    framesIndex <span class="dt">int</span></span>
<span id="cb315-8"><a href="#cb315-8"></a>}</span>
<span id="cb315-9"><a href="#cb315-9"></a></span>
<span id="cb315-10"><a href="#cb315-10"></a><span class="kw">func</span> (vm *VM) currentFrame() *Frame {</span>
<span id="cb315-11"><a href="#cb315-11"></a>    <span class="kw">return</span> vm.frames[vm.framesIndex<span class="dv">-1</span>]</span>
<span id="cb315-12"><a href="#cb315-12"></a>}</span>
<span id="cb315-13"><a href="#cb315-13"></a></span>
<span id="cb315-14"><a href="#cb315-14"></a><span class="kw">func</span> (vm *VM) pushFrame(f *Frame) {</span>
<span id="cb315-15"><a href="#cb315-15"></a>    vm.frames[vm.framesIndex] = f</span>
<span id="cb315-16"><a href="#cb315-16"></a>    vm.framesIndex++</span>
<span id="cb315-17"><a href="#cb315-17"></a>}</span>
<span id="cb315-18"><a href="#cb315-18"></a></span>
<span id="cb315-19"><a href="#cb315-19"></a><span class="kw">func</span> (vm *VM) popFrame() *Frame {</span>
<span id="cb315-20"><a href="#cb315-20"></a>    vm.framesIndex--</span>
<span id="cb315-21"><a href="#cb315-21"></a>    <span class="kw">return</span> vm.frames[vm.framesIndex]</span>
<span id="cb315-22"><a href="#cb315-22"></a>}</span></code></pre></div>
<p>Private and still unused changes – all the tests are still green, but now we have a stack for frames in place. Just like with our other stacks, we use a slice as the underlying data structure and an integer as index. Since it’s nice to have a little bit of performance here, we use a slightly different approach than the one used in the compiler for the <code>scopes</code> stack. Instead of <code>append</code>ing and slicing off, we pre-allocate the <code>frames</code> slice.</p>
<p>Now we just need to use it. The first task is to allocate said slice and push the outermost, the “main frame”, on to it:</p>
<div class="sourceCode" id="cb316"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb316-1"><a href="#cb316-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb316-2"><a href="#cb316-2"></a></span>
<span id="cb316-3"><a href="#cb316-3"></a><span class="kw">const</span> MaxFrames = <span class="dv">1024</span></span>
<span id="cb316-4"><a href="#cb316-4"></a></span>
<span id="cb316-5"><a href="#cb316-5"></a><span class="kw">func</span> New(bytecode *compiler.Bytecode) *VM {</span>
<span id="cb316-6"><a href="#cb316-6"></a>    mainFn := &amp;object.CompiledFunction{Instructions: bytecode.Instructions}</span>
<span id="cb316-7"><a href="#cb316-7"></a>    mainFrame := NewFrame(mainFn)</span>
<span id="cb316-8"><a href="#cb316-8"></a></span>
<span id="cb316-9"><a href="#cb316-9"></a>    frames := <span class="bu">make</span>([]*Frame, MaxFrames)</span>
<span id="cb316-10"><a href="#cb316-10"></a>    frames[<span class="dv">0</span>] = mainFrame</span>
<span id="cb316-11"><a href="#cb316-11"></a></span>
<span id="cb316-12"><a href="#cb316-12"></a>    <span class="kw">return</span> &amp;VM{</span>
<span id="cb316-13"><a href="#cb316-13"></a>        constants: bytecode.Constants,</span>
<span id="cb316-14"><a href="#cb316-14"></a></span>
<span id="cb316-15"><a href="#cb316-15"></a>        stack: <span class="bu">make</span>([]object.Object, StackSize),</span>
<span id="cb316-16"><a href="#cb316-16"></a>        sp:    <span class="dv">0</span>,</span>
<span id="cb316-17"><a href="#cb316-17"></a></span>
<span id="cb316-18"><a href="#cb316-18"></a>        globals: <span class="bu">make</span>([]object.Object, GlobalsSize),</span>
<span id="cb316-19"><a href="#cb316-19"></a></span>
<span id="cb316-20"><a href="#cb316-20"></a>        frames:      frames,</span>
<span id="cb316-21"><a href="#cb316-21"></a>        framesIndex: <span class="dv">1</span>,</span>
<span id="cb316-22"><a href="#cb316-22"></a>    }</span>
<span id="cb316-23"><a href="#cb316-23"></a>}</span></code></pre></div>
<p>New here is the prelude before we initialize a new <code>*VM</code>.</p>
<p>As the first thing, we create a <code>mainFn</code>. That’s the fictional main frame that contains the <code>bytecode.Instructions</code>, which make up the whole Monkey program. Then we allocate the <code>frames</code> stack with a maximum of <code>MaxFrames</code> slots. The value of <code>1024</code> is arbitrary but should be enough for us as long as we don’t nest function calls too much. The first frame on this new <code>frames</code> stack is the <code>mainFrame</code>. And then, following the fields we already know, we put the <code>frames</code> and the <code>framesIndex</code> of <code>1</code> into the newly created <code>*VM</code>.</p>
<p>At the same time, we’ve also <strong>removed</strong> the initialization of the <code>instructions</code> field in this <code>New</code> function and now need to remove it from the definition of <code>VM</code>, too:</p>
<div class="sourceCode" id="cb317"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb317-1"><a href="#cb317-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb317-2"><a href="#cb317-2"></a></span>
<span id="cb317-3"><a href="#cb317-3"></a><span class="kw">type</span> VM <span class="kw">struct</span> {</span>
<span id="cb317-4"><a href="#cb317-4"></a>    constants []object.Object</span>
<span id="cb317-5"><a href="#cb317-5"></a></span>
<span id="cb317-6"><a href="#cb317-6"></a>    stack []object.Object</span>
<span id="cb317-7"><a href="#cb317-7"></a>    sp    <span class="dt">int</span></span>
<span id="cb317-8"><a href="#cb317-8"></a></span>
<span id="cb317-9"><a href="#cb317-9"></a>    globals []object.Object</span>
<span id="cb317-10"><a href="#cb317-10"></a></span>
<span id="cb317-11"><a href="#cb317-11"></a>    frames      []*Frame</span>
<span id="cb317-12"><a href="#cb317-12"></a>    framesIndex <span class="dt">int</span></span>
<span id="cb317-13"><a href="#cb317-13"></a>}</span></code></pre></div>
<p>With the <code>instructions</code> slice gone, we now need to change the way we access the instructions and the instruction pointer inside the VM and make sure that we always access them by going through the current frame.</p>
<p>The first change we need to make is in the VM’s main loop. Since the <code>ip</code> can’t be initialized in the loop anymore, but only incremented there, we need to change from an old school <code>for</code> loop to Go’s version of a <code>while</code> loop, where we have just one condition and increment the <code>ip</code> manually in its body:</p>
<div class="sourceCode" id="cb318"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb318-1"><a href="#cb318-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb318-2"><a href="#cb318-2"></a></span>
<span id="cb318-3"><a href="#cb318-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb318-4"><a href="#cb318-4"></a>    <span class="kw">var</span> ip <span class="dt">int</span></span>
<span id="cb318-5"><a href="#cb318-5"></a>    <span class="kw">var</span> ins code.Instructions</span>
<span id="cb318-6"><a href="#cb318-6"></a>    <span class="kw">var</span> op code.Opcode</span>
<span id="cb318-7"><a href="#cb318-7"></a></span>
<span id="cb318-8"><a href="#cb318-8"></a>    <span class="kw">for</span> vm.currentFrame().ip &lt; <span class="bu">len</span>(vm.currentFrame().Instructions())-<span class="dv">1</span> {</span>
<span id="cb318-9"><a href="#cb318-9"></a>        vm.currentFrame().ip++</span>
<span id="cb318-10"><a href="#cb318-10"></a></span>
<span id="cb318-11"><a href="#cb318-11"></a>        ip = vm.currentFrame().ip</span>
<span id="cb318-12"><a href="#cb318-12"></a>        ins = vm.currentFrame().Instructions()</span>
<span id="cb318-13"><a href="#cb318-13"></a>        op = code.Opcode(ins[ip])</span>
<span id="cb318-14"><a href="#cb318-14"></a></span>
<span id="cb318-15"><a href="#cb318-15"></a>        <span class="kw">switch</span> op {</span>
<span id="cb318-16"><a href="#cb318-16"></a>        <span class="co">// [...]</span></span>
<span id="cb318-17"><a href="#cb318-17"></a>        }</span>
<span id="cb318-18"><a href="#cb318-18"></a>    }</span>
<span id="cb318-19"><a href="#cb318-19"></a></span>
<span id="cb318-20"><a href="#cb318-20"></a>    <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb318-21"><a href="#cb318-21"></a>}</span></code></pre></div>
<p>We add the three helper variables – <code>ip</code>, <code>ins</code> and <code>op</code> – at the top of the <code>Run</code> method, so the rest of it doesn’t become too crowded with calls to <code>currentFrame()</code>. Especially since we now need to update every place in <code>Run</code> where we either read in operands or access or modify the instruction pointer:</p>
<div class="sourceCode" id="cb319"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb319-1"><a href="#cb319-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb319-2"><a href="#cb319-2"></a></span>
<span id="cb319-3"><a href="#cb319-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb319-4"><a href="#cb319-4"></a>    <span class="co">// [...]</span></span>
<span id="cb319-5"><a href="#cb319-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb319-6"><a href="#cb319-6"></a>        <span class="kw">case</span> code.OpConstant:</span>
<span id="cb319-7"><a href="#cb319-7"></a>            constIndex := code.ReadUint16(ins[ip+<span class="dv">1</span>:])</span>
<span id="cb319-8"><a href="#cb319-8"></a>            vm.currentFrame().ip += <span class="dv">2</span></span>
<span id="cb319-9"><a href="#cb319-9"></a>        <span class="co">// [...]</span></span>
<span id="cb319-10"><a href="#cb319-10"></a></span>
<span id="cb319-11"><a href="#cb319-11"></a>        <span class="kw">case</span> code.OpJump:</span>
<span id="cb319-12"><a href="#cb319-12"></a>            pos := <span class="dt">int</span>(code.ReadUint16(ins[ip+<span class="dv">1</span>:]))</span>
<span id="cb319-13"><a href="#cb319-13"></a>            vm.currentFrame().ip = pos - <span class="dv">1</span></span>
<span id="cb319-14"><a href="#cb319-14"></a>        <span class="co">// [...]</span></span>
<span id="cb319-15"><a href="#cb319-15"></a></span>
<span id="cb319-16"><a href="#cb319-16"></a>        <span class="kw">case</span> code.OpJumpNotTruthy:</span>
<span id="cb319-17"><a href="#cb319-17"></a>            pos := <span class="dt">int</span>(code.ReadUint16(ins[ip+<span class="dv">1</span>:]))</span>
<span id="cb319-18"><a href="#cb319-18"></a>            vm.currentFrame().ip += <span class="dv">2</span></span>
<span id="cb319-19"><a href="#cb319-19"></a></span>
<span id="cb319-20"><a href="#cb319-20"></a>            condition := vm.pop()</span>
<span id="cb319-21"><a href="#cb319-21"></a>            <span class="kw">if</span> !isTruthy(condition) {</span>
<span id="cb319-22"><a href="#cb319-22"></a>                vm.currentFrame().ip = pos - <span class="dv">1</span></span>
<span id="cb319-23"><a href="#cb319-23"></a>            }</span>
<span id="cb319-24"><a href="#cb319-24"></a>        <span class="co">// [...]</span></span>
<span id="cb319-25"><a href="#cb319-25"></a></span>
<span id="cb319-26"><a href="#cb319-26"></a>        <span class="kw">case</span> code.OpSetGlobal:</span>
<span id="cb319-27"><a href="#cb319-27"></a>            globalIndex := code.ReadUint16(ins[ip+<span class="dv">1</span>:])</span>
<span id="cb319-28"><a href="#cb319-28"></a>            vm.currentFrame().ip += <span class="dv">2</span></span>
<span id="cb319-29"><a href="#cb319-29"></a>        <span class="co">// [...]</span></span>
<span id="cb319-30"><a href="#cb319-30"></a></span>
<span id="cb319-31"><a href="#cb319-31"></a>        <span class="kw">case</span> code.OpGetGlobal:</span>
<span id="cb319-32"><a href="#cb319-32"></a>            globalIndex := code.ReadUint16(ins[ip+<span class="dv">1</span>:])</span>
<span id="cb319-33"><a href="#cb319-33"></a>            vm.currentFrame().ip += <span class="dv">2</span></span>
<span id="cb319-34"><a href="#cb319-34"></a>        <span class="co">// [...]</span></span>
<span id="cb319-35"><a href="#cb319-35"></a></span>
<span id="cb319-36"><a href="#cb319-36"></a>        <span class="kw">case</span> code.OpArray:</span>
<span id="cb319-37"><a href="#cb319-37"></a>            numElements := <span class="dt">int</span>(code.ReadUint16(ins[ip+<span class="dv">1</span>:]))</span>
<span id="cb319-38"><a href="#cb319-38"></a>            vm.currentFrame().ip += <span class="dv">2</span></span>
<span id="cb319-39"><a href="#cb319-39"></a>        <span class="co">// [...]</span></span>
<span id="cb319-40"><a href="#cb319-40"></a></span>
<span id="cb319-41"><a href="#cb319-41"></a>        <span class="kw">case</span> code.OpHash:</span>
<span id="cb319-42"><a href="#cb319-42"></a>            numElements := <span class="dt">int</span>(code.ReadUint16(ins[ip+<span class="dv">1</span>:]))</span>
<span id="cb319-43"><a href="#cb319-43"></a>            vm.currentFrame().ip += <span class="dv">2</span></span>
<span id="cb319-44"><a href="#cb319-44"></a>        <span class="co">// [...]</span></span>
<span id="cb319-45"><a href="#cb319-45"></a></span>
<span id="cb319-46"><a href="#cb319-46"></a>        }</span>
<span id="cb319-47"><a href="#cb319-47"></a></span>
<span id="cb319-48"><a href="#cb319-48"></a>    <span class="co">// [...]</span></span>
<span id="cb319-49"><a href="#cb319-49"></a>}</span></code></pre></div>
<p>And that was it: our VM is now fully converted to frames! And the best bit is that all the tests are still green:</p>
<div class="sourceCode" id="cb320"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb320-1"><a href="#cb320-1"></a>$ go test ./vm</span>
<span id="cb320-2"><a href="#cb320-2"></a>ok      monkey/vm   0.036s</span></code></pre></div>
<p>Time to add function calls.</p>
<h4 id="executing-function-calls">Executing Function Calls</h4>
<p>It’s high time and we know exactly what we want:</p>
<div class="sourceCode" id="cb321"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb321-1"><a href="#cb321-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb321-2"><a href="#cb321-2"></a></span>
<span id="cb321-3"><a href="#cb321-3"></a><span class="kw">func</span> TestCallingFunctionsWithoutArguments(t *testing.T) {</span>
<span id="cb321-4"><a href="#cb321-4"></a>    tests := []vmTestCase{</span>
<span id="cb321-5"><a href="#cb321-5"></a>        {</span>
<span id="cb321-6"><a href="#cb321-6"></a>            input: <span class="st">`</span></span>
<span id="cb321-7"><a href="#cb321-7"></a><span class="st">        let fivePlusTen = fn() { 5 + 10; };</span></span>
<span id="cb321-8"><a href="#cb321-8"></a><span class="st">        fivePlusTen();</span></span>
<span id="cb321-9"><a href="#cb321-9"></a><span class="st">        `</span>,</span>
<span id="cb321-10"><a href="#cb321-10"></a>            expected: <span class="dv">15</span>,</span>
<span id="cb321-11"><a href="#cb321-11"></a>        },</span>
<span id="cb321-12"><a href="#cb321-12"></a>    }</span>
<span id="cb321-13"><a href="#cb321-13"></a></span>
<span id="cb321-14"><a href="#cb321-14"></a>    runVmTests(t, tests)</span>
<span id="cb321-15"><a href="#cb321-15"></a>}</span></code></pre></div>
<p>That’s what we’re after! Remember? It’s the goal of this section. Question is, can we already get it to work?</p>
<div class="sourceCode" id="cb322"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb322-1"><a href="#cb322-1"></a>$ go test ./vm</span>
<span id="cb322-2"><a href="#cb322-2"></a>--- FAIL: TestCallingFunctionsWithoutArguments (0.00s)</span>
<span id="cb322-3"><a href="#cb322-3"></a> vm_test.go:443: testIntegerObject failed: object is not Integer.\</span>
<span id="cb322-4"><a href="#cb322-4"></a>   got=*object.CompiledFunction (&amp;{Instructions:\</span>
<span id="cb322-5"><a href="#cb322-5"></a>  0000 OpConstant 0</span>
<span id="cb322-6"><a href="#cb322-6"></a>  0003 OpConstant 1</span>
<span id="cb322-7"><a href="#cb322-7"></a>  0006 OpAdd</span>
<span id="cb322-8"><a href="#cb322-8"></a>  0007 OpReturnValue</span>
<span id="cb322-9"><a href="#cb322-9"></a>  })</span>
<span id="cb322-10"><a href="#cb322-10"></a>FAIL</span>
<span id="cb322-11"><a href="#cb322-11"></a>FAIL    monkey/vm   0.036s</span></code></pre></div>
<p>Well, we always do, don’t we?</p>
<p>Most of the things we need are in place already. We know how to handle global bindings, check. We know how to handle integer expressions, check. We know how to load constants, which compiled functions are, check. And we know how to execute frames, so check here too. What we haven’t yet implemented is the <code>OpCall</code> opcode.</p>
<p>But we already know pretty well what to do when we come across an <code>OpCall</code>:</p>
<div class="sourceCode" id="cb323"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb323-1"><a href="#cb323-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb323-2"><a href="#cb323-2"></a></span>
<span id="cb323-3"><a href="#cb323-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb323-4"><a href="#cb323-4"></a>    <span class="co">// [...]</span></span>
<span id="cb323-5"><a href="#cb323-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb323-6"><a href="#cb323-6"></a>        <span class="co">// [...]</span></span>
<span id="cb323-7"><a href="#cb323-7"></a></span>
<span id="cb323-8"><a href="#cb323-8"></a>        <span class="kw">case</span> code.OpCall:</span>
<span id="cb323-9"><a href="#cb323-9"></a>            fn, ok := vm.stack[vm.sp<span class="dv">-1</span>].(*object.CompiledFunction)</span>
<span id="cb323-10"><a href="#cb323-10"></a>            <span class="kw">if</span> !ok {</span>
<span id="cb323-11"><a href="#cb323-11"></a>                <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;calling non-function&quot;</span>)</span>
<span id="cb323-12"><a href="#cb323-12"></a>            }</span>
<span id="cb323-13"><a href="#cb323-13"></a>            frame := NewFrame(fn)</span>
<span id="cb323-14"><a href="#cb323-14"></a>            vm.pushFrame(frame)</span>
<span id="cb323-15"><a href="#cb323-15"></a></span>
<span id="cb323-16"><a href="#cb323-16"></a>        <span class="co">// [...]</span></span>
<span id="cb323-17"><a href="#cb323-17"></a>        }</span>
<span id="cb323-18"><a href="#cb323-18"></a>    <span class="co">// [...]</span></span>
<span id="cb323-19"><a href="#cb323-19"></a>}</span></code></pre></div>
<p>We get the compiled function off the stack and check if it’s indeed an <code>*object.CompiledFunction</code>. If it’s not, we return an error. If it is, we create a new frame that contains a reference to this function and push it on to the frames stack. As a result, the next iteration of the VM’s main loop fetches the next instruction from the <code>*object.CompiledFunction</code>.</p>
<p>Cross your fingers and awkwardly try to type <code>go test ./vm</code> with them:</p>
<div class="sourceCode" id="cb324"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb324-1"><a href="#cb324-1"></a>$ go test ./vm</span>
<span id="cb324-2"><a href="#cb324-2"></a>--- FAIL: TestCallingFunctionsWithoutArguments (0.00s)</span>
<span id="cb324-3"><a href="#cb324-3"></a> vm_test.go:169: testIntegerObject failed: object has wrong value.\</span>
<span id="cb324-4"><a href="#cb324-4"></a>   got=10, want=15</span>
<span id="cb324-5"><a href="#cb324-5"></a>FAIL</span>
<span id="cb324-6"><a href="#cb324-6"></a>FAIL    monkey/vm   0.034s</span></code></pre></div>
<p>Huh. Okay. We got <code>10</code> when we wanted <code>15</code> to be returned. Shouldn’t <code>10</code> be popped off the stack when we come across the <code>OpAdd</code> instruction? Why is it stil– ahh! We always check for the “last popped element” in our tests! And the <code>15</code> hasn’t been popped off the stack yet.</p>
<p>Come to think of it: why did we even expect that this would work? We haven’t even told the VM yet to handle <code>OpReturnValue</code> instructions!</p>
<div class="sourceCode" id="cb325"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb325-1"><a href="#cb325-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb325-2"><a href="#cb325-2"></a></span>
<span id="cb325-3"><a href="#cb325-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb325-4"><a href="#cb325-4"></a>    <span class="co">// [...]</span></span>
<span id="cb325-5"><a href="#cb325-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb325-6"><a href="#cb325-6"></a>        <span class="co">// [...]</span></span>
<span id="cb325-7"><a href="#cb325-7"></a></span>
<span id="cb325-8"><a href="#cb325-8"></a>        <span class="kw">case</span> code.OpReturnValue:</span>
<span id="cb325-9"><a href="#cb325-9"></a>            returnValue := vm.pop()</span>
<span id="cb325-10"><a href="#cb325-10"></a></span>
<span id="cb325-11"><a href="#cb325-11"></a>            vm.popFrame()</span>
<span id="cb325-12"><a href="#cb325-12"></a>            vm.pop()</span>
<span id="cb325-13"><a href="#cb325-13"></a></span>
<span id="cb325-14"><a href="#cb325-14"></a>            err := vm.push(returnValue)</span>
<span id="cb325-15"><a href="#cb325-15"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb325-16"><a href="#cb325-16"></a>                <span class="kw">return</span> err</span>
<span id="cb325-17"><a href="#cb325-17"></a>            }</span>
<span id="cb325-18"><a href="#cb325-18"></a></span>
<span id="cb325-19"><a href="#cb325-19"></a>        <span class="co">// [...]</span></span>
<span id="cb325-20"><a href="#cb325-20"></a>        }</span>
<span id="cb325-21"><a href="#cb325-21"></a>    <span class="co">// [...]</span></span>
<span id="cb325-22"><a href="#cb325-22"></a>}</span></code></pre></div>
<p>We first pop the return value off the stack and put it on the side. That’s the first part of our calling convention: in the case of an <code>OpReturnValue</code> instruction, the return value sits on top of the stack. Then we pop the frame we just executed off the frame stack so that the next iteration of the VM’s main loop continues executing in the caller context.</p>
<p>And then there’s another <code>vm.pop()</code> call to get the just-called <code>*object.CompiledFunction</code> off the stack. Remember that we said it’s the VM’s implicit task to get the executed function off the stack? This is it.</p>
<p>Watch this:</p>
<div class="sourceCode" id="cb326"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb326-1"><a href="#cb326-1"></a>$ go test ./vm</span>
<span id="cb326-2"><a href="#cb326-2"></a>ok      monkey/vm   0.035s</span></code></pre></div>
<p>We just called and executed a function. Remember this moment! This is a milestone when developing a bytecode VM. Our VM is now not just humming along, it’s roaring. We can even execute multiple functions – sequentially or nested in one another:</p>
<div class="sourceCode" id="cb327"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb327-1"><a href="#cb327-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb327-2"><a href="#cb327-2"></a></span>
<span id="cb327-3"><a href="#cb327-3"></a><span class="kw">func</span> TestCallingFunctionsWithoutArguments(t *testing.T) {</span>
<span id="cb327-4"><a href="#cb327-4"></a>    tests := []vmTestCase{</span>
<span id="cb327-5"><a href="#cb327-5"></a>        <span class="co">// [...]</span></span>
<span id="cb327-6"><a href="#cb327-6"></a>        {</span>
<span id="cb327-7"><a href="#cb327-7"></a>            input: <span class="st">`</span></span>
<span id="cb327-8"><a href="#cb327-8"></a><span class="st">        let one = fn() { 1; };</span></span>
<span id="cb327-9"><a href="#cb327-9"></a><span class="st">        let two = fn() { 2; };</span></span>
<span id="cb327-10"><a href="#cb327-10"></a><span class="st">        one() + two()</span></span>
<span id="cb327-11"><a href="#cb327-11"></a><span class="st">        `</span>,</span>
<span id="cb327-12"><a href="#cb327-12"></a>            expected: <span class="dv">3</span>,</span>
<span id="cb327-13"><a href="#cb327-13"></a>        },</span>
<span id="cb327-14"><a href="#cb327-14"></a>        {</span>
<span id="cb327-15"><a href="#cb327-15"></a>            input: <span class="st">`</span></span>
<span id="cb327-16"><a href="#cb327-16"></a><span class="st">        let a = fn() { 1 };</span></span>
<span id="cb327-17"><a href="#cb327-17"></a><span class="st">        let b = fn() { a() + 1 };</span></span>
<span id="cb327-18"><a href="#cb327-18"></a><span class="st">        let c = fn() { b() + 1 };</span></span>
<span id="cb327-19"><a href="#cb327-19"></a><span class="st">        c();</span></span>
<span id="cb327-20"><a href="#cb327-20"></a><span class="st">        `</span>,</span>
<span id="cb327-21"><a href="#cb327-21"></a>            expected: <span class="dv">3</span>,</span>
<span id="cb327-22"><a href="#cb327-22"></a>        },</span>
<span id="cb327-23"><a href="#cb327-23"></a>    }</span>
<span id="cb327-24"><a href="#cb327-24"></a></span>
<span id="cb327-25"><a href="#cb327-25"></a>    runVmTests(t, tests)</span>
<span id="cb327-26"><a href="#cb327-26"></a>}</span></code></pre></div>
<p>This thing runs like clockwork:</p>
<div class="sourceCode" id="cb328"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb328-1"><a href="#cb328-1"></a>$ go test ./vm</span>
<span id="cb328-2"><a href="#cb328-2"></a>ok      monkey/vm   0.039s</span></code></pre></div>
<p>We can even be meticulous and add a test for <em>explicit</em> return statements. We already know that these compile down to the same instructions we just successfully executed, but adding it will give us much better feedback should something go wrong in the future:</p>
<div class="sourceCode" id="cb329"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb329-1"><a href="#cb329-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb329-2"><a href="#cb329-2"></a></span>
<span id="cb329-3"><a href="#cb329-3"></a><span class="kw">func</span> TestFunctionsWithReturnStatement(t *testing.T) {</span>
<span id="cb329-4"><a href="#cb329-4"></a>    tests := []vmTestCase{</span>
<span id="cb329-5"><a href="#cb329-5"></a>        {</span>
<span id="cb329-6"><a href="#cb329-6"></a>            input: <span class="st">`</span></span>
<span id="cb329-7"><a href="#cb329-7"></a><span class="st">        let earlyExit = fn() { return 99; 100; };</span></span>
<span id="cb329-8"><a href="#cb329-8"></a><span class="st">        earlyExit();</span></span>
<span id="cb329-9"><a href="#cb329-9"></a><span class="st">        `</span>,</span>
<span id="cb329-10"><a href="#cb329-10"></a>            expected: <span class="dv">99</span>,</span>
<span id="cb329-11"><a href="#cb329-11"></a>        },</span>
<span id="cb329-12"><a href="#cb329-12"></a>        {</span>
<span id="cb329-13"><a href="#cb329-13"></a>            input: <span class="st">`</span></span>
<span id="cb329-14"><a href="#cb329-14"></a><span class="st">        let earlyExit = fn() { return 99; return 100; };</span></span>
<span id="cb329-15"><a href="#cb329-15"></a><span class="st">        earlyExit();</span></span>
<span id="cb329-16"><a href="#cb329-16"></a><span class="st">        `</span>,</span>
<span id="cb329-17"><a href="#cb329-17"></a>            expected: <span class="dv">99</span>,</span>
<span id="cb329-18"><a href="#cb329-18"></a>        },</span>
<span id="cb329-19"><a href="#cb329-19"></a>    }</span>
<span id="cb329-20"><a href="#cb329-20"></a></span>
<span id="cb329-21"><a href="#cb329-21"></a>    runVmTests(t, tests)</span>
<span id="cb329-22"><a href="#cb329-22"></a>}</span></code></pre></div>
<p>Even that runs without any hiccups:</p>
<div class="sourceCode" id="cb330"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb330-1"><a href="#cb330-1"></a>$ go test ./vm</span>
<span id="cb330-2"><a href="#cb330-2"></a>ok      monkey/vm   0.032s</span></code></pre></div>
<p>Holy opcode! We’re compiling <em>function calls</em> to <em>bytecode</em> and have our own call stack in our <em>bytecode VM</em> and it all works! It’s high time for a nice round of patting ourselves on the back and to sit back and take a deep breath.</p>
<p>But since we’re here…</p>
<h4 id="its-not-nothing-its-null">It’s Not Nothing, It’s Null</h4>
<p>Before we move on, we need to take care of the <code>OpReturn</code> opcode. In the compiler we already made sure that empty functions compile to a single opcode: <code>OpReturn</code>. We also decided that calling these functions should put <code>vm.Null</code> on the VM’s stack and now is the time to implement that.</p>
<p>Thankfully, this last paragraph is a straightforward definition of the desired behaviour and can be rewritten as a test:</p>
<div class="sourceCode" id="cb331"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb331-1"><a href="#cb331-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb331-2"><a href="#cb331-2"></a></span>
<span id="cb331-3"><a href="#cb331-3"></a><span class="kw">func</span> TestFunctionsWithoutReturnValue(t *testing.T) {</span>
<span id="cb331-4"><a href="#cb331-4"></a>    tests := []vmTestCase{</span>
<span id="cb331-5"><a href="#cb331-5"></a>        {</span>
<span id="cb331-6"><a href="#cb331-6"></a>            input: <span class="st">`</span></span>
<span id="cb331-7"><a href="#cb331-7"></a><span class="st">        let noReturn = fn() { };</span></span>
<span id="cb331-8"><a href="#cb331-8"></a><span class="st">        noReturn();</span></span>
<span id="cb331-9"><a href="#cb331-9"></a><span class="st">        `</span>,</span>
<span id="cb331-10"><a href="#cb331-10"></a>            expected: Null,</span>
<span id="cb331-11"><a href="#cb331-11"></a>        },</span>
<span id="cb331-12"><a href="#cb331-12"></a>        {</span>
<span id="cb331-13"><a href="#cb331-13"></a>            input: <span class="st">`</span></span>
<span id="cb331-14"><a href="#cb331-14"></a><span class="st">        let noReturn = fn() { };</span></span>
<span id="cb331-15"><a href="#cb331-15"></a><span class="st">        let noReturnTwo = fn() { noReturn(); };</span></span>
<span id="cb331-16"><a href="#cb331-16"></a><span class="st">        noReturn();</span></span>
<span id="cb331-17"><a href="#cb331-17"></a><span class="st">        noReturnTwo();</span></span>
<span id="cb331-18"><a href="#cb331-18"></a><span class="st">        `</span>,</span>
<span id="cb331-19"><a href="#cb331-19"></a>            expected: Null,</span>
<span id="cb331-20"><a href="#cb331-20"></a>        },</span>
<span id="cb331-21"><a href="#cb331-21"></a>    }</span>
<span id="cb331-22"><a href="#cb331-22"></a></span>
<span id="cb331-23"><a href="#cb331-23"></a>    runVmTests(t, tests)</span>
<span id="cb331-24"><a href="#cb331-24"></a>}</span></code></pre></div>
<p>Clueless as our VM is about <code>OpReturn</code>, it doesn’t put <code>vm.Null</code> on the stack:</p>
<div class="sourceCode" id="cb332"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb332-1"><a href="#cb332-1"></a>$ go test ./vm</span>
<span id="cb332-2"><a href="#cb332-2"></a>--- FAIL: TestFunctionsWithoutReturnValue (0.00s)</span>
<span id="cb332-3"><a href="#cb332-3"></a> vm_test.go:546: object is not Null: &lt;nil&gt; (&lt;nil&gt;)</span>
<span id="cb332-4"><a href="#cb332-4"></a> vm_test.go:546: object is not Null: &lt;nil&gt; (&lt;nil&gt;)</span>
<span id="cb332-5"><a href="#cb332-5"></a>FAIL</span>
<span id="cb332-6"><a href="#cb332-6"></a>FAIL    monkey/vm   0.037s</span></code></pre></div>
<p>What do we have to do to fix these test cases? We already know how to return from a function and we even know how to return <em>with a value</em>. Now we have to do <em>less</em>:</p>
<div class="sourceCode" id="cb333"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb333-1"><a href="#cb333-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb333-2"><a href="#cb333-2"></a></span>
<span id="cb333-3"><a href="#cb333-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb333-4"><a href="#cb333-4"></a>    <span class="co">// [...]</span></span>
<span id="cb333-5"><a href="#cb333-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb333-6"><a href="#cb333-6"></a>        <span class="co">// [...]</span></span>
<span id="cb333-7"><a href="#cb333-7"></a></span>
<span id="cb333-8"><a href="#cb333-8"></a>        <span class="kw">case</span> code.OpReturn:</span>
<span id="cb333-9"><a href="#cb333-9"></a>            vm.popFrame()</span>
<span id="cb333-10"><a href="#cb333-10"></a>            vm.pop()</span>
<span id="cb333-11"><a href="#cb333-11"></a></span>
<span id="cb333-12"><a href="#cb333-12"></a>            err := vm.push(Null)</span>
<span id="cb333-13"><a href="#cb333-13"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb333-14"><a href="#cb333-14"></a>                <span class="kw">return</span> err</span>
<span id="cb333-15"><a href="#cb333-15"></a>            }</span>
<span id="cb333-16"><a href="#cb333-16"></a></span>
<span id="cb333-17"><a href="#cb333-17"></a>        <span class="co">// [...]</span></span>
<span id="cb333-18"><a href="#cb333-18"></a>        }</span>
<span id="cb333-19"><a href="#cb333-19"></a>    <span class="co">// [...]</span></span>
<span id="cb333-20"><a href="#cb333-20"></a>}</span></code></pre></div>
<p>Pop the frame, pop the called function, push <code>Null</code>. Done:</p>
<div class="sourceCode" id="cb334"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb334-1"><a href="#cb334-1"></a>$ go test ./vm</span>
<span id="cb334-2"><a href="#cb334-2"></a>ok      monkey/vm   0.038s</span></code></pre></div>
<h3 id="a-little-bonus">A Little Bonus</h3>
<p>Here’s a little treat. In this section, we did more than reach the milestone of compiling and executing the snippet we set out to get working. We also – without making it a goal or even thinking about it – managed to implement the best thing since REPLs and fast unit tests: first-class functions. Yes, the compiler and VM are already capable of compiling and executing the following piece of Monkey code:</p>
<div class="sourceCode" id="cb335"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb335-1"><a href="#cb335-1"></a><span class="kw">let</span> returnsOne <span class="op">=</span> fn() { <span class="dv">1</span><span class="op">;</span> }<span class="op">;</span></span>
<span id="cb335-2"><a href="#cb335-2"></a><span class="kw">let</span> returnsOneReturner <span class="op">=</span> fn() { returnsOne<span class="op">;</span> }<span class="op">;</span></span>
<span id="cb335-3"><a href="#cb335-3"></a>returnsOneReturner()()<span class="op">;</span></span></code></pre></div>
<p>Don’t believe me? Well, no need, I’m willing to bet a test case on it:</p>
<div class="sourceCode" id="cb336"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb336-1"><a href="#cb336-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb336-2"><a href="#cb336-2"></a></span>
<span id="cb336-3"><a href="#cb336-3"></a><span class="kw">func</span> TestFirstClassFunctions(t *testing.T) {</span>
<span id="cb336-4"><a href="#cb336-4"></a>    tests := []vmTestCase{</span>
<span id="cb336-5"><a href="#cb336-5"></a>        {</span>
<span id="cb336-6"><a href="#cb336-6"></a>            input: <span class="st">`</span></span>
<span id="cb336-7"><a href="#cb336-7"></a><span class="st">        let returnsOne = fn() { 1; };</span></span>
<span id="cb336-8"><a href="#cb336-8"></a><span class="st">        let returnsOneReturner = fn() { returnsOne; };</span></span>
<span id="cb336-9"><a href="#cb336-9"></a><span class="st">        returnsOneReturner()();</span></span>
<span id="cb336-10"><a href="#cb336-10"></a><span class="st">        `</span>,</span>
<span id="cb336-11"><a href="#cb336-11"></a>            expected: <span class="dv">1</span>,</span>
<span id="cb336-12"><a href="#cb336-12"></a>        },</span>
<span id="cb336-13"><a href="#cb336-13"></a>    }</span>
<span id="cb336-14"><a href="#cb336-14"></a></span>
<span id="cb336-15"><a href="#cb336-15"></a>    runVmTests(t, tests)</span>
<span id="cb336-16"><a href="#cb336-16"></a>}</span></code></pre></div>
<p>Here’s what we achieved without even intending to:</p>
<div class="sourceCode" id="cb337"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb337-1"><a href="#cb337-1"></a>$ go test ./vm</span>
<span id="cb337-2"><a href="#cb337-2"></a>ok      monkey/vm   0.038s</span></code></pre></div>
<p>If it wouldn’t be us patting ourselves shamelessly on our backs, I’d say that’s a note as high as you can end a section on.</p>
<h2 id="local-bindings">Local Bindings</h2>
<p>Our current implementation of functions and function calls does not support local bindings. We do support bindings, but only global ones. Local bindings are different in a crucial detail, in that they are <em>local to a function</em>, meaning that they are only visible and accessible within the scope of a function. This detail is crucial because it ties the implementation of local bindings to the implementation of functions. And since we did a great job with the second one, we’re now ready to approach the first one.</p>
<p>At the end of this section we want to have this piece of Monkey code working:</p>
<div class="sourceCode" id="cb338"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb338-1"><a href="#cb338-1"></a><span class="kw">let</span> globalSeed <span class="op">=</span> <span class="dv">50</span><span class="op">;</span></span>
<span id="cb338-2"><a href="#cb338-2"></a><span class="kw">let</span> minusOne <span class="op">=</span> fn() {</span>
<span id="cb338-3"><a href="#cb338-3"></a>  <span class="kw">let</span> num <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb338-4"><a href="#cb338-4"></a>  globalSeed <span class="op">-</span> num<span class="op">;</span></span>
<span id="cb338-5"><a href="#cb338-5"></a>}</span>
<span id="cb338-6"><a href="#cb338-6"></a><span class="kw">let</span> minusTwo <span class="op">=</span> fn() {</span>
<span id="cb338-7"><a href="#cb338-7"></a>  <span class="kw">let</span> num <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb338-8"><a href="#cb338-8"></a>  globalSeed <span class="op">-</span> num<span class="op">;</span></span>
<span id="cb338-9"><a href="#cb338-9"></a>}</span>
<span id="cb338-10"><a href="#cb338-10"></a>minusOne() <span class="op">+</span> minusTwo()</span></code></pre></div>
<p>What we have here is a mixture of global and local bindings. <code>globalSeed</code> is a global binding that can be accessed in nested scopes, like the <code>minusOne</code> and <code>minusTwo</code> functions. Then we also have the local binding <code>num</code>, showing up in both functions. Important about <code>num</code> is that it’s not accessible outside these functions and that both bindings of <code>num</code> in each function are unique and don’t overwrite each other.</p>
<p>In order to get this piece of code compiled and executed, we need to do a few different things.</p>
<p>First of all, we need to define opcodes that tell the VM to create local binding and to retrieve them. I bet you guessed as much.</p>
<p>Then we need to extend the compiler so it can output these new opcodes correctly. That means, it needs to distinguish between local bindings and global bindings, and also between local bindings with the same name in different functions.</p>
<p>The last step is to implement these new instructions and local bindings in the VM. We already know how to store and access global bindings and that knowledge won’t be wasted, since the main mechanism behind bindings won’t change. But for local bindings we need a new <em>store</em>.</p>
<p>As always, we’ll take small steps and start at the beginning.</p>
<h3 id="opcodes-for-local-bindings">Opcodes for Local Bindings</h3>
<p>We already have two opcodes for bindings in place: <code>OpSetGlobal</code> and <code>OpGetGlobal</code>. Now we need equivalents for local bindings. We don’t even need to be creative here, we’ll just create “local versions” of the global ones and call them <code>OpSetLocal</code> and <code>OpGetLocal</code>. They’ll also, just like the global ones, have one operand each, a unique index for the local binding in question.</p>
<p>The naming doesn’t play a huge role, as you know, because it’s just bytes underneath. The important bit is that these opcodes are distinct from the global ones. They should tell VM that the binding is <em>local</em> to the currently executing function and that it should have absolutely no effect on global bindings. The binding shouldn’t overwrite a global binding and it itself shouldn’t be overwritten by one.</p>
<p>And since defining opcodes is a rather dull task, we’ll treat ourselves to a little flourish: instead of giving these new opcodes the two-byte operand their global cousins have, we’ll use one byte, which we haven’t had before. And besides that, 256 local bindings per function should surely be enough for the average Monkey program, right?</p>
<p>Here are the definitions:</p>
<div class="sourceCode" id="cb339"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb339-1"><a href="#cb339-1"></a><span class="co">// code/code.go</span></span>
<span id="cb339-2"><a href="#cb339-2"></a></span>
<span id="cb339-3"><a href="#cb339-3"></a><span class="kw">const</span> (</span>
<span id="cb339-4"><a href="#cb339-4"></a>    <span class="co">// [...]</span></span>
<span id="cb339-5"><a href="#cb339-5"></a></span>
<span id="cb339-6"><a href="#cb339-6"></a>    OpGetLocal</span>
<span id="cb339-7"><a href="#cb339-7"></a>    OpSetLocal</span>
<span id="cb339-8"><a href="#cb339-8"></a>)</span>
<span id="cb339-9"><a href="#cb339-9"></a></span>
<span id="cb339-10"><a href="#cb339-10"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb339-11"><a href="#cb339-11"></a>    <span class="co">// [...]</span></span>
<span id="cb339-12"><a href="#cb339-12"></a></span>
<span id="cb339-13"><a href="#cb339-13"></a>    OpGetLocal: {<span class="st">&quot;OpGetLocal&quot;</span>, []<span class="dt">int</span>{<span class="dv">1</span>}},</span>
<span id="cb339-14"><a href="#cb339-14"></a>    OpSetLocal: {<span class="st">&quot;OpSetLocal&quot;</span>, []<span class="dt">int</span>{<span class="dv">1</span>}},</span>
<span id="cb339-15"><a href="#cb339-15"></a>}</span></code></pre></div>
<p>Nothing surprising here, only the one-byte operands are new. That means we need to make sure our existing tooling can handle them:</p>
<div class="sourceCode" id="cb340"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb340-1"><a href="#cb340-1"></a><span class="co">// code/code_test.go</span></span>
<span id="cb340-2"><a href="#cb340-2"></a></span>
<span id="cb340-3"><a href="#cb340-3"></a><span class="kw">func</span> TestMake(t *testing.T) {</span>
<span id="cb340-4"><a href="#cb340-4"></a>    tests := []<span class="kw">struct</span> {</span>
<span id="cb340-5"><a href="#cb340-5"></a>        op       Opcode</span>
<span id="cb340-6"><a href="#cb340-6"></a>        operands []<span class="dt">int</span></span>
<span id="cb340-7"><a href="#cb340-7"></a>        expected []<span class="dt">byte</span></span>
<span id="cb340-8"><a href="#cb340-8"></a>    }{</span>
<span id="cb340-9"><a href="#cb340-9"></a>        <span class="co">// [...]</span></span>
<span id="cb340-10"><a href="#cb340-10"></a>        {OpGetLocal, []<span class="dt">int</span>{<span class="dv">255</span>}, []<span class="dt">byte</span>{<span class="dt">byte</span>(OpGetLocal), <span class="dv">255</span>}},</span>
<span id="cb340-11"><a href="#cb340-11"></a>    }</span>
<span id="cb340-12"><a href="#cb340-12"></a></span>
<span id="cb340-13"><a href="#cb340-13"></a>    <span class="co">// [...]</span></span>
<span id="cb340-14"><a href="#cb340-14"></a>}</span></code></pre></div>
<p>Rightfully, <code>Make</code> is stumped by the one byte:</p>
<div class="sourceCode" id="cb341"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb341-1"><a href="#cb341-1"></a>$ go test ./code</span>
<span id="cb341-2"><a href="#cb341-2"></a>--- FAIL: TestMake (0.00s)</span>
<span id="cb341-3"><a href="#cb341-3"></a> code_test.go:26: wrong byte at pos 1. want=255, got=0</span>
<span id="cb341-4"><a href="#cb341-4"></a>FAIL</span>
<span id="cb341-5"><a href="#cb341-5"></a>FAIL    monkey/code 0.007s</span></code></pre></div>
<p>Getting <code>Make</code> to work means extending its <code>switch</code> statement, which I promised you to do since it’s been introduced:</p>
<div class="sourceCode" id="cb342"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb342-1"><a href="#cb342-1"></a><span class="co">// code/code.go</span></span>
<span id="cb342-2"><a href="#cb342-2"></a></span>
<span id="cb342-3"><a href="#cb342-3"></a><span class="kw">func</span> Make(op Opcode, operands ...<span class="dt">int</span>) []<span class="dt">byte</span> {</span>
<span id="cb342-4"><a href="#cb342-4"></a>    <span class="co">// [...]</span></span>
<span id="cb342-5"><a href="#cb342-5"></a></span>
<span id="cb342-6"><a href="#cb342-6"></a>    offset := <span class="dv">1</span></span>
<span id="cb342-7"><a href="#cb342-7"></a>    <span class="kw">for</span> i, o := <span class="kw">range</span> operands {</span>
<span id="cb342-8"><a href="#cb342-8"></a>        width := def.OperandWidths[i]</span>
<span id="cb342-9"><a href="#cb342-9"></a>        <span class="kw">switch</span> width {</span>
<span id="cb342-10"><a href="#cb342-10"></a>        <span class="kw">case</span> <span class="dv">2</span>:</span>
<span id="cb342-11"><a href="#cb342-11"></a>            binary.BigEndian.PutUint16(instruction[offset:], <span class="dt">uint16</span>(o))</span>
<span id="cb342-12"><a href="#cb342-12"></a>        <span class="kw">case</span> <span class="dv">1</span>:</span>
<span id="cb342-13"><a href="#cb342-13"></a>            instruction[offset] = <span class="dt">byte</span>(o)</span>
<span id="cb342-14"><a href="#cb342-14"></a>        }</span>
<span id="cb342-15"><a href="#cb342-15"></a>        offset += width</span>
<span id="cb342-16"><a href="#cb342-16"></a>    }</span>
<span id="cb342-17"><a href="#cb342-17"></a></span>
<span id="cb342-18"><a href="#cb342-18"></a>    <span class="kw">return</span> instruction</span>
<span id="cb342-19"><a href="#cb342-19"></a>}</span></code></pre></div>
<p>The added <code>case 1</code> branch is enough to get it working, since there’s only one way to sort a single byte:</p>
<div class="sourceCode" id="cb343"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb343-1"><a href="#cb343-1"></a>$ go test ./code</span>
<span id="cb343-2"><a href="#cb343-2"></a>ok      monkey/code 0.007s</span></code></pre></div>
<p>With <code>Make</code> working, we can now produce instructions with one-byte operands, but we can’t decode them. For that, we need to update our <code>ReadOperands</code> function and the <code>String()</code> debug method on <code>Instructions</code>:</p>
<div class="sourceCode" id="cb344"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb344-1"><a href="#cb344-1"></a><span class="co">// code/code_test.go</span></span>
<span id="cb344-2"><a href="#cb344-2"></a></span>
<span id="cb344-3"><a href="#cb344-3"></a><span class="kw">func</span> TestReadOperands(t *testing.T) {</span>
<span id="cb344-4"><a href="#cb344-4"></a>    tests := []<span class="kw">struct</span> {</span>
<span id="cb344-5"><a href="#cb344-5"></a>        op        Opcode</span>
<span id="cb344-6"><a href="#cb344-6"></a>        operands  []<span class="dt">int</span></span>
<span id="cb344-7"><a href="#cb344-7"></a>        bytesRead <span class="dt">int</span></span>
<span id="cb344-8"><a href="#cb344-8"></a>    }{</span>
<span id="cb344-9"><a href="#cb344-9"></a>        <span class="co">// [...]</span></span>
<span id="cb344-10"><a href="#cb344-10"></a>        {OpGetLocal, []<span class="dt">int</span>{<span class="dv">255</span>}, <span class="dv">1</span>},</span>
<span id="cb344-11"><a href="#cb344-11"></a>    }</span>
<span id="cb344-12"><a href="#cb344-12"></a></span>
<span id="cb344-13"><a href="#cb344-13"></a>    <span class="co">// [...]</span></span>
<span id="cb344-14"><a href="#cb344-14"></a>}</span>
<span id="cb344-15"><a href="#cb344-15"></a></span>
<span id="cb344-16"><a href="#cb344-16"></a><span class="kw">func</span> TestInstructionsString(t *testing.T) {</span>
<span id="cb344-17"><a href="#cb344-17"></a>    instructions := []Instructions{</span>
<span id="cb344-18"><a href="#cb344-18"></a>        Make(OpAdd),</span>
<span id="cb344-19"><a href="#cb344-19"></a>        Make(OpGetLocal, <span class="dv">1</span>),</span>
<span id="cb344-20"><a href="#cb344-20"></a>        Make(OpConstant, <span class="dv">2</span>),</span>
<span id="cb344-21"><a href="#cb344-21"></a>        Make(OpConstant, <span class="dv">65535</span>),</span>
<span id="cb344-22"><a href="#cb344-22"></a>    }</span>
<span id="cb344-23"><a href="#cb344-23"></a></span>
<span id="cb344-24"><a href="#cb344-24"></a>    expected := <span class="st">`0000 OpAdd</span></span>
<span id="cb344-25"><a href="#cb344-25"></a><span class="st">0001 OpGetLocal 1</span></span>
<span id="cb344-26"><a href="#cb344-26"></a><span class="st">0003 OpConstant 2</span></span>
<span id="cb344-27"><a href="#cb344-27"></a><span class="st">0006 OpConstant 65535</span></span>
<span id="cb344-28"><a href="#cb344-28"></a><span class="st">`</span></span>
<span id="cb344-29"><a href="#cb344-29"></a></span>
<span id="cb344-30"><a href="#cb344-30"></a>    <span class="co">// [...]</span></span>
<span id="cb344-31"><a href="#cb344-31"></a>}</span></code></pre></div>
<p>Both test functions blow up, because they both depend on the same function underneath:</p>
<div class="sourceCode" id="cb345"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb345-1"><a href="#cb345-1"></a>$ go test ./code</span>
<span id="cb345-2"><a href="#cb345-2"></a>--- FAIL: TestInstructionsString (0.00s)</span>
<span id="cb345-3"><a href="#cb345-3"></a> code_test.go:53: instructions wrongly formatted.</span>
<span id="cb345-4"><a href="#cb345-4"></a>  want=&quot;0000 OpAdd\n0001 OpGetLocal 1\n0003 OpConstant 2\n\</span>
<span id="cb345-5"><a href="#cb345-5"></a>    0006 OpConstant 65535\n&quot;</span>
<span id="cb345-6"><a href="#cb345-6"></a>  got=&quot;0000 OpAdd\n0001 OpGetLocal 0\n0003 OpConstant 2\n\</span>
<span id="cb345-7"><a href="#cb345-7"></a>    0006 OpConstant 65535\n&quot;</span>
<span id="cb345-8"><a href="#cb345-8"></a>--- FAIL: TestReadOperands (0.00s)</span>
<span id="cb345-9"><a href="#cb345-9"></a> code_test.go:83: operand wrong. want=255, got=0</span>
<span id="cb345-10"><a href="#cb345-10"></a>FAIL</span>
<span id="cb345-11"><a href="#cb345-11"></a>FAIL    monkey/code 0.006s</span></code></pre></div>
<p>To fix these tests we create a <code>ReadUint8</code> function and use it in <code>ReadOperands</code>:</p>
<div class="sourceCode" id="cb346"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb346-1"><a href="#cb346-1"></a><span class="co">// code/code.go</span></span>
<span id="cb346-2"><a href="#cb346-2"></a></span>
<span id="cb346-3"><a href="#cb346-3"></a><span class="kw">func</span> ReadOperands(def *Definition, ins Instructions) ([]<span class="dt">int</span>, <span class="dt">int</span>) {</span>
<span id="cb346-4"><a href="#cb346-4"></a>    operands := <span class="bu">make</span>([]<span class="dt">int</span>, <span class="bu">len</span>(def.OperandWidths))</span>
<span id="cb346-5"><a href="#cb346-5"></a>    offset := <span class="dv">0</span></span>
<span id="cb346-6"><a href="#cb346-6"></a></span>
<span id="cb346-7"><a href="#cb346-7"></a>    <span class="kw">for</span> i, width := <span class="kw">range</span> def.OperandWidths {</span>
<span id="cb346-8"><a href="#cb346-8"></a>        <span class="kw">switch</span> width {</span>
<span id="cb346-9"><a href="#cb346-9"></a>        <span class="kw">case</span> <span class="dv">2</span>:</span>
<span id="cb346-10"><a href="#cb346-10"></a>            operands[i] = <span class="dt">int</span>(ReadUint16(ins[offset:]))</span>
<span id="cb346-11"><a href="#cb346-11"></a>        <span class="kw">case</span> <span class="dv">1</span>:</span>
<span id="cb346-12"><a href="#cb346-12"></a>            operands[i] = <span class="dt">int</span>(ReadUint8(ins[offset:]))</span>
<span id="cb346-13"><a href="#cb346-13"></a>        }</span>
<span id="cb346-14"><a href="#cb346-14"></a></span>
<span id="cb346-15"><a href="#cb346-15"></a>        offset += width</span>
<span id="cb346-16"><a href="#cb346-16"></a>    }</span>
<span id="cb346-17"><a href="#cb346-17"></a></span>
<span id="cb346-18"><a href="#cb346-18"></a>    <span class="kw">return</span> operands, offset</span>
<span id="cb346-19"><a href="#cb346-19"></a>}</span>
<span id="cb346-20"><a href="#cb346-20"></a></span>
<span id="cb346-21"><a href="#cb346-21"></a><span class="kw">func</span> ReadUint8(ins Instructions) <span class="dt">uint8</span> { <span class="kw">return</span> <span class="dt">uint8</span>(ins[<span class="dv">0</span>]) }</span></code></pre></div>
<p>Yes, reading one byte and turning it into an <code>uint8</code> means nothing more than telling the compiler that from now on it should treat it as such:</p>
<div class="sourceCode" id="cb347"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb347-1"><a href="#cb347-1"></a>$ go test ./code</span>
<span id="cb347-2"><a href="#cb347-2"></a>ok      monkey/code 0.008s</span></code></pre></div>
<p>Alright, we now have two new opcodes, <code>SetLocal</code> and <code>GetLocal</code>, and both have a one-byte operand that’s supported by our infrastructure. Let’s move on to the compiler.</p>
<h3 id="compiling-locals">Compiling Locals</h3>
<p>We already know where and how to emit the correct instructions for bindings, because we already did that for global bindings. The “where” and “how” won’t change now, but the “scope” will. And that’s also the main challenge when it comes to compiling local bindings: deciding whether to emit an instruction for a global or for a local binding.</p>
<p>From the outside, though, it’s clear what we want and easy to express in a test case:</p>
<div class="sourceCode" id="cb348"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb348-1"><a href="#cb348-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb348-2"><a href="#cb348-2"></a></span>
<span id="cb348-3"><a href="#cb348-3"></a><span class="kw">func</span> TestLetStatementScopes(t *testing.T) {</span>
<span id="cb348-4"><a href="#cb348-4"></a>    tests := []compilerTestCase{</span>
<span id="cb348-5"><a href="#cb348-5"></a>        {</span>
<span id="cb348-6"><a href="#cb348-6"></a>            input: <span class="st">`</span></span>
<span id="cb348-7"><a href="#cb348-7"></a><span class="st">            let num = 55;</span></span>
<span id="cb348-8"><a href="#cb348-8"></a><span class="st">            fn() { num }</span></span>
<span id="cb348-9"><a href="#cb348-9"></a><span class="st">            `</span>,</span>
<span id="cb348-10"><a href="#cb348-10"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb348-11"><a href="#cb348-11"></a>                <span class="dv">55</span>,</span>
<span id="cb348-12"><a href="#cb348-12"></a>                []code.Instructions{</span>
<span id="cb348-13"><a href="#cb348-13"></a>                    code.Make(code.OpGetGlobal, <span class="dv">0</span>),</span>
<span id="cb348-14"><a href="#cb348-14"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb348-15"><a href="#cb348-15"></a>                },</span>
<span id="cb348-16"><a href="#cb348-16"></a>            },</span>
<span id="cb348-17"><a href="#cb348-17"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb348-18"><a href="#cb348-18"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb348-19"><a href="#cb348-19"></a>                code.Make(code.OpSetGlobal, <span class="dv">0</span>),</span>
<span id="cb348-20"><a href="#cb348-20"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb348-21"><a href="#cb348-21"></a>                code.Make(code.OpPop),</span>
<span id="cb348-22"><a href="#cb348-22"></a>            },</span>
<span id="cb348-23"><a href="#cb348-23"></a>        },</span>
<span id="cb348-24"><a href="#cb348-24"></a>        {</span>
<span id="cb348-25"><a href="#cb348-25"></a>            input: <span class="st">`</span></span>
<span id="cb348-26"><a href="#cb348-26"></a><span class="st">            fn() {</span></span>
<span id="cb348-27"><a href="#cb348-27"></a><span class="st">                let num = 55;</span></span>
<span id="cb348-28"><a href="#cb348-28"></a><span class="st">                num</span></span>
<span id="cb348-29"><a href="#cb348-29"></a><span class="st">            }</span></span>
<span id="cb348-30"><a href="#cb348-30"></a><span class="st">            `</span>,</span>
<span id="cb348-31"><a href="#cb348-31"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb348-32"><a href="#cb348-32"></a>                <span class="dv">55</span>,</span>
<span id="cb348-33"><a href="#cb348-33"></a>                []code.Instructions{</span>
<span id="cb348-34"><a href="#cb348-34"></a>                    code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb348-35"><a href="#cb348-35"></a>                    code.Make(code.OpSetLocal, <span class="dv">0</span>),</span>
<span id="cb348-36"><a href="#cb348-36"></a>                    code.Make(code.OpGetLocal, <span class="dv">0</span>),</span>
<span id="cb348-37"><a href="#cb348-37"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb348-38"><a href="#cb348-38"></a>                },</span>
<span id="cb348-39"><a href="#cb348-39"></a>            },</span>
<span id="cb348-40"><a href="#cb348-40"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb348-41"><a href="#cb348-41"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb348-42"><a href="#cb348-42"></a>                code.Make(code.OpPop),</span>
<span id="cb348-43"><a href="#cb348-43"></a>            },</span>
<span id="cb348-44"><a href="#cb348-44"></a>        },</span>
<span id="cb348-45"><a href="#cb348-45"></a>        {</span>
<span id="cb348-46"><a href="#cb348-46"></a>            input: <span class="st">`</span></span>
<span id="cb348-47"><a href="#cb348-47"></a><span class="st">            fn() {</span></span>
<span id="cb348-48"><a href="#cb348-48"></a><span class="st">                let a = 55;</span></span>
<span id="cb348-49"><a href="#cb348-49"></a><span class="st">                let b = 77;</span></span>
<span id="cb348-50"><a href="#cb348-50"></a><span class="st">                a + b</span></span>
<span id="cb348-51"><a href="#cb348-51"></a><span class="st">            }</span></span>
<span id="cb348-52"><a href="#cb348-52"></a><span class="st">            `</span>,</span>
<span id="cb348-53"><a href="#cb348-53"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb348-54"><a href="#cb348-54"></a>                <span class="dv">55</span>,</span>
<span id="cb348-55"><a href="#cb348-55"></a>                <span class="dv">77</span>,</span>
<span id="cb348-56"><a href="#cb348-56"></a>                []code.Instructions{</span>
<span id="cb348-57"><a href="#cb348-57"></a>                    code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb348-58"><a href="#cb348-58"></a>                    code.Make(code.OpSetLocal, <span class="dv">0</span>),</span>
<span id="cb348-59"><a href="#cb348-59"></a>                    code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb348-60"><a href="#cb348-60"></a>                    code.Make(code.OpSetLocal, <span class="dv">1</span>),</span>
<span id="cb348-61"><a href="#cb348-61"></a>                    code.Make(code.OpGetLocal, <span class="dv">0</span>),</span>
<span id="cb348-62"><a href="#cb348-62"></a>                    code.Make(code.OpGetLocal, <span class="dv">1</span>),</span>
<span id="cb348-63"><a href="#cb348-63"></a>                    code.Make(code.OpAdd),</span>
<span id="cb348-64"><a href="#cb348-64"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb348-65"><a href="#cb348-65"></a>                },</span>
<span id="cb348-66"><a href="#cb348-66"></a>            },</span>
<span id="cb348-67"><a href="#cb348-67"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb348-68"><a href="#cb348-68"></a>                code.Make(code.OpConstant, <span class="dv">2</span>),</span>
<span id="cb348-69"><a href="#cb348-69"></a>                code.Make(code.OpPop),</span>
<span id="cb348-70"><a href="#cb348-70"></a>            },</span>
<span id="cb348-71"><a href="#cb348-71"></a>        },</span>
<span id="cb348-72"><a href="#cb348-72"></a>    }</span>
<span id="cb348-73"><a href="#cb348-73"></a></span>
<span id="cb348-74"><a href="#cb348-74"></a>    runCompilerTests(t, tests)</span>
<span id="cb348-75"><a href="#cb348-75"></a>}</span></code></pre></div>
<p>Don’t be put off by the line count, this is mostly just busywork around the three use cases we test here. In the first test case, we assert that accessing a global binding from a function results in a <code>OpGetGlobal</code> instruction. In the second one, we expect that creating and accessing a local binding results in the new <code>OpSetLocal</code> and <code>OpGetLocal</code> opcodes being emitted. And in the third one we want to make sure that multiple local bindings in the same scope also work.</p>
<p>As expected, the test fails:</p>
<div class="sourceCode" id="cb349"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb349-1"><a href="#cb349-1"></a>$ go test ./compiler</span>
<span id="cb349-2"><a href="#cb349-2"></a>--- FAIL: TestLetStatementScopes (0.00s)</span>
<span id="cb349-3"><a href="#cb349-3"></a> compiler_test.go:935: testConstants failed:\</span>
<span id="cb349-4"><a href="#cb349-4"></a>   constant 1 - testInstructions failed: wrong instructions length.</span>
<span id="cb349-5"><a href="#cb349-5"></a>  want=&quot;0000 OpConstant 0\n0003 OpSetLocal 0\n0005 OpGetLocal 0\n\</span>
<span id="cb349-6"><a href="#cb349-6"></a>    0007 OpReturnValue\n&quot;</span>
<span id="cb349-7"><a href="#cb349-7"></a>  got =&quot;0000 OpConstant 0\n0003 OpSetGlobal 0\n0006 OpGetGlobal 0\n\</span>
<span id="cb349-8"><a href="#cb349-8"></a>    0009 OpReturnValue\n&quot;</span>
<span id="cb349-9"><a href="#cb349-9"></a>FAIL</span>
<span id="cb349-10"><a href="#cb349-10"></a>FAIL    monkey/compiler 0.009s</span></code></pre></div>
<p>As you can see, the compiler treats every binding created with a let statement as a global binding. In order to fix that, we have to extend the <code>SymbolTable</code>.</p>
<h4 id="extending-the-symbol-table">Extending the Symbol Table</h4>
<p>Currently, our symbol table only knows about one scope, the global one. We now need to extend it so it can not only tell different scopes apart but also in which scope a given symbol was defined.</p>
<p>More specifically, what we want is to just tell the symbol table when we enter or leave a scope in our compiler and it should keep track for us in which scope we’re in and attach that to every symbol we define in that scope. And then, when we ask it to resolve a symbol, it should tell us which unique <code>Index</code> a previously-defined symbol has and in which scope it was defined.</p>
<p>It doesn’t take a lot of code to implement that – once we make our <code>SymbolTable</code> recursive. But before we do that, here’s the list of requirements, translated into a test:</p>
<div class="sourceCode" id="cb350"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb350-1"><a href="#cb350-1"></a><span class="co">// compiler/symbol_table_test.go</span></span>
<span id="cb350-2"><a href="#cb350-2"></a></span>
<span id="cb350-3"><a href="#cb350-3"></a><span class="kw">func</span> TestResolveLocal(t *testing.T) {</span>
<span id="cb350-4"><a href="#cb350-4"></a>    global := NewSymbolTable()</span>
<span id="cb350-5"><a href="#cb350-5"></a>    global.Define(<span class="st">&quot;a&quot;</span>)</span>
<span id="cb350-6"><a href="#cb350-6"></a>    global.Define(<span class="st">&quot;b&quot;</span>)</span>
<span id="cb350-7"><a href="#cb350-7"></a></span>
<span id="cb350-8"><a href="#cb350-8"></a>    local := NewEnclosedSymbolTable(global)</span>
<span id="cb350-9"><a href="#cb350-9"></a>    local.Define(<span class="st">&quot;c&quot;</span>)</span>
<span id="cb350-10"><a href="#cb350-10"></a>    local.Define(<span class="st">&quot;d&quot;</span>)</span>
<span id="cb350-11"><a href="#cb350-11"></a></span>
<span id="cb350-12"><a href="#cb350-12"></a>    expected := []Symbol{</span>
<span id="cb350-13"><a href="#cb350-13"></a>        Symbol{Name: <span class="st">&quot;a&quot;</span>, Scope: GlobalScope, Index: <span class="dv">0</span>},</span>
<span id="cb350-14"><a href="#cb350-14"></a>        Symbol{Name: <span class="st">&quot;b&quot;</span>, Scope: GlobalScope, Index: <span class="dv">1</span>},</span>
<span id="cb350-15"><a href="#cb350-15"></a>        Symbol{Name: <span class="st">&quot;c&quot;</span>, Scope: LocalScope, Index: <span class="dv">0</span>},</span>
<span id="cb350-16"><a href="#cb350-16"></a>        Symbol{Name: <span class="st">&quot;d&quot;</span>, Scope: LocalScope, Index: <span class="dv">1</span>},</span>
<span id="cb350-17"><a href="#cb350-17"></a>    }</span>
<span id="cb350-18"><a href="#cb350-18"></a></span>
<span id="cb350-19"><a href="#cb350-19"></a>    <span class="kw">for</span> _, sym := <span class="kw">range</span> expected {</span>
<span id="cb350-20"><a href="#cb350-20"></a>        result, ok := local.Resolve(sym.Name)</span>
<span id="cb350-21"><a href="#cb350-21"></a>        <span class="kw">if</span> !ok {</span>
<span id="cb350-22"><a href="#cb350-22"></a>            t.Errorf(<span class="st">&quot;name %s not resolvable&quot;</span>, sym.Name)</span>
<span id="cb350-23"><a href="#cb350-23"></a>            <span class="kw">continue</span></span>
<span id="cb350-24"><a href="#cb350-24"></a>        }</span>
<span id="cb350-25"><a href="#cb350-25"></a>        <span class="kw">if</span> result != sym {</span>
<span id="cb350-26"><a href="#cb350-26"></a>            t.Errorf(<span class="st">&quot;expected %s to resolve to %+v, got=%+v&quot;</span>,</span>
<span id="cb350-27"><a href="#cb350-27"></a>                sym.Name, sym, result)</span>
<span id="cb350-28"><a href="#cb350-28"></a>        }</span>
<span id="cb350-29"><a href="#cb350-29"></a>    }</span>
<span id="cb350-30"><a href="#cb350-30"></a>}</span></code></pre></div>
<p>In the first line of <code>TestResolveLocal</code> we create a new symbol table, <code>global</code>, just like we previously did by calling <code>NewSymbolTable</code>. Then we define two symbols in this global symbol table: <code>a</code> and <code>b</code>. After that, we use a new function, called <code>NewEnclosedSymbolTable</code>, to create another symbol table, called <code>local</code>, that’s enclosed in <code>global</code>. In <code>local</code> we then define two new symbols: <code>c</code> and <code>d</code>.</p>
<p>That’s the setup. The expectation is that when we then try to resolve all four symbols by calling <code>Resolve</code> on <code>local</code>, the symbols with the correct <code>Scope</code> and <code>Index</code> fields are returned.</p>
<p>And that’s not all of it. We also want to make sure that the <code>SymbolTable</code> can handle arbitrarily nested and enclosed symbol tables:</p>
<div class="sourceCode" id="cb351"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb351-1"><a href="#cb351-1"></a><span class="co">// compiler/symbol_table_test.go</span></span>
<span id="cb351-2"><a href="#cb351-2"></a></span>
<span id="cb351-3"><a href="#cb351-3"></a><span class="kw">func</span> TestResolveNestedLocal(t *testing.T) {</span>
<span id="cb351-4"><a href="#cb351-4"></a>    global := NewSymbolTable()</span>
<span id="cb351-5"><a href="#cb351-5"></a>    global.Define(<span class="st">&quot;a&quot;</span>)</span>
<span id="cb351-6"><a href="#cb351-6"></a>    global.Define(<span class="st">&quot;b&quot;</span>)</span>
<span id="cb351-7"><a href="#cb351-7"></a></span>
<span id="cb351-8"><a href="#cb351-8"></a>    firstLocal := NewEnclosedSymbolTable(global)</span>
<span id="cb351-9"><a href="#cb351-9"></a>    firstLocal.Define(<span class="st">&quot;c&quot;</span>)</span>
<span id="cb351-10"><a href="#cb351-10"></a>    firstLocal.Define(<span class="st">&quot;d&quot;</span>)</span>
<span id="cb351-11"><a href="#cb351-11"></a></span>
<span id="cb351-12"><a href="#cb351-12"></a>    secondLocal := NewEnclosedSymbolTable(firstLocal)</span>
<span id="cb351-13"><a href="#cb351-13"></a>    secondLocal.Define(<span class="st">&quot;e&quot;</span>)</span>
<span id="cb351-14"><a href="#cb351-14"></a>    secondLocal.Define(<span class="st">&quot;f&quot;</span>)</span>
<span id="cb351-15"><a href="#cb351-15"></a></span>
<span id="cb351-16"><a href="#cb351-16"></a>    tests := []<span class="kw">struct</span> {</span>
<span id="cb351-17"><a href="#cb351-17"></a>        table           *SymbolTable</span>
<span id="cb351-18"><a href="#cb351-18"></a>        expectedSymbols []Symbol</span>
<span id="cb351-19"><a href="#cb351-19"></a>    }{</span>
<span id="cb351-20"><a href="#cb351-20"></a>        {</span>
<span id="cb351-21"><a href="#cb351-21"></a>            firstLocal,</span>
<span id="cb351-22"><a href="#cb351-22"></a>            []Symbol{</span>
<span id="cb351-23"><a href="#cb351-23"></a>                Symbol{Name: <span class="st">&quot;a&quot;</span>, Scope: GlobalScope, Index: <span class="dv">0</span>},</span>
<span id="cb351-24"><a href="#cb351-24"></a>                Symbol{Name: <span class="st">&quot;b&quot;</span>, Scope: GlobalScope, Index: <span class="dv">1</span>},</span>
<span id="cb351-25"><a href="#cb351-25"></a>                Symbol{Name: <span class="st">&quot;c&quot;</span>, Scope: LocalScope, Index: <span class="dv">0</span>},</span>
<span id="cb351-26"><a href="#cb351-26"></a>                Symbol{Name: <span class="st">&quot;d&quot;</span>, Scope: LocalScope, Index: <span class="dv">1</span>},</span>
<span id="cb351-27"><a href="#cb351-27"></a>            },</span>
<span id="cb351-28"><a href="#cb351-28"></a>        },</span>
<span id="cb351-29"><a href="#cb351-29"></a>        {</span>
<span id="cb351-30"><a href="#cb351-30"></a>            secondLocal,</span>
<span id="cb351-31"><a href="#cb351-31"></a>            []Symbol{</span>
<span id="cb351-32"><a href="#cb351-32"></a>                Symbol{Name: <span class="st">&quot;a&quot;</span>, Scope: GlobalScope, Index: <span class="dv">0</span>},</span>
<span id="cb351-33"><a href="#cb351-33"></a>                Symbol{Name: <span class="st">&quot;b&quot;</span>, Scope: GlobalScope, Index: <span class="dv">1</span>},</span>
<span id="cb351-34"><a href="#cb351-34"></a>                Symbol{Name: <span class="st">&quot;e&quot;</span>, Scope: LocalScope, Index: <span class="dv">0</span>},</span>
<span id="cb351-35"><a href="#cb351-35"></a>                Symbol{Name: <span class="st">&quot;f&quot;</span>, Scope: LocalScope, Index: <span class="dv">1</span>},</span>
<span id="cb351-36"><a href="#cb351-36"></a>            },</span>
<span id="cb351-37"><a href="#cb351-37"></a>        },</span>
<span id="cb351-38"><a href="#cb351-38"></a>    }</span>
<span id="cb351-39"><a href="#cb351-39"></a></span>
<span id="cb351-40"><a href="#cb351-40"></a>    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</span>
<span id="cb351-41"><a href="#cb351-41"></a>        <span class="kw">for</span> _, sym := <span class="kw">range</span> tt.expectedSymbols {</span>
<span id="cb351-42"><a href="#cb351-42"></a>            result, ok := tt.table.Resolve(sym.Name)</span>
<span id="cb351-43"><a href="#cb351-43"></a>            <span class="kw">if</span> !ok {</span>
<span id="cb351-44"><a href="#cb351-44"></a>                t.Errorf(<span class="st">&quot;name %s not resolvable&quot;</span>, sym.Name)</span>
<span id="cb351-45"><a href="#cb351-45"></a>                <span class="kw">continue</span></span>
<span id="cb351-46"><a href="#cb351-46"></a>            }</span>
<span id="cb351-47"><a href="#cb351-47"></a>            <span class="kw">if</span> result != sym {</span>
<span id="cb351-48"><a href="#cb351-48"></a>                t.Errorf(<span class="st">&quot;expected %s to resolve to %+v, got=%+v&quot;</span>,</span>
<span id="cb351-49"><a href="#cb351-49"></a>                    sym.Name, sym, result)</span>
<span id="cb351-50"><a href="#cb351-50"></a>            }</span>
<span id="cb351-51"><a href="#cb351-51"></a>        }</span>
<span id="cb351-52"><a href="#cb351-52"></a>    }</span>
<span id="cb351-53"><a href="#cb351-53"></a>}</span></code></pre></div>
<p>Here we go one step further and create a third symbol table, <code>secondLocal</code>, that’s enclosed in <code>firstLocal</code>, which in turn is enclosed in <code>global</code>. In <code>global</code> we again define <code>a</code> and <code>b</code>. In both enclosed symbol tables we also define two symbols each, <code>c</code> and <code>d</code> in <code>firstLocal</code> and <code>e</code> and <code>f</code> in <code>secondLocal</code>.</p>
<p>The expectation is that defining symbols in one local table does not interfere with the definitions in another one, and that resolving global symbols in a nested local table still resolves to the correct symbols. Finally, we also want to make sure that the <code>Index</code> values of the symbols defined in <code>secondLocal</code> again start at zero, so we can use them as operands in <code>OpSetLocal</code> and <code>OpGetLocal</code> without being tied to other scopes.</p>
<p>Since the nesting of symbol tables must also have an effect on the <code>Define</code> method of <code>SymbolTable</code>, we need to update the existing <code>TestDefine</code> function:</p>
<div class="sourceCode" id="cb352"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb352-1"><a href="#cb352-1"></a><span class="co">// compiler/symbol_table_test.go</span></span>
<span id="cb352-2"><a href="#cb352-2"></a></span>
<span id="cb352-3"><a href="#cb352-3"></a><span class="kw">func</span> TestDefine(t *testing.T) {</span>
<span id="cb352-4"><a href="#cb352-4"></a>    expected := <span class="kw">map</span>[<span class="dt">string</span>]Symbol{</span>
<span id="cb352-5"><a href="#cb352-5"></a>        <span class="st">&quot;a&quot;</span>: Symbol{Name: <span class="st">&quot;a&quot;</span>, Scope: GlobalScope, Index: <span class="dv">0</span>},</span>
<span id="cb352-6"><a href="#cb352-6"></a>        <span class="st">&quot;b&quot;</span>: Symbol{Name: <span class="st">&quot;b&quot;</span>, Scope: GlobalScope, Index: <span class="dv">1</span>},</span>
<span id="cb352-7"><a href="#cb352-7"></a>        <span class="st">&quot;c&quot;</span>: Symbol{Name: <span class="st">&quot;c&quot;</span>, Scope: LocalScope, Index: <span class="dv">0</span>},</span>
<span id="cb352-8"><a href="#cb352-8"></a>        <span class="st">&quot;d&quot;</span>: Symbol{Name: <span class="st">&quot;d&quot;</span>, Scope: LocalScope, Index: <span class="dv">1</span>},</span>
<span id="cb352-9"><a href="#cb352-9"></a>        <span class="st">&quot;e&quot;</span>: Symbol{Name: <span class="st">&quot;e&quot;</span>, Scope: LocalScope, Index: <span class="dv">0</span>},</span>
<span id="cb352-10"><a href="#cb352-10"></a>        <span class="st">&quot;f&quot;</span>: Symbol{Name: <span class="st">&quot;f&quot;</span>, Scope: LocalScope, Index: <span class="dv">1</span>},</span>
<span id="cb352-11"><a href="#cb352-11"></a>    }</span>
<span id="cb352-12"><a href="#cb352-12"></a></span>
<span id="cb352-13"><a href="#cb352-13"></a>    global := NewSymbolTable()</span>
<span id="cb352-14"><a href="#cb352-14"></a></span>
<span id="cb352-15"><a href="#cb352-15"></a>    a := global.Define(<span class="st">&quot;a&quot;</span>)</span>
<span id="cb352-16"><a href="#cb352-16"></a>    <span class="kw">if</span> a != expected[<span class="st">&quot;a&quot;</span>] {</span>
<span id="cb352-17"><a href="#cb352-17"></a>        t.Errorf(<span class="st">&quot;expected a=%+v, got=%+v&quot;</span>, expected[<span class="st">&quot;a&quot;</span>], a)</span>
<span id="cb352-18"><a href="#cb352-18"></a>    }</span>
<span id="cb352-19"><a href="#cb352-19"></a></span>
<span id="cb352-20"><a href="#cb352-20"></a>    b := global.Define(<span class="st">&quot;b&quot;</span>)</span>
<span id="cb352-21"><a href="#cb352-21"></a>    <span class="kw">if</span> b != expected[<span class="st">&quot;b&quot;</span>] {</span>
<span id="cb352-22"><a href="#cb352-22"></a>        t.Errorf(<span class="st">&quot;expected b=%+v, got=%+v&quot;</span>, expected[<span class="st">&quot;b&quot;</span>], b)</span>
<span id="cb352-23"><a href="#cb352-23"></a>    }</span>
<span id="cb352-24"><a href="#cb352-24"></a></span>
<span id="cb352-25"><a href="#cb352-25"></a>    firstLocal := NewEnclosedSymbolTable(global)</span>
<span id="cb352-26"><a href="#cb352-26"></a></span>
<span id="cb352-27"><a href="#cb352-27"></a>    c := firstLocal.Define(<span class="st">&quot;c&quot;</span>)</span>
<span id="cb352-28"><a href="#cb352-28"></a>    <span class="kw">if</span> c != expected[<span class="st">&quot;c&quot;</span>] {</span>
<span id="cb352-29"><a href="#cb352-29"></a>        t.Errorf(<span class="st">&quot;expected c=%+v, got=%+v&quot;</span>, expected[<span class="st">&quot;c&quot;</span>], c)</span>
<span id="cb352-30"><a href="#cb352-30"></a>    }</span>
<span id="cb352-31"><a href="#cb352-31"></a></span>
<span id="cb352-32"><a href="#cb352-32"></a>    d := firstLocal.Define(<span class="st">&quot;d&quot;</span>)</span>
<span id="cb352-33"><a href="#cb352-33"></a>    <span class="kw">if</span> d != expected[<span class="st">&quot;d&quot;</span>] {</span>
<span id="cb352-34"><a href="#cb352-34"></a>        t.Errorf(<span class="st">&quot;expected d=%+v, got=%+v&quot;</span>, expected[<span class="st">&quot;d&quot;</span>], d)</span>
<span id="cb352-35"><a href="#cb352-35"></a>    }</span>
<span id="cb352-36"><a href="#cb352-36"></a></span>
<span id="cb352-37"><a href="#cb352-37"></a>    secondLocal := NewEnclosedSymbolTable(firstLocal)</span>
<span id="cb352-38"><a href="#cb352-38"></a></span>
<span id="cb352-39"><a href="#cb352-39"></a>    e := secondLocal.Define(<span class="st">&quot;e&quot;</span>)</span>
<span id="cb352-40"><a href="#cb352-40"></a>    <span class="kw">if</span> e != expected[<span class="st">&quot;e&quot;</span>] {</span>
<span id="cb352-41"><a href="#cb352-41"></a>        t.Errorf(<span class="st">&quot;expected e=%+v, got=%+v&quot;</span>, expected[<span class="st">&quot;e&quot;</span>], e)</span>
<span id="cb352-42"><a href="#cb352-42"></a>    }</span>
<span id="cb352-43"><a href="#cb352-43"></a></span>
<span id="cb352-44"><a href="#cb352-44"></a>    f := secondLocal.Define(<span class="st">&quot;f&quot;</span>)</span>
<span id="cb352-45"><a href="#cb352-45"></a>    <span class="kw">if</span> f != expected[<span class="st">&quot;f&quot;</span>] {</span>
<span id="cb352-46"><a href="#cb352-46"></a>        t.Errorf(<span class="st">&quot;expected f=%+v, got=%+v&quot;</span>, expected[<span class="st">&quot;f&quot;</span>], f)</span>
<span id="cb352-47"><a href="#cb352-47"></a>    }</span>
<span id="cb352-48"><a href="#cb352-48"></a>}</span></code></pre></div>
<p>Okay, we know what we have to do. We need to make <code>Define</code> and <code>Resolve</code> work with enclosed symbol tables. The good thing is that they are two sides of the same implementation: a recursive definition of <code>SymbolTable</code> that allows us to enclose symbol tables within other symbol tables.</p>
<p>Our tests can’t give us feedback yet, because they won’t compile due to <code>NewEnclosedSymbolTable</code> and <code>LocalScope</code> being undefined. So, let’s get them running and start by giving <code>SymbolTable</code> an <code>Outer</code> field:</p>
<div class="sourceCode" id="cb353"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb353-1"><a href="#cb353-1"></a><span class="co">// compiler/symbol_table.go</span></span>
<span id="cb353-2"><a href="#cb353-2"></a></span>
<span id="cb353-3"><a href="#cb353-3"></a><span class="kw">type</span> SymbolTable <span class="kw">struct</span> {</span>
<span id="cb353-4"><a href="#cb353-4"></a>    Outer *SymbolTable</span>
<span id="cb353-5"><a href="#cb353-5"></a></span>
<span id="cb353-6"><a href="#cb353-6"></a>    store          <span class="kw">map</span>[<span class="dt">string</span>]Symbol</span>
<span id="cb353-7"><a href="#cb353-7"></a>    numDefinitions <span class="dt">int</span></span>
<span id="cb353-8"><a href="#cb353-8"></a>}</span></code></pre></div>
<p>That allows us to implement the <code>NewEnclosedSymbolTable</code> function that creates a <code>*SymbolTable</code> with an <code>Outer</code> symbol table:</p>
<div class="sourceCode" id="cb354"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb354-1"><a href="#cb354-1"></a><span class="co">// compiler/symbol_table.go</span></span>
<span id="cb354-2"><a href="#cb354-2"></a></span>
<span id="cb354-3"><a href="#cb354-3"></a><span class="kw">func</span> NewEnclosedSymbolTable(outer *SymbolTable) *SymbolTable {</span>
<span id="cb354-4"><a href="#cb354-4"></a>    s := NewSymbolTable()</span>
<span id="cb354-5"><a href="#cb354-5"></a>    s.Outer = outer</span>
<span id="cb354-6"><a href="#cb354-6"></a>    <span class="kw">return</span> s</span>
<span id="cb354-7"><a href="#cb354-7"></a>}</span></code></pre></div>
<p>We just got rid of one of the <code>undefined</code> errors when trying to compile the tests. In order to make the other one disappear, we have to define the <code>LocalScope</code> constant, right next to the existing <code>GlobalScope</code>:</p>
<div class="sourceCode" id="cb355"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb355-1"><a href="#cb355-1"></a><span class="co">// compiler/symbol_table.go</span></span>
<span id="cb355-2"><a href="#cb355-2"></a></span>
<span id="cb355-3"><a href="#cb355-3"></a><span class="kw">const</span> (</span>
<span id="cb355-4"><a href="#cb355-4"></a>    LocalScope  SymbolScope = <span class="st">&quot;LOCAL&quot;</span></span>
<span id="cb355-5"><a href="#cb355-5"></a>    GlobalScope SymbolScope = <span class="st">&quot;GLOBAL&quot;</span></span>
<span id="cb355-6"><a href="#cb355-6"></a>)</span></code></pre></div>
<p>Now we can finally get feedback from our three failing tests in <code>symbol_table_test.go</code>:</p>
<div class="sourceCode" id="cb356"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb356-1"><a href="#cb356-1"></a>$ go test ./compiler</span>
<span id="cb356-2"><a href="#cb356-2"></a>--- FAIL: TestLetStatementScopes (0.00s)</span>
<span id="cb356-3"><a href="#cb356-3"></a> compiler_test.go:935: testConstants failed:\</span>
<span id="cb356-4"><a href="#cb356-4"></a>   constant 1 - testInstructions failed: wrong instructions length.</span>
<span id="cb356-5"><a href="#cb356-5"></a>  want=&quot;0000 OpConstant 0\n0003 OpSetLocal 0\n0005 OpGetLocal 0\n\</span>
<span id="cb356-6"><a href="#cb356-6"></a>    0007 OpReturnValue\n&quot;</span>
<span id="cb356-7"><a href="#cb356-7"></a>  got =&quot;0000 OpConstant 0\n0003 OpSetGlobal 0\n0006 OpGetGlobal 0\n\</span>
<span id="cb356-8"><a href="#cb356-8"></a>    0009 OpReturnValue\n&quot;</span>
<span id="cb356-9"><a href="#cb356-9"></a></span>
<span id="cb356-10"><a href="#cb356-10"></a>--- FAIL: TestDefine (0.00s)</span>
<span id="cb356-11"><a href="#cb356-11"></a> symbol_table_test.go:31: expected c={Name:c Scope:LOCAL Index:0},\</span>
<span id="cb356-12"><a href="#cb356-12"></a>   got={Name:c Scope:GLOBAL Index:0}</span>
<span id="cb356-13"><a href="#cb356-13"></a> symbol_table_test.go:36: expected d={Name:d Scope:LOCAL Index:1},\</span>
<span id="cb356-14"><a href="#cb356-14"></a>   got={Name:d Scope:GLOBAL Index:1}</span>
<span id="cb356-15"><a href="#cb356-15"></a> symbol_table_test.go:43: expected e={Name:e Scope:LOCAL Index:0},\</span>
<span id="cb356-16"><a href="#cb356-16"></a>   got={Name:e Scope:GLOBAL Index:0}</span>
<span id="cb356-17"><a href="#cb356-17"></a> symbol_table_test.go:48: expected f={Name:f Scope:LOCAL Index:1},\</span>
<span id="cb356-18"><a href="#cb356-18"></a>   got={Name:f Scope:GLOBAL Index:1}</span>
<span id="cb356-19"><a href="#cb356-19"></a></span>
<span id="cb356-20"><a href="#cb356-20"></a>--- FAIL: TestResolveLocal (0.00s)</span>
<span id="cb356-21"><a href="#cb356-21"></a> symbol_table_test.go:94: name a not resolvable</span>
<span id="cb356-22"><a href="#cb356-22"></a> symbol_table_test.go:94: name b not resolvable</span>
<span id="cb356-23"><a href="#cb356-23"></a> symbol_table_test.go:98: expected c to resolve to\</span>
<span id="cb356-24"><a href="#cb356-24"></a>   {Name:c Scope:LOCAL Index:0}, got={Name:c Scope:GLOBAL Index:0}</span>
<span id="cb356-25"><a href="#cb356-25"></a> symbol_table_test.go:98: expected d to resolve to\</span>
<span id="cb356-26"><a href="#cb356-26"></a>   {Name:d Scope:LOCAL Index:1}, got={Name:d Scope:GLOBAL Index:1}</span>
<span id="cb356-27"><a href="#cb356-27"></a></span>
<span id="cb356-28"><a href="#cb356-28"></a>--- FAIL: TestResolveNestedLocal (0.00s)</span>
<span id="cb356-29"><a href="#cb356-29"></a> symbol_table_test.go:145: name a not resolvable</span>
<span id="cb356-30"><a href="#cb356-30"></a> symbol_table_test.go:145: name b not resolvable</span>
<span id="cb356-31"><a href="#cb356-31"></a> symbol_table_test.go:149: expected c to resolve to\</span>
<span id="cb356-32"><a href="#cb356-32"></a>   {Name:c Scope:LOCAL Index:0}, got={Name:c Scope:GLOBAL Index:0}</span>
<span id="cb356-33"><a href="#cb356-33"></a> symbol_table_test.go:149: expected d to resolve to\</span>
<span id="cb356-34"><a href="#cb356-34"></a>   {Name:d Scope:LOCAL Index:1}, got={Name:d Scope:GLOBAL Index:1}</span>
<span id="cb356-35"><a href="#cb356-35"></a> symbol_table_test.go:145: name a not resolvable</span>
<span id="cb356-36"><a href="#cb356-36"></a> symbol_table_test.go:145: name b not resolvable</span>
<span id="cb356-37"><a href="#cb356-37"></a> symbol_table_test.go:149: expected e to resolve to\</span>
<span id="cb356-38"><a href="#cb356-38"></a>   {Name:e Scope:LOCAL Index:0}, got={Name:e Scope:GLOBAL Index:0}</span>
<span id="cb356-39"><a href="#cb356-39"></a> symbol_table_test.go:149: expected f to resolve to\</span>
<span id="cb356-40"><a href="#cb356-40"></a>   {Name:f Scope:LOCAL Index:1}, got={Name:f Scope:GLOBAL Index:1}</span>
<span id="cb356-41"><a href="#cb356-41"></a>FAIL</span>
<span id="cb356-42"><a href="#cb356-42"></a>FAIL    monkey/compiler 0.008s</span></code></pre></div>
<p>Besides the three test functions concerning themselves with <code>SymbolTable</code>, there’s also <code>TestLetStatementScopes</code> failing and reminding us that we need to go back to our compiler once we’re done with extending <code>SymbolTable</code>. That won’t take too long – we can make all of the other tests pass with a tiny number of changes.</p>
<p>Now that we have the <code>Outer</code> field on <code>SymbolTable</code>, the <code>Resolve</code> and <code>Define</code> methods need to make use of it. We’ll start with <code>Define</code>. Here’s what it needs to do: if the <code>SymbolTable</code> being called is not enclosed in another <code>SymbolTable</code>, i.e. its <code>Outer</code> field is not set, then its scope is global. If it <em>is</em> enclosed, the scope is local. Every symbol defined in the symbol table should then have the correct scope. Translated into code the changes are barely worth mentioning:</p>
<div class="sourceCode" id="cb357"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb357-1"><a href="#cb357-1"></a><span class="co">// compiler/symbol_table.go</span></span>
<span id="cb357-2"><a href="#cb357-2"></a></span>
<span id="cb357-3"><a href="#cb357-3"></a><span class="kw">func</span> (s *SymbolTable) Define(name <span class="dt">string</span>) Symbol {</span>
<span id="cb357-4"><a href="#cb357-4"></a>    symbol := Symbol{Name: name, Index: s.numDefinitions}</span>
<span id="cb357-5"><a href="#cb357-5"></a>    <span class="kw">if</span> s.Outer == <span class="ot">nil</span> {</span>
<span id="cb357-6"><a href="#cb357-6"></a>        symbol.Scope = GlobalScope</span>
<span id="cb357-7"><a href="#cb357-7"></a>    } <span class="kw">else</span> {</span>
<span id="cb357-8"><a href="#cb357-8"></a>        symbol.Scope = LocalScope</span>
<span id="cb357-9"><a href="#cb357-9"></a>    }</span>
<span id="cb357-10"><a href="#cb357-10"></a></span>
<span id="cb357-11"><a href="#cb357-11"></a>    s.store[name] = symbol</span>
<span id="cb357-12"><a href="#cb357-12"></a>    s.numDefinitions++</span>
<span id="cb357-13"><a href="#cb357-13"></a>    <span class="kw">return</span> symbol</span>
<span id="cb357-14"><a href="#cb357-14"></a>}</span></code></pre></div>
<p>New is only the conditional which checks whether <code>s.Outer</code> is <code>nil</code>. If it is, we set the <code>Scope</code> on the symbol to <code>GlobalScope</code> and if it’s not, we set it to <code>LocalScope</code>.</p>
<p>That not only makes <code>TestDefine</code> pass, but a lot of the other test errors also disappear:</p>
<div class="sourceCode" id="cb358"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb358-1"><a href="#cb358-1"></a>$ go test ./compiler</span>
<span id="cb358-2"><a href="#cb358-2"></a>--- FAIL: TestLetStatementScopes (0.00s)</span>
<span id="cb358-3"><a href="#cb358-3"></a> compiler_test.go:935: testConstants failed:\</span>
<span id="cb358-4"><a href="#cb358-4"></a>   constant 1 - testInstructions failed: wrong instructions length.</span>
<span id="cb358-5"><a href="#cb358-5"></a>  want=&quot;0000 OpConstant 0\n0003 OpSetLocal 0\n0005 OpGetLocal 0\n\</span>
<span id="cb358-6"><a href="#cb358-6"></a>    0007 OpReturnValue\n&quot;</span>
<span id="cb358-7"><a href="#cb358-7"></a>  got =&quot;0000 OpConstant 0\n0003 OpSetGlobal 0\n0006 OpGetGlobal 0\n\</span>
<span id="cb358-8"><a href="#cb358-8"></a>    0009 OpReturnValue\n&quot;</span>
<span id="cb358-9"><a href="#cb358-9"></a>--- FAIL: TestResolveLocal (0.00s)</span>
<span id="cb358-10"><a href="#cb358-10"></a> symbol_table_test.go:94: name a not resolvable</span>
<span id="cb358-11"><a href="#cb358-11"></a> symbol_table_test.go:94: name b not resolvable</span>
<span id="cb358-12"><a href="#cb358-12"></a>--- FAIL: TestResolveNestedLocal (0.00s)</span>
<span id="cb358-13"><a href="#cb358-13"></a> symbol_table_test.go:145: name a not resolvable</span>
<span id="cb358-14"><a href="#cb358-14"></a> symbol_table_test.go:145: name b not resolvable</span>
<span id="cb358-15"><a href="#cb358-15"></a> symbol_table_test.go:145: name a not resolvable</span>
<span id="cb358-16"><a href="#cb358-16"></a> symbol_table_test.go:145: name b not resolvable</span>
<span id="cb358-17"><a href="#cb358-17"></a>FAIL</span>
<span id="cb358-18"><a href="#cb358-18"></a>FAIL    monkey/compiler 0.011s</span></code></pre></div>
<p>This tells us that we can now <code>Define</code> global and local bindings by enclosing a symbol table in another one. Perfect! But it’s also clear that we do not resolve symbols correctly yet.</p>
<p>The task of <code>Resolve</code> is now to either find symbols in the <code>SymbolTable</code> on which it’s called or – if it exists – in the <code>Outer</code> symbol table. And since symbol tables can be nested arbitrarily deep, <code>Resolve</code> can’t just access the outer symbol table’s <code>store</code> directly but needs to use that table’s <code>Resolve</code> method instead. That one, then, checks its own <code>store</code> and if it can’t find anything there, it needs to use its own outer table’s <code>Resolve</code> method, which again checks its <code>store</code> and i… You get the drift. Recursion.</p>
<p>We need to make <code>Resolve</code> recursive so that it climbs up the <code>Outer</code> symbol table until it either finds a symbol defined somewhere up the chain or tells the caller that it’s not defined:</p>
<div class="sourceCode" id="cb359"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb359-1"><a href="#cb359-1"></a><span class="co">// compiler/symbol_table.go</span></span>
<span id="cb359-2"><a href="#cb359-2"></a></span>
<span id="cb359-3"><a href="#cb359-3"></a><span class="kw">func</span> (s *SymbolTable) Resolve(name <span class="dt">string</span>) (Symbol, <span class="dt">bool</span>) {</span>
<span id="cb359-4"><a href="#cb359-4"></a>    obj, ok := s.store[name]</span>
<span id="cb359-5"><a href="#cb359-5"></a>    <span class="kw">if</span> !ok &amp;&amp; s.Outer != <span class="ot">nil</span> {</span>
<span id="cb359-6"><a href="#cb359-6"></a>        obj, ok = s.Outer.Resolve(name)</span>
<span id="cb359-7"><a href="#cb359-7"></a>        <span class="kw">return</span> obj, ok</span>
<span id="cb359-8"><a href="#cb359-8"></a>    }</span>
<span id="cb359-9"><a href="#cb359-9"></a>    <span class="kw">return</span> obj, ok</span>
<span id="cb359-10"><a href="#cb359-10"></a>}</span></code></pre></div>
<p>Three new lines that check whether the given symbol <code>name</code> can be recursively resolved in any of the <code>Outer</code> symbol tables. Three lines!</p>
<div class="sourceCode" id="cb360"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb360-1"><a href="#cb360-1"></a>$ go test ./compiler</span>
<span id="cb360-2"><a href="#cb360-2"></a>--- FAIL: TestLetStatementScopes (0.00s)</span>
<span id="cb360-3"><a href="#cb360-3"></a> compiler_test.go:935: testConstants failed:</span>
<span id="cb360-4"><a href="#cb360-4"></a>   constant 1 - testInstructions failed: wrong instructions length.</span>
<span id="cb360-5"><a href="#cb360-5"></a>  want=&quot;0000 OpConstant 0\n0003 OpSetLocal 0\n0005 OpGetLocal 0\n\</span>
<span id="cb360-6"><a href="#cb360-6"></a>    0007 OpReturnValue\n&quot;</span>
<span id="cb360-7"><a href="#cb360-7"></a>  got =&quot;0000 OpConstant 0\n0003 OpSetGlobal 0\n0006 OpGetGlobal 0\n\</span>
<span id="cb360-8"><a href="#cb360-8"></a>    0009 OpReturnValue\n&quot;</span>
<span id="cb360-9"><a href="#cb360-9"></a>FAIL</span>
<span id="cb360-10"><a href="#cb360-10"></a>FAIL    monkey/compiler 0.010s</span></code></pre></div>
<p>All that’s left is the failing compiler test, which means we successfully fixed all the tests for <code>SymbolTable</code>! Yes! We can now define and resolve symbols in the global and multiple nested local scopes!</p>
<p>But while that’s cause for celebration, I also know that you’re thinking ahead and probably wondering: “but if you define a symbol in a local scope and then resolve it in a deeper scope, the symbol has a local scope, even though it’s – from the perspective of the deepest scope – defined in an <em>outer</em> scope?” You’re on to something. We’ll get to that once we implement closures.</p>
<p>Right now, we still have a failing test to fix.</p>
<h4 id="compiling-with-scopes-1">Compiling With Scopes</h4>
<p>Our compiler already knows about scopes. Its <code>enterScope</code> and <code>leaveScope</code> methods are called when compiling a function literal and make sure that emitted instructions end up where they need to. We now need to extend them both so they also enclose and “un-enclose” symbol tables.</p>
<p>The existing <code>TestCompilerScopes</code> test function is the perfect place to test that:</p>
<div class="sourceCode" id="cb361"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb361-1"><a href="#cb361-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb361-2"><a href="#cb361-2"></a></span>
<span id="cb361-3"><a href="#cb361-3"></a><span class="kw">func</span> TestCompilerScopes(t *testing.T) {</span>
<span id="cb361-4"><a href="#cb361-4"></a>    compiler := New()</span>
<span id="cb361-5"><a href="#cb361-5"></a>    <span class="kw">if</span> compiler.scopeIndex != <span class="dv">0</span> {</span>
<span id="cb361-6"><a href="#cb361-6"></a>        t.Errorf(<span class="st">&quot;scopeIndex wrong. got=%d, want=%d&quot;</span>, compiler.scopeIndex, <span class="dv">0</span>)</span>
<span id="cb361-7"><a href="#cb361-7"></a>    }</span>
<span id="cb361-8"><a href="#cb361-8"></a>    globalSymbolTable := compiler.symbolTable</span>
<span id="cb361-9"><a href="#cb361-9"></a></span>
<span id="cb361-10"><a href="#cb361-10"></a>    compiler.emit(code.OpMul)</span>
<span id="cb361-11"><a href="#cb361-11"></a></span>
<span id="cb361-12"><a href="#cb361-12"></a>    compiler.enterScope()</span>
<span id="cb361-13"><a href="#cb361-13"></a>    <span class="kw">if</span> compiler.scopeIndex != <span class="dv">1</span> {</span>
<span id="cb361-14"><a href="#cb361-14"></a>        t.Errorf(<span class="st">&quot;scopeIndex wrong. got=%d, want=%d&quot;</span>, compiler.scopeIndex, <span class="dv">1</span>)</span>
<span id="cb361-15"><a href="#cb361-15"></a>    }</span>
<span id="cb361-16"><a href="#cb361-16"></a></span>
<span id="cb361-17"><a href="#cb361-17"></a>    compiler.emit(code.OpSub)</span>
<span id="cb361-18"><a href="#cb361-18"></a></span>
<span id="cb361-19"><a href="#cb361-19"></a>    <span class="kw">if</span> <span class="bu">len</span>(compiler.scopes[compiler.scopeIndex].instructions) != <span class="dv">1</span> {</span>
<span id="cb361-20"><a href="#cb361-20"></a>        t.Errorf(<span class="st">&quot;instructions length wrong. got=%d&quot;</span>,</span>
<span id="cb361-21"><a href="#cb361-21"></a>            <span class="bu">len</span>(compiler.scopes[compiler.scopeIndex].instructions))</span>
<span id="cb361-22"><a href="#cb361-22"></a>    }</span>
<span id="cb361-23"><a href="#cb361-23"></a></span>
<span id="cb361-24"><a href="#cb361-24"></a>    last := compiler.scopes[compiler.scopeIndex].lastInstruction</span>
<span id="cb361-25"><a href="#cb361-25"></a>    <span class="kw">if</span> last.Opcode != code.OpSub {</span>
<span id="cb361-26"><a href="#cb361-26"></a>        t.Errorf(<span class="st">&quot;lastInstruction.Opcode wrong. got=%d, want=%d&quot;</span>,</span>
<span id="cb361-27"><a href="#cb361-27"></a>            last.Opcode, code.OpSub)</span>
<span id="cb361-28"><a href="#cb361-28"></a>    }</span>
<span id="cb361-29"><a href="#cb361-29"></a></span>
<span id="cb361-30"><a href="#cb361-30"></a>    <span class="kw">if</span> compiler.symbolTable.Outer != globalSymbolTable {</span>
<span id="cb361-31"><a href="#cb361-31"></a>        t.Errorf(<span class="st">&quot;compiler did not enclose symbolTable&quot;</span>)</span>
<span id="cb361-32"><a href="#cb361-32"></a>    }</span>
<span id="cb361-33"><a href="#cb361-33"></a></span>
<span id="cb361-34"><a href="#cb361-34"></a>    compiler.leaveScope()</span>
<span id="cb361-35"><a href="#cb361-35"></a>    <span class="kw">if</span> compiler.scopeIndex != <span class="dv">0</span> {</span>
<span id="cb361-36"><a href="#cb361-36"></a>        t.Errorf(<span class="st">&quot;scopeIndex wrong. got=%d, want=%d&quot;</span>,</span>
<span id="cb361-37"><a href="#cb361-37"></a>            compiler.scopeIndex, <span class="dv">0</span>)</span>
<span id="cb361-38"><a href="#cb361-38"></a>    }</span>
<span id="cb361-39"><a href="#cb361-39"></a></span>
<span id="cb361-40"><a href="#cb361-40"></a>    <span class="kw">if</span> compiler.symbolTable != globalSymbolTable {</span>
<span id="cb361-41"><a href="#cb361-41"></a>        t.Errorf(<span class="st">&quot;compiler did not restore global symbol table&quot;</span>)</span>
<span id="cb361-42"><a href="#cb361-42"></a>    }</span>
<span id="cb361-43"><a href="#cb361-43"></a>    <span class="kw">if</span> compiler.symbolTable.Outer != <span class="ot">nil</span> {</span>
<span id="cb361-44"><a href="#cb361-44"></a>        t.Errorf(<span class="st">&quot;compiler modified global symbol table incorrectly&quot;</span>)</span>
<span id="cb361-45"><a href="#cb361-45"></a>    }</span>
<span id="cb361-46"><a href="#cb361-46"></a></span>
<span id="cb361-47"><a href="#cb361-47"></a>    compiler.emit(code.OpAdd)</span>
<span id="cb361-48"><a href="#cb361-48"></a></span>
<span id="cb361-49"><a href="#cb361-49"></a>    <span class="kw">if</span> <span class="bu">len</span>(compiler.scopes[compiler.scopeIndex].instructions) != <span class="dv">2</span> {</span>
<span id="cb361-50"><a href="#cb361-50"></a>        t.Errorf(<span class="st">&quot;instructions length wrong. got=%d&quot;</span>,</span>
<span id="cb361-51"><a href="#cb361-51"></a>            <span class="bu">len</span>(compiler.scopes[compiler.scopeIndex].instructions))</span>
<span id="cb361-52"><a href="#cb361-52"></a>    }</span>
<span id="cb361-53"><a href="#cb361-53"></a></span>
<span id="cb361-54"><a href="#cb361-54"></a>    last = compiler.scopes[compiler.scopeIndex].lastInstruction</span>
<span id="cb361-55"><a href="#cb361-55"></a>    <span class="kw">if</span> last.Opcode != code.OpAdd {</span>
<span id="cb361-56"><a href="#cb361-56"></a>        t.Errorf(<span class="st">&quot;lastInstruction.Opcode wrong. got=%d, want=%d&quot;</span>,</span>
<span id="cb361-57"><a href="#cb361-57"></a>            last.Opcode, code.OpAdd)</span>
<span id="cb361-58"><a href="#cb361-58"></a>    }</span>
<span id="cb361-59"><a href="#cb361-59"></a></span>
<span id="cb361-60"><a href="#cb361-60"></a>    previous := compiler.scopes[compiler.scopeIndex].previousInstruction</span>
<span id="cb361-61"><a href="#cb361-61"></a>    <span class="kw">if</span> previous.Opcode != code.OpMul {</span>
<span id="cb361-62"><a href="#cb361-62"></a>        t.Errorf(<span class="st">&quot;previousInstruction.Opcode wrong. got=%d, want=%d&quot;</span>,</span>
<span id="cb361-63"><a href="#cb361-63"></a>            previous.Opcode, code.OpMul)</span>
<span id="cb361-64"><a href="#cb361-64"></a>    }</span>
<span id="cb361-65"><a href="#cb361-65"></a>}</span></code></pre></div>
<p>Scattered among the existing assertions regarding the compiler’s <code>scopes</code> stack we now have new code that makes sure <code>enterScope</code> and <code>leaveScope</code> enclose and “un-enclose” the compiler’s <code>symbolTable</code> respectively. Testing that is as easy as checking whether the <code>Outer</code> field of the <code>symbolTable</code> is <code>nil</code> or not. And if it’s not, it should point to the <code>globalSymbolTable</code>.</p>
<div class="sourceCode" id="cb362"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb362-1"><a href="#cb362-1"></a>$ go test -run TestCompilerScopes ./compiler</span>
<span id="cb362-2"><a href="#cb362-2"></a>--- FAIL: TestCompilerScopes (0.00s)</span>
<span id="cb362-3"><a href="#cb362-3"></a> compiler_test.go:41: compiler did not enclose symbolTable</span>
<span id="cb362-4"><a href="#cb362-4"></a>FAIL</span>
<span id="cb362-5"><a href="#cb362-5"></a>FAIL    monkey/compiler 0.008s</span></code></pre></div>
<p>To make this test green, we need to enclose a symbol table in the global one every time we enter a scope:</p>
<div class="sourceCode" id="cb363"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb363-1"><a href="#cb363-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb363-2"><a href="#cb363-2"></a></span>
<span id="cb363-3"><a href="#cb363-3"></a><span class="kw">func</span> (c *Compiler) enterScope() {</span>
<span id="cb363-4"><a href="#cb363-4"></a>    <span class="co">// [...]</span></span>
<span id="cb363-5"><a href="#cb363-5"></a></span>
<span id="cb363-6"><a href="#cb363-6"></a>    c.symbolTable = NewEnclosedSymbolTable(c.symbolTable)</span>
<span id="cb363-7"><a href="#cb363-7"></a>}</span></code></pre></div>
<p>That makes the compiler use a fresh, enclosed symbol table when it compiles a function’s body. Exactly what we want, but we also need to undo it once the function is fully compiled:</p>
<div class="sourceCode" id="cb364"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb364-1"><a href="#cb364-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb364-2"><a href="#cb364-2"></a></span>
<span id="cb364-3"><a href="#cb364-3"></a><span class="kw">func</span> (c *Compiler) leaveScope() code.Instructions {</span>
<span id="cb364-4"><a href="#cb364-4"></a>    <span class="co">// [...]</span></span>
<span id="cb364-5"><a href="#cb364-5"></a></span>
<span id="cb364-6"><a href="#cb364-6"></a>    c.symbolTable = c.symbolTable.Outer</span>
<span id="cb364-7"><a href="#cb364-7"></a></span>
<span id="cb364-8"><a href="#cb364-8"></a>    <span class="kw">return</span> instructions</span>
<span id="cb364-9"><a href="#cb364-9"></a>}</span></code></pre></div>
<p>Again, it’s only one new line, but it’s enough to fix <em>this</em> test:</p>
<div class="sourceCode" id="cb365"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb365-1"><a href="#cb365-1"></a>$ go test -run TestCompilerScopes ./compiler</span>
<span id="cb365-2"><a href="#cb365-2"></a>ok      monkey/compiler 0.006s</span></code></pre></div>
<p>However, the test that’s been haunting us for a while now is still failing:</p>
<div class="sourceCode" id="cb366"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb366-1"><a href="#cb366-1"></a>$ go test ./compiler</span>
<span id="cb366-2"><a href="#cb366-2"></a>--- FAIL: TestLetStatementScopes (0.00s)</span>
<span id="cb366-3"><a href="#cb366-3"></a> compiler_test.go:947: testConstants failed:\</span>
<span id="cb366-4"><a href="#cb366-4"></a>   constant 1 - testInstructions failed: wrong instructions length.</span>
<span id="cb366-5"><a href="#cb366-5"></a>  want=&quot;0000 OpConstant 0\n0003 OpSetLocal 0\n0005 OpGetLocal 0\n\</span>
<span id="cb366-6"><a href="#cb366-6"></a>    0007 OpReturnValue\n&quot;</span>
<span id="cb366-7"><a href="#cb366-7"></a>  got =&quot;0000 OpConstant 0\n0003 OpSetGlobal 0\n0006 OpGetGlobal 0\n\</span>
<span id="cb366-8"><a href="#cb366-8"></a>    0009 OpReturnValue\n&quot;</span>
<span id="cb366-9"><a href="#cb366-9"></a>FAIL</span>
<span id="cb366-10"><a href="#cb366-10"></a>FAIL    monkey/compiler 0.009s</span></code></pre></div>
<p>But we’re finally ready to fix it. We have all the necessary parts in place and now we just need to use them and to finally listen to what our symbol table really has to say.</p>
<p>Up until now, we always emitted <code>OpSetGlobal</code> and <code>OpGetGlobal</code> instructions – no matter what the symbol table might say about the scope of a symbol. Granted, “might” is the important word here. Because even if we would have listened, the symbol table would’ve always replied with <code>GlobalScope</code>. That’s changed and we can now use a <code>Symbol</code>’s scope to emit the correct instructions.</p>
<p>The first place to do that is the <code>case</code> branch for <code>*ast.LetStatement</code>s:</p>
<div class="sourceCode" id="cb367"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb367-1"><a href="#cb367-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb367-2"><a href="#cb367-2"></a></span>
<span id="cb367-3"><a href="#cb367-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb367-4"><a href="#cb367-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb367-5"><a href="#cb367-5"></a>    <span class="co">// [...]</span></span>
<span id="cb367-6"><a href="#cb367-6"></a></span>
<span id="cb367-7"><a href="#cb367-7"></a>    <span class="kw">case</span> *ast.LetStatement:</span>
<span id="cb367-8"><a href="#cb367-8"></a>        err := c.Compile(node.Value)</span>
<span id="cb367-9"><a href="#cb367-9"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb367-10"><a href="#cb367-10"></a>            <span class="kw">return</span> err</span>
<span id="cb367-11"><a href="#cb367-11"></a>        }</span>
<span id="cb367-12"><a href="#cb367-12"></a></span>
<span id="cb367-13"><a href="#cb367-13"></a>        symbol := c.symbolTable.Define(node.Name.Value)</span>
<span id="cb367-14"><a href="#cb367-14"></a>        <span class="kw">if</span> symbol.Scope == GlobalScope {</span>
<span id="cb367-15"><a href="#cb367-15"></a>            c.emit(code.OpSetGlobal, symbol.Index)</span>
<span id="cb367-16"><a href="#cb367-16"></a>        } <span class="kw">else</span> {</span>
<span id="cb367-17"><a href="#cb367-17"></a>            c.emit(code.OpSetLocal, symbol.Index)</span>
<span id="cb367-18"><a href="#cb367-18"></a>        }</span>
<span id="cb367-19"><a href="#cb367-19"></a></span>
<span id="cb367-20"><a href="#cb367-20"></a>    <span class="co">// [...]</span></span>
<span id="cb367-21"><a href="#cb367-21"></a>    }</span>
<span id="cb367-22"><a href="#cb367-22"></a></span>
<span id="cb367-23"><a href="#cb367-23"></a>    <span class="co">// [...]</span></span>
<span id="cb367-24"><a href="#cb367-24"></a>}</span></code></pre></div>
<p>New is the check for the <code>symbol.Scope</code> and, depending on its outcome, the emitting of an <code>OpSetGlobal</code> or <code>OpSetLocal</code> instruction. As you can see, most of the work is done by the <code>SymbolTable</code> and we just listen to what it tells us:</p>
<div class="sourceCode" id="cb368"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb368-1"><a href="#cb368-1"></a>$ go test ./compiler</span>
<span id="cb368-2"><a href="#cb368-2"></a>--- FAIL: TestLetStatementScopes (0.00s)</span>
<span id="cb368-3"><a href="#cb368-3"></a> compiler_test.go:947: testConstants failed:\</span>
<span id="cb368-4"><a href="#cb368-4"></a>   constant 1 - testInstructions failed: wrong instructions length.</span>
<span id="cb368-5"><a href="#cb368-5"></a>  want=&quot;0000 OpConstant 0\n0003 OpSetLocal 0\n0005 OpGetLocal 0\n\</span>
<span id="cb368-6"><a href="#cb368-6"></a>    0007 OpReturnValue\n&quot;</span>
<span id="cb368-7"><a href="#cb368-7"></a>  got =&quot;0000 OpConstant 0\n0003 OpSetLocal 0\n0005 OpGetGlobal 0\n\</span>
<span id="cb368-8"><a href="#cb368-8"></a>    0008 OpReturnValue\n&quot;</span>
<span id="cb368-9"><a href="#cb368-9"></a>FAIL</span>
<span id="cb368-10"><a href="#cb368-10"></a>FAIL    monkey/compiler 0.007s</span></code></pre></div>
<p>Finally, the <code>OpSetLocal</code> instruction is there. The creation of local bindings is now being properly compiled. Now we need to do the same for the other side, the resolving of a name:</p>
<div class="sourceCode" id="cb369"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb369-1"><a href="#cb369-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb369-2"><a href="#cb369-2"></a></span>
<span id="cb369-3"><a href="#cb369-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb369-4"><a href="#cb369-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb369-5"><a href="#cb369-5"></a>    <span class="co">// [...]</span></span>
<span id="cb369-6"><a href="#cb369-6"></a></span>
<span id="cb369-7"><a href="#cb369-7"></a>    <span class="kw">case</span> *ast.Identifier:</span>
<span id="cb369-8"><a href="#cb369-8"></a>        symbol, ok := c.symbolTable.Resolve(node.Value)</span>
<span id="cb369-9"><a href="#cb369-9"></a>        <span class="kw">if</span> !ok {</span>
<span id="cb369-10"><a href="#cb369-10"></a>            <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;undefined variable %s&quot;</span>, node.Value)</span>
<span id="cb369-11"><a href="#cb369-11"></a>        }</span>
<span id="cb369-12"><a href="#cb369-12"></a></span>
<span id="cb369-13"><a href="#cb369-13"></a>        <span class="kw">if</span> symbol.Scope == GlobalScope {</span>
<span id="cb369-14"><a href="#cb369-14"></a>            c.emit(code.OpGetGlobal, symbol.Index)</span>
<span id="cb369-15"><a href="#cb369-15"></a>        } <span class="kw">else</span> {</span>
<span id="cb369-16"><a href="#cb369-16"></a>            c.emit(code.OpGetLocal, symbol.Index)</span>
<span id="cb369-17"><a href="#cb369-17"></a>        }</span>
<span id="cb369-18"><a href="#cb369-18"></a></span>
<span id="cb369-19"><a href="#cb369-19"></a>    <span class="co">// [...]</span></span>
<span id="cb369-20"><a href="#cb369-20"></a>    }</span>
<span id="cb369-21"><a href="#cb369-21"></a></span>
<span id="cb369-22"><a href="#cb369-22"></a>    <span class="co">// [...]</span></span>
<span id="cb369-23"><a href="#cb369-23"></a>}</span></code></pre></div>
<p>The only difference to the previous change is that here the opcodes are <code>OpGetGlobal</code> and <code>OpGetLocal</code>. And with that, the tests are passing – all of them:</p>
<div class="sourceCode" id="cb370"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb370-1"><a href="#cb370-1"></a>$ go test ./compiler</span>
<span id="cb370-2"><a href="#cb370-2"></a>ok      monkey/compiler 0.008s</span></code></pre></div>
<p>It’s time to move on over to the VM.</p>
<h3 id="implementing-local-bindings-in-the-vm">Implementing Local Bindings in the VM</h3>
<p>Now that the bytecode is able to represent the creation and resolution of local bindings with <code>OpSetLocal</code> and <code>OpGetLocal</code> instructions and the compiler knows how to emit them, the task at hand is clear: we need to implement local bindings in the VM.</p>
<p>That means we need to, first, create bindings when we execute <code>OpSetLocal</code> instructions and then, second, resolve those bindings when we execute <code>OpGetLocal</code> instructions. That’s similar to the implementation of global bindings, except that the storage must now be different – it must be <em>local</em>.</p>
<p>But while the storage of the local bindings is more than a mere implementation detail and can play a crucial role in the performance of a VM, it shouldn’t concern the user of the VM <em>where</em> and <em>how</em> they’re stored. The most important thing is that they work as expected, which is what this test describes:</p>
<div class="sourceCode" id="cb371"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb371-1"><a href="#cb371-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb371-2"><a href="#cb371-2"></a></span>
<span id="cb371-3"><a href="#cb371-3"></a><span class="kw">func</span> TestCallingFunctionsWithBindings(t *testing.T) {</span>
<span id="cb371-4"><a href="#cb371-4"></a>    tests := []vmTestCase{</span>
<span id="cb371-5"><a href="#cb371-5"></a>        {</span>
<span id="cb371-6"><a href="#cb371-6"></a>            input: <span class="st">`</span></span>
<span id="cb371-7"><a href="#cb371-7"></a><span class="st">        let one = fn() { let one = 1; one };</span></span>
<span id="cb371-8"><a href="#cb371-8"></a><span class="st">        one();</span></span>
<span id="cb371-9"><a href="#cb371-9"></a><span class="st">        `</span>,</span>
<span id="cb371-10"><a href="#cb371-10"></a>            expected: <span class="dv">1</span>,</span>
<span id="cb371-11"><a href="#cb371-11"></a>        },</span>
<span id="cb371-12"><a href="#cb371-12"></a>        {</span>
<span id="cb371-13"><a href="#cb371-13"></a>            input: <span class="st">`</span></span>
<span id="cb371-14"><a href="#cb371-14"></a><span class="st">        let oneAndTwo = fn() { let one = 1; let two = 2; one + two; };</span></span>
<span id="cb371-15"><a href="#cb371-15"></a><span class="st">        oneAndTwo();</span></span>
<span id="cb371-16"><a href="#cb371-16"></a><span class="st">        `</span>,</span>
<span id="cb371-17"><a href="#cb371-17"></a>            expected: <span class="dv">3</span>,</span>
<span id="cb371-18"><a href="#cb371-18"></a>        },</span>
<span id="cb371-19"><a href="#cb371-19"></a>        {</span>
<span id="cb371-20"><a href="#cb371-20"></a>            input: <span class="st">`</span></span>
<span id="cb371-21"><a href="#cb371-21"></a><span class="st">        let oneAndTwo = fn() { let one = 1; let two = 2; one + two; };</span></span>
<span id="cb371-22"><a href="#cb371-22"></a><span class="st">        let threeAndFour = fn() { let three = 3; let four = 4; three + four; };</span></span>
<span id="cb371-23"><a href="#cb371-23"></a><span class="st">        oneAndTwo() + threeAndFour();</span></span>
<span id="cb371-24"><a href="#cb371-24"></a><span class="st">        `</span>,</span>
<span id="cb371-25"><a href="#cb371-25"></a>            expected: <span class="dv">10</span>,</span>
<span id="cb371-26"><a href="#cb371-26"></a>        },</span>
<span id="cb371-27"><a href="#cb371-27"></a>        {</span>
<span id="cb371-28"><a href="#cb371-28"></a>            input: <span class="st">`</span></span>
<span id="cb371-29"><a href="#cb371-29"></a><span class="st">        let firstFoobar = fn() { let foobar = 50; foobar; };</span></span>
<span id="cb371-30"><a href="#cb371-30"></a><span class="st">        let secondFoobar = fn() { let foobar = 100; foobar; };</span></span>
<span id="cb371-31"><a href="#cb371-31"></a><span class="st">        firstFoobar() + secondFoobar();</span></span>
<span id="cb371-32"><a href="#cb371-32"></a><span class="st">        `</span>,</span>
<span id="cb371-33"><a href="#cb371-33"></a>            expected: <span class="dv">150</span>,</span>
<span id="cb371-34"><a href="#cb371-34"></a>        },</span>
<span id="cb371-35"><a href="#cb371-35"></a>        {</span>
<span id="cb371-36"><a href="#cb371-36"></a>            input: <span class="st">`</span></span>
<span id="cb371-37"><a href="#cb371-37"></a><span class="st">        let globalSeed = 50;</span></span>
<span id="cb371-38"><a href="#cb371-38"></a><span class="st">        let minusOne = fn() {</span></span>
<span id="cb371-39"><a href="#cb371-39"></a><span class="st">            let num = 1;</span></span>
<span id="cb371-40"><a href="#cb371-40"></a><span class="st">            globalSeed - num;</span></span>
<span id="cb371-41"><a href="#cb371-41"></a><span class="st">        }</span></span>
<span id="cb371-42"><a href="#cb371-42"></a><span class="st">        let minusTwo = fn() {</span></span>
<span id="cb371-43"><a href="#cb371-43"></a><span class="st">            let num = 2;</span></span>
<span id="cb371-44"><a href="#cb371-44"></a><span class="st">            globalSeed - num;</span></span>
<span id="cb371-45"><a href="#cb371-45"></a><span class="st">        }</span></span>
<span id="cb371-46"><a href="#cb371-46"></a><span class="st">        minusOne() + minusTwo();</span></span>
<span id="cb371-47"><a href="#cb371-47"></a><span class="st">        `</span>,</span>
<span id="cb371-48"><a href="#cb371-48"></a>            expected: <span class="dv">97</span>,</span>
<span id="cb371-49"><a href="#cb371-49"></a>        },</span>
<span id="cb371-50"><a href="#cb371-50"></a>    }</span>
<span id="cb371-51"><a href="#cb371-51"></a></span>
<span id="cb371-52"><a href="#cb371-52"></a>    runVmTests(t, tests)</span>
<span id="cb371-53"><a href="#cb371-53"></a>}</span></code></pre></div>
<p>All of these test cases assert that local bindings work, each one concentrating on a different aspect of the feature.</p>
<p>The first test case makes sure that local bindings work at all. The second one tests multiple local bindings in the same function. The third one tests multiple local bindings in different functions, while the fourth one does a slight variation of that by making sure that local bindings with the same name in different functions do not cause problems.</p>
<p>Take a look at the last test case, the one with <code>globalSeed</code> and <code>minusOne</code> – remember that? That’s our main goal for this section! That’s what we set out to compile and to execute. But, alas, the test output confirms that we’ve done the compilation part but not much execution:</p>
<div class="sourceCode" id="cb372"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb372-1"><a href="#cb372-1"></a>$ go test ./vm</span>
<span id="cb372-2"><a href="#cb372-2"></a>--- FAIL: TestCallingFunctionsWithBindings (0.00s)</span>
<span id="cb372-3"><a href="#cb372-3"></a>panic: runtime error: index out of range [recovered]</span>
<span id="cb372-4"><a href="#cb372-4"></a> panic: runtime error: index out of range</span>
<span id="cb372-5"><a href="#cb372-5"></a></span>
<span id="cb372-6"><a href="#cb372-6"></a>goroutine 37 [running]:</span>
<span id="cb372-7"><a href="#cb372-7"></a>testing.tRunner.func1(0xc4204e60f0)</span>
<span id="cb372-8"><a href="#cb372-8"></a> /usr/local/go/src/testing/testing.go:742 +0x29d</span>
<span id="cb372-9"><a href="#cb372-9"></a>panic(0x11211a0, 0x11fffe0)</span>
<span id="cb372-10"><a href="#cb372-10"></a> /usr/local/go/src/runtime/panic.go:502 +0x229</span>
<span id="cb372-11"><a href="#cb372-11"></a>monkey/vm.(*VM).Run(0xc420527e58, 0x10000, 0x10000)</span>
<span id="cb372-12"><a href="#cb372-12"></a> /Users/mrnugget/code/07/src/monkey/vm/vm.go:78 +0xb54</span>
<span id="cb372-13"><a href="#cb372-13"></a>monkey/vm.runVmTests(0xc4204e60f0, 0xc420527ef8, 0x5, 0x5)</span>
<span id="cb372-14"><a href="#cb372-14"></a> /Users/mrnugget/code/07/src/monkey/vm/vm_test.go:266 +0x5d6</span>
<span id="cb372-15"><a href="#cb372-15"></a>monkey/vm.TestCallingFunctionsWithBindings(0xc4204e60f0)</span>
<span id="cb372-16"><a href="#cb372-16"></a> /Users/mrnugget/code/07/src/monkey/vm/vm_test.go:326 +0xe3</span>
<span id="cb372-17"><a href="#cb372-17"></a>testing.tRunner(0xc4204e60f0, 0x1153b68)</span>
<span id="cb372-18"><a href="#cb372-18"></a> /usr/local/go/src/testing/testing.go:777 +0xd0</span>
<span id="cb372-19"><a href="#cb372-19"></a>created by testing.(*T).Run</span>
<span id="cb372-20"><a href="#cb372-20"></a> /usr/local/go/src/testing/testing.go:824 +0x2e0</span>
<span id="cb372-21"><a href="#cb372-21"></a>FAIL    monkey/vm   0.041s</span></code></pre></div>
<p>Let’s think this through. How do we implement local bindings? We know that local bindings come with a unique index, just like their global counterparts. So, here too, we can use the operand of an <code>OpSetLocal</code> instruction, the unique index, as an index into a data structure to store and retrieve the value being bound to a name.</p>
<p>The question is: index into which data structure? And where is this data structure located? We can’t just use the <code>globals</code> slice stored on the <code>VM</code>, since that would defy having local bindings in the first place. We need something different.</p>
<p>There are two main options. The first one is to dynamically allocate the local bindings and store them in their own data structure. That could be a slice, for example. Whenever a function is called an empty slice would then be allocated and used to store and retrieve locals. Then there’s the second option: reusing what we already have. Because we do have a place in memory where we store data that’s relevant to the current function being called. It’s called the stack.</p>
<p>Now, storing locals on the stack is the elaborate choice, but lots of fun to implement. It can also teach us a great deal and not just about our VM and compiler, but about computers and low-level programming in general, where using the stack like this is common practice. That’s why we’re choosing this, even though we normally opt for the easiest option, because this time, the increased effort is worth it.</p>
<p>Here’s how it works. When we come across an <code>OpCall</code> instruction in the VM and are about to execute the function on the stack, we take the current value of the stack pointer and put it aside – for later use. We then increase the stack pointer by the number of locals used by the function we’re about to execute. The result is a “hole” on the stack: we’ve increased the stack pointer without pushing any values, creating a region on the stack without any values. Below the hole: all the values previously pushed on to the stack, before the function call. And above the hole is the function’s workspace, where it will push and pop the values it needs to do its work.</p>
<p>The hole itself is where we’re going to store local bindings. We won’t use the unique index of a local binding as a key for another data structure, but instead as an index into the hole on the stack.</p>
<!-- ./ascii_drawings/07/stack_function_locals.monopic -->
<figure>
<img src="./images/07/stack_function_locals.svg" style="width:65.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>We already have the necessary parts to pull this off: the value of the stack pointer before executing the function, giving us the lower boundary of the hole, and an index that increases with every local. We can use both to calculate a stack slot index for each local binding by adding them together. Every index calculated this way serves as an offset into the hole and points to the slot where we’ll store the local binding.</p>
<p>The beauty of this approach is what happens when we’re done executing a function. Since we put the previous value of the stack pointer aside, we can now simply restore it and thus “reset” the stack. That removes not only everything the function call may have left on the stack, but also the local bindings saved in the hole – everything is squeaky-clean again!</p>
<p>“That’s all fine and good”, you say, “but how do we know how many locals a function is going to use?” Good catch; you got me. It’s true, we <em>don’t</em> know. At least not in the VM. In the compiler, on the other hand, we do and it’s rather trivial for us to pass this information on to the VM.</p>
<p>What we need to do first is to extend our <code>object.CompiledFunction</code> by one field:</p>
<div class="sourceCode" id="cb373"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb373-1"><a href="#cb373-1"></a><span class="co">// object/object.go</span></span>
<span id="cb373-2"><a href="#cb373-2"></a></span>
<span id="cb373-3"><a href="#cb373-3"></a><span class="kw">type</span> CompiledFunction <span class="kw">struct</span> {</span>
<span id="cb373-4"><a href="#cb373-4"></a>    Instructions code.Instructions</span>
<span id="cb373-5"><a href="#cb373-5"></a>    NumLocals    <span class="dt">int</span></span>
<span id="cb373-6"><a href="#cb373-6"></a>}</span></code></pre></div>
<p><code>NumLocals</code> will later on tell us how many local bindings this function is going to create. In the compiler we can now ask the symbol table how many symbols were defined while compiling a function and put that number into <code>NumLocals</code>:</p>
<div class="sourceCode" id="cb374"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb374-1"><a href="#cb374-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb374-2"><a href="#cb374-2"></a></span>
<span id="cb374-3"><a href="#cb374-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb374-4"><a href="#cb374-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb374-5"><a href="#cb374-5"></a>    <span class="co">// [...]</span></span>
<span id="cb374-6"><a href="#cb374-6"></a></span>
<span id="cb374-7"><a href="#cb374-7"></a>    <span class="kw">case</span> *ast.FunctionLiteral:</span>
<span id="cb374-8"><a href="#cb374-8"></a>        <span class="co">// [...]</span></span>
<span id="cb374-9"><a href="#cb374-9"></a></span>
<span id="cb374-10"><a href="#cb374-10"></a>        numLocals := c.symbolTable.numDefinitions</span>
<span id="cb374-11"><a href="#cb374-11"></a>        instructions := c.leaveScope()</span>
<span id="cb374-12"><a href="#cb374-12"></a></span>
<span id="cb374-13"><a href="#cb374-13"></a>        compiledFn := &amp;object.CompiledFunction{</span>
<span id="cb374-14"><a href="#cb374-14"></a>            Instructions: instructions,</span>
<span id="cb374-15"><a href="#cb374-15"></a>            NumLocals:    numLocals,</span>
<span id="cb374-16"><a href="#cb374-16"></a>        }</span>
<span id="cb374-17"><a href="#cb374-17"></a>        c.emit(code.OpConstant, c.addConstant(compiledFn))</span>
<span id="cb374-18"><a href="#cb374-18"></a></span>
<span id="cb374-19"><a href="#cb374-19"></a>    <span class="co">// [...]</span></span>
<span id="cb374-20"><a href="#cb374-20"></a>    }</span>
<span id="cb374-21"><a href="#cb374-21"></a></span>
<span id="cb374-22"><a href="#cb374-22"></a>    <span class="co">// [...]</span></span>
<span id="cb374-23"><a href="#cb374-23"></a>}</span></code></pre></div>
<p>Right before we call <code>c.leaveScope</code>, we take the current symbol table’s <code>numDefinitions</code>, put it aside and, after leaving the scope, save it to the <code>*object.CompiledFunction</code>. That gives us the number of local bindings a function is going to create and use in the VM. First mini-challenge completed! Sweet!</p>
<p>Now, according to our plan the other thing we need to do is to keep track of the stack pointer’s value <em>before</em> we execute a function and then restore it to this value <em>after</em> executing. So in other words, we need a temporary storage that lives as long as a function call. Guess what? We already have that and call it <code>Frame</code>. We only need to add one more field to it, the so called <code>basePointer</code>:</p>
<div class="sourceCode" id="cb375"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb375-1"><a href="#cb375-1"></a><span class="co">// vm/frame.go</span></span>
<span id="cb375-2"><a href="#cb375-2"></a></span>
<span id="cb375-3"><a href="#cb375-3"></a><span class="kw">type</span> Frame <span class="kw">struct</span> {</span>
<span id="cb375-4"><a href="#cb375-4"></a>    fn          *object.CompiledFunction</span>
<span id="cb375-5"><a href="#cb375-5"></a>    ip          <span class="dt">int</span></span>
<span id="cb375-6"><a href="#cb375-6"></a>    basePointer <span class="dt">int</span></span>
<span id="cb375-7"><a href="#cb375-7"></a>}</span>
<span id="cb375-8"><a href="#cb375-8"></a></span>
<span id="cb375-9"><a href="#cb375-9"></a><span class="kw">func</span> NewFrame(fn *object.CompiledFunction, basePointer <span class="dt">int</span>) *Frame {</span>
<span id="cb375-10"><a href="#cb375-10"></a>    f := &amp;Frame{</span>
<span id="cb375-11"><a href="#cb375-11"></a>        fn:          fn,</span>
<span id="cb375-12"><a href="#cb375-12"></a>        ip:          <span class="dv">-1</span>,</span>
<span id="cb375-13"><a href="#cb375-13"></a>        basePointer: basePointer,</span>
<span id="cb375-14"><a href="#cb375-14"></a>    }</span>
<span id="cb375-15"><a href="#cb375-15"></a></span>
<span id="cb375-16"><a href="#cb375-16"></a>    <span class="kw">return</span> f</span>
<span id="cb375-17"><a href="#cb375-17"></a>}</span></code></pre></div>
<p>The name “base pointer” is not something I made up. On the contrary, it’s common practice to give this name to the pointer that points to the bottom of the stack of the current call frame. It’s the <em>base</em> for a lot of references while executing a function. Sometimes it’s also called “frame pointer”. In the upcoming sections of this book we’ll use it even more. Right now, we just need to initialize it before we push a new frame:</p>
<div class="sourceCode" id="cb376"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb376-1"><a href="#cb376-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb376-2"><a href="#cb376-2"></a></span>
<span id="cb376-3"><a href="#cb376-3"></a><span class="kw">func</span> New(bytecode *compiler.Bytecode) *VM {</span>
<span id="cb376-4"><a href="#cb376-4"></a>    <span class="co">// [...]</span></span>
<span id="cb376-5"><a href="#cb376-5"></a></span>
<span id="cb376-6"><a href="#cb376-6"></a>    mainFrame := NewFrame(mainFn, <span class="dv">0</span>)</span>
<span id="cb376-7"><a href="#cb376-7"></a></span>
<span id="cb376-8"><a href="#cb376-8"></a>    <span class="co">// [...]</span></span>
<span id="cb376-9"><a href="#cb376-9"></a>}</span>
<span id="cb376-10"><a href="#cb376-10"></a></span>
<span id="cb376-11"><a href="#cb376-11"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb376-12"><a href="#cb376-12"></a>    <span class="co">// [...]</span></span>
<span id="cb376-13"><a href="#cb376-13"></a>        <span class="kw">switch</span> op {</span>
<span id="cb376-14"><a href="#cb376-14"></a>        <span class="co">// [...]</span></span>
<span id="cb376-15"><a href="#cb376-15"></a></span>
<span id="cb376-16"><a href="#cb376-16"></a>        <span class="kw">case</span> code.OpCall:</span>
<span id="cb376-17"><a href="#cb376-17"></a>            fn, ok := vm.stack[vm.sp<span class="dv">-1</span>].(*object.CompiledFunction)</span>
<span id="cb376-18"><a href="#cb376-18"></a>            <span class="kw">if</span> !ok {</span>
<span id="cb376-19"><a href="#cb376-19"></a>                <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;calling non-function&quot;</span>)</span>
<span id="cb376-20"><a href="#cb376-20"></a>            }</span>
<span id="cb376-21"><a href="#cb376-21"></a>            frame := NewFrame(fn, vm.sp)</span>
<span id="cb376-22"><a href="#cb376-22"></a>            vm.pushFrame(frame)</span>
<span id="cb376-23"><a href="#cb376-23"></a></span>
<span id="cb376-24"><a href="#cb376-24"></a>        <span class="co">// [...]</span></span>
<span id="cb376-25"><a href="#cb376-25"></a>        }</span>
<span id="cb376-26"><a href="#cb376-26"></a>    <span class="co">// [...]</span></span>
<span id="cb376-27"><a href="#cb376-27"></a>}</span></code></pre></div>
<p>In the <code>vm.New</code> function we pass in <code>0</code> as the current value of the stack pointer so we can make our <code>mainFrame</code> work properly, even though this particular frame should never be popped off the stack and doesn’t have local bindings. The setup of the new frame in the <code>case code.OpCall</code> branch is what we’re really after. New is the second argument in the call to <code>NewFrame</code>, the current value of <code>vm.sp</code>, which will serve as the <code>basePointer</code> for the new frame.</p>
<p>Alright! We now have a <code>basePointer</code> in place and we know how many locals a function is going to use. That leaves us with two tasks: Allocate space for the local bindings on the stack before executing a function. Meaning: creating the “hole”. And we also need to implement <code>OpSetLocal</code> and <code>OpGetLocal</code> instructions in the VM to use it.</p>
<p>“Allocating space on the stack” sounds fancy, but comes down to increasing the value of <code>vm.sp</code> without pushing something. And since we already save its value to the side before executing a function, we already have a perfect place, where we can do that:</p>
<div class="sourceCode" id="cb377"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb377-1"><a href="#cb377-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb377-2"><a href="#cb377-2"></a></span>
<span id="cb377-3"><a href="#cb377-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb377-4"><a href="#cb377-4"></a>    <span class="co">// [...]</span></span>
<span id="cb377-5"><a href="#cb377-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb377-6"><a href="#cb377-6"></a>        <span class="co">// [...]</span></span>
<span id="cb377-7"><a href="#cb377-7"></a></span>
<span id="cb377-8"><a href="#cb377-8"></a>        <span class="kw">case</span> code.OpCall:</span>
<span id="cb377-9"><a href="#cb377-9"></a>            fn, ok := vm.stack[vm.sp<span class="dv">-1</span>].(*object.CompiledFunction)</span>
<span id="cb377-10"><a href="#cb377-10"></a>            <span class="kw">if</span> !ok {</span>
<span id="cb377-11"><a href="#cb377-11"></a>                <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;calling non-function&quot;</span>)</span>
<span id="cb377-12"><a href="#cb377-12"></a>            }</span>
<span id="cb377-13"><a href="#cb377-13"></a>            frame := NewFrame(fn, vm.sp)</span>
<span id="cb377-14"><a href="#cb377-14"></a>            vm.pushFrame(frame)</span>
<span id="cb377-15"><a href="#cb377-15"></a>            vm.sp = frame.basePointer + fn.NumLocals</span>
<span id="cb377-16"><a href="#cb377-16"></a></span>
<span id="cb377-17"><a href="#cb377-17"></a>        <span class="co">// [...]</span></span>
<span id="cb377-18"><a href="#cb377-18"></a>        }</span>
<span id="cb377-19"><a href="#cb377-19"></a>    <span class="co">// [...]</span></span>
<span id="cb377-20"><a href="#cb377-20"></a>}</span></code></pre></div>
<p>We set <code>vm.sp</code> to <code>frame.basePointer + fn.NumLocals</code> to make clear that the starting point is <code>basePointer</code> and that we reserve <code>fn.NumLocals</code> slots on the stack. These slots might contain no or old values and in either case, we don’t care. We can now use this region of the stack for local bindings and the normal usage of the stack – the pushing and popping of temporary values – won’t affect it.</p>
<p>Next up: implement <code>OpSetLocal</code> and <code>OpGetLocal</code> instructions in our VM. We’ll start with <code>OpSetLocal</code>.</p>
<p>What we have to do is very similar to what we did for global bindings: read in the operand, pop the value that should be bound off the stack and store it.</p>
<div class="sourceCode" id="cb378"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb378-1"><a href="#cb378-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb378-2"><a href="#cb378-2"></a></span>
<span id="cb378-3"><a href="#cb378-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb378-4"><a href="#cb378-4"></a>    <span class="co">// [...]</span></span>
<span id="cb378-5"><a href="#cb378-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb378-6"><a href="#cb378-6"></a>        <span class="co">// [...]</span></span>
<span id="cb378-7"><a href="#cb378-7"></a></span>
<span id="cb378-8"><a href="#cb378-8"></a>        <span class="kw">case</span> code.OpSetLocal:</span>
<span id="cb378-9"><a href="#cb378-9"></a>            localIndex := code.ReadUint8(ins[ip+<span class="dv">1</span>:])</span>
<span id="cb378-10"><a href="#cb378-10"></a>            vm.currentFrame().ip += <span class="dv">1</span></span>
<span id="cb378-11"><a href="#cb378-11"></a></span>
<span id="cb378-12"><a href="#cb378-12"></a>            frame := vm.currentFrame()</span>
<span id="cb378-13"><a href="#cb378-13"></a></span>
<span id="cb378-14"><a href="#cb378-14"></a>            vm.stack[frame.basePointer+<span class="dt">int</span>(localIndex)] = vm.pop()</span>
<span id="cb378-15"><a href="#cb378-15"></a></span>
<span id="cb378-16"><a href="#cb378-16"></a>        <span class="co">// [...]</span></span>
<span id="cb378-17"><a href="#cb378-17"></a>        }</span>
<span id="cb378-18"><a href="#cb378-18"></a>    <span class="co">// [...]</span></span>
<span id="cb378-19"><a href="#cb378-19"></a>}</span></code></pre></div>
<p>After decoding the operand and getting the current frame, we take the <code>basePointer</code> of the frame and add the index of the binding in question as an offset. The result is the index of the location on the stack to which we can save the binding. We then pop the value off the stack and save it to the computed location. Done. Local binding created.</p>
<p>Implementing <code>OpGetLocal</code> means doing the opposite. Instead of assigning a value, we retrieve it. The rest is exactly the same:</p>
<div class="sourceCode" id="cb379"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb379-1"><a href="#cb379-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb379-2"><a href="#cb379-2"></a></span>
<span id="cb379-3"><a href="#cb379-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb379-4"><a href="#cb379-4"></a>    <span class="co">// [...]</span></span>
<span id="cb379-5"><a href="#cb379-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb379-6"><a href="#cb379-6"></a>        <span class="co">// [...]</span></span>
<span id="cb379-7"><a href="#cb379-7"></a></span>
<span id="cb379-8"><a href="#cb379-8"></a>        <span class="kw">case</span> code.OpGetLocal:</span>
<span id="cb379-9"><a href="#cb379-9"></a>            localIndex := code.ReadUint8(ins[ip+<span class="dv">1</span>:])</span>
<span id="cb379-10"><a href="#cb379-10"></a>            vm.currentFrame().ip += <span class="dv">1</span></span>
<span id="cb379-11"><a href="#cb379-11"></a></span>
<span id="cb379-12"><a href="#cb379-12"></a>            frame := vm.currentFrame()</span>
<span id="cb379-13"><a href="#cb379-13"></a></span>
<span id="cb379-14"><a href="#cb379-14"></a>            err := vm.push(vm.stack[frame.basePointer+<span class="dt">int</span>(localIndex)])</span>
<span id="cb379-15"><a href="#cb379-15"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb379-16"><a href="#cb379-16"></a>                <span class="kw">return</span> err</span>
<span id="cb379-17"><a href="#cb379-17"></a>            }</span>
<span id="cb379-18"><a href="#cb379-18"></a></span>
<span id="cb379-19"><a href="#cb379-19"></a>        <span class="co">// [...]</span></span>
<span id="cb379-20"><a href="#cb379-20"></a>        }</span>
<span id="cb379-21"><a href="#cb379-21"></a>    <span class="co">// [...]</span></span>
<span id="cb379-22"><a href="#cb379-22"></a>}</span></code></pre></div>
<p>Done! Let’s see what our tests have to say:</p>
<div class="sourceCode" id="cb380"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb380-1"><a href="#cb380-1"></a>$ go test ./vm</span>
<span id="cb380-2"><a href="#cb380-2"></a>--- FAIL: TestCallingFunctionsWithBindings (0.00s)</span>
<span id="cb380-3"><a href="#cb380-3"></a>  vm_test.go:444: vm error: unsupported types for binary operation:\</span>
<span id="cb380-4"><a href="#cb380-4"></a>    COMPILED_FUNCTION_OBJ INTEGER</span>
<span id="cb380-5"><a href="#cb380-5"></a>FAIL</span>
<span id="cb380-6"><a href="#cb380-6"></a>FAIL    monkey/vm       0.031s</span></code></pre></div>
<p>What? In none of our test cases do we try to add a function to an integer. That would only happen if we leave functions lying around on the sta- Aha! We forgot to clean up the stack! We have the <code>basePointer</code> in place but we don’t use it to reset our <code>vm.sp</code> after we’re done executing a function.</p>
<p>We know where to do that, though: when we come across an <code>OpReturnValue</code> or an <code>OpReturn</code> instruction. Currently, we only take the return value and the just executed function off the stack. Now we need to get rid of the local bindings, too. The easiest way to do that is to set the stack pointer to the <code>basePointer</code> of the frame that holds the just-executed function:</p>
<div class="sourceCode" id="cb381"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb381-1"><a href="#cb381-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb381-2"><a href="#cb381-2"></a></span>
<span id="cb381-3"><a href="#cb381-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb381-4"><a href="#cb381-4"></a>    <span class="co">// [...]</span></span>
<span id="cb381-5"><a href="#cb381-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb381-6"><a href="#cb381-6"></a>        <span class="co">// [...]</span></span>
<span id="cb381-7"><a href="#cb381-7"></a></span>
<span id="cb381-8"><a href="#cb381-8"></a>        <span class="kw">case</span> code.OpReturnValue:</span>
<span id="cb381-9"><a href="#cb381-9"></a>            returnValue := vm.pop()</span>
<span id="cb381-10"><a href="#cb381-10"></a></span>
<span id="cb381-11"><a href="#cb381-11"></a>            frame := vm.popFrame()</span>
<span id="cb381-12"><a href="#cb381-12"></a>            vm.sp = frame.basePointer - <span class="dv">1</span></span>
<span id="cb381-13"><a href="#cb381-13"></a></span>
<span id="cb381-14"><a href="#cb381-14"></a>            err := vm.push(returnValue)</span>
<span id="cb381-15"><a href="#cb381-15"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb381-16"><a href="#cb381-16"></a>                <span class="kw">return</span> err</span>
<span id="cb381-17"><a href="#cb381-17"></a>            }</span>
<span id="cb381-18"><a href="#cb381-18"></a></span>
<span id="cb381-19"><a href="#cb381-19"></a>        <span class="kw">case</span> code.OpReturn:</span>
<span id="cb381-20"><a href="#cb381-20"></a>            frame := vm.popFrame()</span>
<span id="cb381-21"><a href="#cb381-21"></a>            vm.sp = frame.basePointer - <span class="dv">1</span></span>
<span id="cb381-22"><a href="#cb381-22"></a></span>
<span id="cb381-23"><a href="#cb381-23"></a>            err := vm.push(Null)</span>
<span id="cb381-24"><a href="#cb381-24"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb381-25"><a href="#cb381-25"></a>                <span class="kw">return</span> err</span>
<span id="cb381-26"><a href="#cb381-26"></a>            }</span>
<span id="cb381-27"><a href="#cb381-27"></a></span>
<span id="cb381-28"><a href="#cb381-28"></a>        <span class="co">// [...]</span></span>
<span id="cb381-29"><a href="#cb381-29"></a>        }</span>
<span id="cb381-30"><a href="#cb381-30"></a>    <span class="co">// [...]</span></span>
<span id="cb381-31"><a href="#cb381-31"></a>}</span></code></pre></div>
<p>When we return from a function we first pop the frame off the frame stack. Previously we also did that, but didn’t save the popped <code>frame</code>. Now we also set <code>vm.sp</code> to <code>frame.basePointer - 1</code>. Where does the additional <code>-1</code> come from? It’s an optimization: setting <code>vm.sp</code> to <code>frame.basePointer</code> would get rid of the local bindings, but it would still leave the just-executed function on the stack. So instead of keeping around the <code>vm.pop()</code> we previously had in place there, we replace it by decrementing <code>vm.sp</code> even further.</p>
<p>And with that, we’re done. Yes, really. We’re at the end of a journey that began with the definition of the <code>OpSetLocal</code> and <code>OpGetLocal</code> opcodes, led us from the compiler tests through the symbol table back to the compiler and finally, with a little detour back to <code>object.CompiledFunction</code>, landed us in the VM. Local bindings work:</p>
<div class="sourceCode" id="cb382"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb382-1"><a href="#cb382-1"></a>$ go test ./vm</span>
<span id="cb382-2"><a href="#cb382-2"></a>ok      monkey/vm   0.039s</span></code></pre></div>
<p>We can now compile and execute this piece of Monkey code:</p>
<div class="sourceCode" id="cb383"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb383-1"><a href="#cb383-1"></a><span class="kw">let</span> globalSeed <span class="op">=</span> <span class="dv">50</span><span class="op">;</span></span>
<span id="cb383-2"><a href="#cb383-2"></a><span class="kw">let</span> minusOne <span class="op">=</span> fn() {</span>
<span id="cb383-3"><a href="#cb383-3"></a>  <span class="kw">let</span> num <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb383-4"><a href="#cb383-4"></a>  globalSeed <span class="op">-</span> num<span class="op">;</span></span>
<span id="cb383-5"><a href="#cb383-5"></a>}</span>
<span id="cb383-6"><a href="#cb383-6"></a><span class="kw">let</span> minusTwo <span class="op">=</span> fn() {</span>
<span id="cb383-7"><a href="#cb383-7"></a>  <span class="kw">let</span> num <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb383-8"><a href="#cb383-8"></a>  globalSeed <span class="op">-</span> num<span class="op">;</span></span>
<span id="cb383-9"><a href="#cb383-9"></a>}</span>
<span id="cb383-10"><a href="#cb383-10"></a>minusOne() <span class="op">+</span> minusOne()</span></code></pre></div>
<p>And there’s more. We got an upgrade to our first-class functions without, again, explicitly setting out to do so. We can now take functions and assign them to names – in other functions:</p>
<div class="sourceCode" id="cb384"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb384-1"><a href="#cb384-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb384-2"><a href="#cb384-2"></a></span>
<span id="cb384-3"><a href="#cb384-3"></a><span class="kw">func</span> TestFirstClassFunctions(t *testing.T) {</span>
<span id="cb384-4"><a href="#cb384-4"></a>    tests := []vmTestCase{</span>
<span id="cb384-5"><a href="#cb384-5"></a>        <span class="co">// [...]</span></span>
<span id="cb384-6"><a href="#cb384-6"></a>        {</span>
<span id="cb384-7"><a href="#cb384-7"></a>            input: <span class="st">`</span></span>
<span id="cb384-8"><a href="#cb384-8"></a><span class="st">        let returnsOneReturner = fn() {</span></span>
<span id="cb384-9"><a href="#cb384-9"></a><span class="st">            let returnsOne = fn() { 1; };</span></span>
<span id="cb384-10"><a href="#cb384-10"></a><span class="st">            returnsOne;</span></span>
<span id="cb384-11"><a href="#cb384-11"></a><span class="st">        };</span></span>
<span id="cb384-12"><a href="#cb384-12"></a><span class="st">        returnsOneReturner()();</span></span>
<span id="cb384-13"><a href="#cb384-13"></a><span class="st">        `</span>,</span>
<span id="cb384-14"><a href="#cb384-14"></a>            expected: <span class="dv">1</span>,</span>
<span id="cb384-15"><a href="#cb384-15"></a>        },</span>
<span id="cb384-16"><a href="#cb384-16"></a>    }</span>
<span id="cb384-17"><a href="#cb384-17"></a></span>
<span id="cb384-18"><a href="#cb384-18"></a>    runVmTests(t, tests)</span>
<span id="cb384-19"><a href="#cb384-19"></a>}</span></code></pre></div>
<p>Yep, that passes:</p>
<div class="sourceCode" id="cb385"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb385-1"><a href="#cb385-1"></a>$ go test ./vm</span>
<span id="cb385-2"><a href="#cb385-2"></a>ok      monkey/vm   0.037s</span></code></pre></div>
<p>Now that we’ve reached our goal, where do we go next? Arguments to function calls – they are much closer to where we are than you might think.</p>
<h2 id="arguments">Arguments</h2>
<p>Let’s start this section with a little recap. In Monkey we can define functions to have parameters, like this:</p>
<div class="sourceCode" id="cb386"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb386-1"><a href="#cb386-1"></a><span class="kw">let</span> addThree <span class="op">=</span> fn(a<span class="op">,</span> b<span class="op">,</span> c) {</span>
<span id="cb386-2"><a href="#cb386-2"></a>  a <span class="op">+</span> b <span class="op">+</span> c<span class="op">;</span></span>
<span id="cb386-3"><a href="#cb386-3"></a>}</span></code></pre></div>
<p>This function has three parameters: <code>a</code>, <code>b</code>, and <code>c</code>. When we call it we can use arguments in the call expression:</p>
<div class="sourceCode" id="cb387"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb387-1"><a href="#cb387-1"></a>addThree(<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">;</span></span></code></pre></div>
<p>This binds the values passed in as arguments to the parameter names while the function executes. Now, the “bind” should ring a bell but I don’t want to beat around the bush, so let me come straight out with it: arguments to function calls are a special case of local bindings.</p>
<p>They have the same lifespan, they have the same scope, they resolve in the same way. The only difference is their creation. Local bindings are created explicitly by the user with a let statement and result in <code>OpSetLocal</code> instructions being emitted by the compiler. Arguments, on the other hand, are implicitly bound to names, which is done behind the scenes by the compiler and the VM. And that leads us to our list of tasks for this section.</p>
<p>Our goal in this section is to fully implement function parameters and arguments to function calls. At the end, we want to compile and execute this snippet of Monkey code:</p>
<div class="sourceCode" id="cb388"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb388-1"><a href="#cb388-1"></a><span class="kw">let</span> globalNum <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb388-2"><a href="#cb388-2"></a></span>
<span id="cb388-3"><a href="#cb388-3"></a><span class="kw">let</span> sum <span class="op">=</span> fn(a<span class="op">,</span> b) {</span>
<span id="cb388-4"><a href="#cb388-4"></a>  <span class="kw">let</span> c <span class="op">=</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb388-5"><a href="#cb388-5"></a>  c <span class="op">+</span> globalNum<span class="op">;</span></span>
<span id="cb388-6"><a href="#cb388-6"></a>}<span class="op">;</span></span>
<span id="cb388-7"><a href="#cb388-7"></a></span>
<span id="cb388-8"><a href="#cb388-8"></a><span class="kw">let</span> outer <span class="op">=</span> fn() {</span>
<span id="cb388-9"><a href="#cb388-9"></a>  sum(<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>) <span class="op">+</span> sum(<span class="dv">3</span><span class="op">,</span> <span class="dv">4</span>) <span class="op">+</span> globalNum<span class="op">;</span></span>
<span id="cb388-10"><a href="#cb388-10"></a>}<span class="op">;</span></span>
<span id="cb388-11"><a href="#cb388-11"></a></span>
<span id="cb388-12"><a href="#cb388-12"></a>outer() <span class="op">+</span> globalNum<span class="op">;</span></span></code></pre></div>
<p>At first glance, this looks quite chaotic. That’s intentional. It’s a mixture of everything we’ve already implemented and the things we’re about to build: global and local bindings, functions with and without parameters, function calls with and without arguments.</p>
<p>So what’s our plan? First, we need to rethink our calling convention. In its current form it doesn’t accommodate for arguments. Then, as the second and already final step, we need to implement this updated calling convention. But let’s start at the beginning.</p>
<h3 id="compiling-calls-with-arguments">Compiling Calls With Arguments</h3>
<p>The condensed version of our current calling convention is this: push the function you want to call on to the stack, emit <code>OpCall</code> and off you go. The question we’re now facing is where to put the arguments to the function call – not only “where” in the sense of a memory location, but also where in the calling convention.</p>
<p>We don’t have to search for a memory location for too long, because we already have a place where we store data that’s relevant to the current function call: the stack. And just like we use the stack to store the function that’s to be called, we can use it to store the arguments to the call.</p>
<p>But how do we get them on there? The easiest way is to simply push them on the stack right after the function has been pushed. And, surprisingly enough, there’s nothing that speaks against this pragmatic solution. It’s actually quite elegant, as we’ll later see.</p>
<p>So, if we adopt this approach, it changes our calling convention to this: push the function you want to call on to the stack, then push all the arguments to the call on to the stack, emit <code>OpCall</code> and off you go. The stack would then look like this, right before executing <code>OpCall</code>:</p>
<!-- ./ascii_drawings/07/stack_function_call_arguments.monopic -->
<figure>
<img src="./images/07/stack_function_call_arguments.svg" style="width:30.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>As things stand, though, that solution poses a slight problem to our VM, because it wouldn’t know how many arguments are on top of the stack.</p>
<p>Think of our implementation of <code>OpCall</code> in the VM. Before we push a new frame, we take the function to be called right off the top of the stack. With this new calling convention, there could be zero or multiple arguments on the stack – on top of the function. How do we reach the function on the stack so we can execute it?</p>
<p>Since functions are ordinary Monkey <code>object.Object</code>s we can’t even choose the hacky way and traverse the stack to find the first <code>object.CompiledFunction</code>; that might just be an argument to the function call.</p>
<p>Thankfully, we don’t have to resort to hacky and ugh-this-feels-dirty fixes. There’s a simple and beautiful solution available: we give the <code>OpCall</code> opcode an operand that holds the number of arguments of the call. One byte is enough for that (or do you want to call functions with more than 256 arguments?) and allows us, by doing a little calculation, to find the function below the arguments.</p>
<p>So, let’s add an operand to <code>OpCall</code>:</p>
<div class="sourceCode" id="cb389"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb389-1"><a href="#cb389-1"></a><span class="co">// code/code.go</span></span>
<span id="cb389-2"><a href="#cb389-2"></a></span>
<span id="cb389-3"><a href="#cb389-3"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb389-4"><a href="#cb389-4"></a>    <span class="co">// [...]</span></span>
<span id="cb389-5"><a href="#cb389-5"></a></span>
<span id="cb389-6"><a href="#cb389-6"></a>    OpCall:        {<span class="st">&quot;OpCall&quot;</span>, []<span class="dt">int</span>{<span class="dv">1</span>}},</span>
<span id="cb389-7"><a href="#cb389-7"></a></span>
<span id="cb389-8"><a href="#cb389-8"></a>    <span class="co">// [...]</span></span>
<span id="cb389-9"><a href="#cb389-9"></a>}</span></code></pre></div>
<p>With this change some tests are breaking due to <code>panic</code>s and index errors, because we defined something neither the compiler nor the VM know about. That’s not a problem per se, but the definition of the new operand causes our <code>code.Make</code> function to create an empty byte in its place – even if we don’t pass in an operand. We end up in this sort of limbo, where different parts in our system act on different assumptions and nobody knows what’s really happened. We need to restore order again.</p>
<p>We’ll start by updating our existing compiler tests and making sure that we do pass in an operand when creating <code>OpCall</code> instructions:</p>
<div class="sourceCode" id="cb390"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb390-1"><a href="#cb390-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb390-2"><a href="#cb390-2"></a></span>
<span id="cb390-3"><a href="#cb390-3"></a><span class="kw">func</span> TestFunctionCalls(t *testing.T) {</span>
<span id="cb390-4"><a href="#cb390-4"></a>    tests := []compilerTestCase{</span>
<span id="cb390-5"><a href="#cb390-5"></a>        {</span>
<span id="cb390-6"><a href="#cb390-6"></a>            <span class="co">// [...]</span></span>
<span id="cb390-7"><a href="#cb390-7"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb390-8"><a href="#cb390-8"></a>                code.Make(code.OpConstant, <span class="dv">1</span>), <span class="co">// The compiled function</span></span>
<span id="cb390-9"><a href="#cb390-9"></a>                code.Make(code.OpCall, <span class="dv">0</span>),</span>
<span id="cb390-10"><a href="#cb390-10"></a>                code.Make(code.OpPop),</span>
<span id="cb390-11"><a href="#cb390-11"></a>            },</span>
<span id="cb390-12"><a href="#cb390-12"></a>        },</span>
<span id="cb390-13"><a href="#cb390-13"></a>        {</span>
<span id="cb390-14"><a href="#cb390-14"></a>            <span class="co">// [...]</span></span>
<span id="cb390-15"><a href="#cb390-15"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb390-16"><a href="#cb390-16"></a>                code.Make(code.OpConstant, <span class="dv">1</span>), <span class="co">// The compiled function</span></span>
<span id="cb390-17"><a href="#cb390-17"></a>                code.Make(code.OpSetGlobal, <span class="dv">0</span>),</span>
<span id="cb390-18"><a href="#cb390-18"></a>                code.Make(code.OpGetGlobal, <span class="dv">0</span>),</span>
<span id="cb390-19"><a href="#cb390-19"></a>                code.Make(code.OpCall, <span class="dv">0</span>),</span>
<span id="cb390-20"><a href="#cb390-20"></a>                code.Make(code.OpPop),</span>
<span id="cb390-21"><a href="#cb390-21"></a>            },</span>
<span id="cb390-22"><a href="#cb390-22"></a>        },</span>
<span id="cb390-23"><a href="#cb390-23"></a>    }</span>
<span id="cb390-24"><a href="#cb390-24"></a></span>
<span id="cb390-25"><a href="#cb390-25"></a>    runCompilerTests(t, tests)</span>
<span id="cb390-26"><a href="#cb390-26"></a>}</span></code></pre></div>
<p>That makes the compiler tests correct and the compiler itself is fine for now, because it also uses <code>code.Make</code> to emit instructions, which, again, adds an empty byte for the new operand, even if none was passed in as argument.</p>
<p>The VM, though, stumbles and trips over the new operand, empty or not. The solution for now, at least until we’ve written the tests to tell us what we actually want, is to simply skip it:</p>
<div class="sourceCode" id="cb391"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb391-1"><a href="#cb391-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb391-2"><a href="#cb391-2"></a></span>
<span id="cb391-3"><a href="#cb391-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb391-4"><a href="#cb391-4"></a>    <span class="co">// [...]</span></span>
<span id="cb391-5"><a href="#cb391-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb391-6"><a href="#cb391-6"></a>        <span class="co">// [...]</span></span>
<span id="cb391-7"><a href="#cb391-7"></a></span>
<span id="cb391-8"><a href="#cb391-8"></a>        <span class="kw">case</span> code.OpCall:</span>
<span id="cb391-9"><a href="#cb391-9"></a>            vm.currentFrame().ip += <span class="dv">1</span></span>
<span id="cb391-10"><a href="#cb391-10"></a>            <span class="co">// [...]</span></span>
<span id="cb391-11"><a href="#cb391-11"></a></span>
<span id="cb391-12"><a href="#cb391-12"></a>        <span class="co">// [...]</span></span>
<span id="cb391-13"><a href="#cb391-13"></a>        }</span>
<span id="cb391-14"><a href="#cb391-14"></a>    <span class="co">// [...]</span></span>
<span id="cb391-15"><a href="#cb391-15"></a>}</span></code></pre></div>
<p>Order is restored:</p>
<div class="sourceCode" id="cb392"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb392-1"><a href="#cb392-1"></a>$ go test ./...</span>
<span id="cb392-2"><a href="#cb392-2"></a>?       monkey  [no test files]</span>
<span id="cb392-3"><a href="#cb392-3"></a>ok      monkey/ast  0.014s</span>
<span id="cb392-4"><a href="#cb392-4"></a>ok      monkey/code 0.014s</span>
<span id="cb392-5"><a href="#cb392-5"></a>ok      monkey/compiler 0.011s</span>
<span id="cb392-6"><a href="#cb392-6"></a>ok      monkey/evaluator    0.014s</span>
<span id="cb392-7"><a href="#cb392-7"></a>ok      monkey/lexer    0.011s</span>
<span id="cb392-8"><a href="#cb392-8"></a>ok      monkey/object   0.014s</span>
<span id="cb392-9"><a href="#cb392-9"></a>ok      monkey/parser   0.009s</span>
<span id="cb392-10"><a href="#cb392-10"></a>?       monkey/repl [no test files]</span>
<span id="cb392-11"><a href="#cb392-11"></a>?       monkey/token    [no test files]</span>
<span id="cb392-12"><a href="#cb392-12"></a>ok      monkey/vm   0.037s</span></code></pre></div>
<p>We’re back on track and can now write a test to make sure the compiler conforms to the updated calling convention by emitting instructions that push the arguments on to the stack. Since we already have <code>TestFunctionCalls</code> in place, we can extend it with new test cases instead of having to add a new test function:</p>
<div class="sourceCode" id="cb393"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb393-1"><a href="#cb393-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb393-2"><a href="#cb393-2"></a></span>
<span id="cb393-3"><a href="#cb393-3"></a><span class="kw">func</span> TestFunctionCalls(t *testing.T) {</span>
<span id="cb393-4"><a href="#cb393-4"></a>    tests := []compilerTestCase{</span>
<span id="cb393-5"><a href="#cb393-5"></a>        <span class="co">// [...]</span></span>
<span id="cb393-6"><a href="#cb393-6"></a>        {</span>
<span id="cb393-7"><a href="#cb393-7"></a>            input: <span class="st">`</span></span>
<span id="cb393-8"><a href="#cb393-8"></a><span class="st">            let oneArg = fn(a) { };</span></span>
<span id="cb393-9"><a href="#cb393-9"></a><span class="st">            oneArg(24);</span></span>
<span id="cb393-10"><a href="#cb393-10"></a><span class="st">            `</span>,</span>
<span id="cb393-11"><a href="#cb393-11"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb393-12"><a href="#cb393-12"></a>                []code.Instructions{</span>
<span id="cb393-13"><a href="#cb393-13"></a>                    code.Make(code.OpReturn),</span>
<span id="cb393-14"><a href="#cb393-14"></a>                },</span>
<span id="cb393-15"><a href="#cb393-15"></a>                <span class="dv">24</span>,</span>
<span id="cb393-16"><a href="#cb393-16"></a>            },</span>
<span id="cb393-17"><a href="#cb393-17"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb393-18"><a href="#cb393-18"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb393-19"><a href="#cb393-19"></a>                code.Make(code.OpSetGlobal, <span class="dv">0</span>),</span>
<span id="cb393-20"><a href="#cb393-20"></a>                code.Make(code.OpGetGlobal, <span class="dv">0</span>),</span>
<span id="cb393-21"><a href="#cb393-21"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb393-22"><a href="#cb393-22"></a>                code.Make(code.OpCall, <span class="dv">1</span>),</span>
<span id="cb393-23"><a href="#cb393-23"></a>                code.Make(code.OpPop),</span>
<span id="cb393-24"><a href="#cb393-24"></a>            },</span>
<span id="cb393-25"><a href="#cb393-25"></a>        },</span>
<span id="cb393-26"><a href="#cb393-26"></a>        {</span>
<span id="cb393-27"><a href="#cb393-27"></a>            input: <span class="st">`</span></span>
<span id="cb393-28"><a href="#cb393-28"></a><span class="st">            let manyArg = fn(a, b, c) { };</span></span>
<span id="cb393-29"><a href="#cb393-29"></a><span class="st">            manyArg(24, 25, 26);</span></span>
<span id="cb393-30"><a href="#cb393-30"></a><span class="st">            `</span>,</span>
<span id="cb393-31"><a href="#cb393-31"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb393-32"><a href="#cb393-32"></a>                []code.Instructions{</span>
<span id="cb393-33"><a href="#cb393-33"></a>                    code.Make(code.OpReturn),</span>
<span id="cb393-34"><a href="#cb393-34"></a>                },</span>
<span id="cb393-35"><a href="#cb393-35"></a>                <span class="dv">24</span>,</span>
<span id="cb393-36"><a href="#cb393-36"></a>                <span class="dv">25</span>,</span>
<span id="cb393-37"><a href="#cb393-37"></a>                <span class="dv">26</span>,</span>
<span id="cb393-38"><a href="#cb393-38"></a>            },</span>
<span id="cb393-39"><a href="#cb393-39"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb393-40"><a href="#cb393-40"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb393-41"><a href="#cb393-41"></a>                code.Make(code.OpSetGlobal, <span class="dv">0</span>),</span>
<span id="cb393-42"><a href="#cb393-42"></a>                code.Make(code.OpGetGlobal, <span class="dv">0</span>),</span>
<span id="cb393-43"><a href="#cb393-43"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb393-44"><a href="#cb393-44"></a>                code.Make(code.OpConstant, <span class="dv">2</span>),</span>
<span id="cb393-45"><a href="#cb393-45"></a>                code.Make(code.OpConstant, <span class="dv">3</span>),</span>
<span id="cb393-46"><a href="#cb393-46"></a>                code.Make(code.OpCall, <span class="dv">3</span>),</span>
<span id="cb393-47"><a href="#cb393-47"></a>                code.Make(code.OpPop),</span>
<span id="cb393-48"><a href="#cb393-48"></a>            },</span>
<span id="cb393-49"><a href="#cb393-49"></a>        },</span>
<span id="cb393-50"><a href="#cb393-50"></a>    }</span>
<span id="cb393-51"><a href="#cb393-51"></a></span>
<span id="cb393-52"><a href="#cb393-52"></a>    runCompilerTests(t, tests)</span>
<span id="cb393-53"><a href="#cb393-53"></a>}</span></code></pre></div>
<p>It’s worth noting that the functions used in these new test cases have an empty body and don’t make use of their parameters. That’s by design. We first want to make sure that we can compile function calls and once we have that in place, we’ll reference the parameters in the same tests and update our expectations.</p>
<p>As you can see in the <code>expectedInstructions</code> of these test cases, the first argument to the function call should end up lowest on the stack. From our current point of view, it doesn’t really matter, but soon we’ll see how much nicer that makes things in the VM once we start to reference parameters.</p>
<p>The output of these new tests is quite instructive:</p>
<div class="sourceCode" id="cb394"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb394-1"><a href="#cb394-1"></a>$ go test ./compiler</span>
<span id="cb394-2"><a href="#cb394-2"></a>--- FAIL: TestFunctionCalls (0.00s)</span>
<span id="cb394-3"><a href="#cb394-3"></a> compiler_test.go:889: testInstructions failed: wrong instructions length.</span>
<span id="cb394-4"><a href="#cb394-4"></a>  want=&quot;0000 OpConstant 0\n0003 OpSetGlobal 0\n0006 OpGetGlobal 0\n\</span>
<span id="cb394-5"><a href="#cb394-5"></a>    0009 OpConstant 1\n0012 OpCall 1\n0014 OpPop\n&quot;</span>
<span id="cb394-6"><a href="#cb394-6"></a>  got =&quot;0000 OpConstant 0\n0003 OpSetGlobal 0\n0006 OpGetGlobal 0\n\</span>
<span id="cb394-7"><a href="#cb394-7"></a>    0009 OpCall 0\n0011 OpPop\n&quot;</span>
<span id="cb394-8"><a href="#cb394-8"></a>FAIL</span>
<span id="cb394-9"><a href="#cb394-9"></a>FAIL    monkey/compiler 0.008s</span></code></pre></div>
<p>The missing <code>OpConstant</code> instructions tell us that we need to compile the arguments of the function call and the wrong operand of <code>OpCall</code> tells us that it’s still unused.</p>
<p>We can do both by updating our <code>case</code> branch in the compiler for <code>*ast.CallExpression</code>s to this:</p>
<div class="sourceCode" id="cb395"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb395-1"><a href="#cb395-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb395-2"><a href="#cb395-2"></a></span>
<span id="cb395-3"><a href="#cb395-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb395-4"><a href="#cb395-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb395-5"><a href="#cb395-5"></a>    <span class="co">// [...]</span></span>
<span id="cb395-6"><a href="#cb395-6"></a></span>
<span id="cb395-7"><a href="#cb395-7"></a>    <span class="kw">case</span> *ast.CallExpression:</span>
<span id="cb395-8"><a href="#cb395-8"></a>        err := c.Compile(node.Function)</span>
<span id="cb395-9"><a href="#cb395-9"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb395-10"><a href="#cb395-10"></a>            <span class="kw">return</span> err</span>
<span id="cb395-11"><a href="#cb395-11"></a>        }</span>
<span id="cb395-12"><a href="#cb395-12"></a></span>
<span id="cb395-13"><a href="#cb395-13"></a>        <span class="kw">for</span> _, a := <span class="kw">range</span> node.Arguments {</span>
<span id="cb395-14"><a href="#cb395-14"></a>            err := c.Compile(a)</span>
<span id="cb395-15"><a href="#cb395-15"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb395-16"><a href="#cb395-16"></a>                <span class="kw">return</span> err</span>
<span id="cb395-17"><a href="#cb395-17"></a>            }</span>
<span id="cb395-18"><a href="#cb395-18"></a>        }</span>
<span id="cb395-19"><a href="#cb395-19"></a></span>
<span id="cb395-20"><a href="#cb395-20"></a>        c.emit(code.OpCall, <span class="bu">len</span>(node.Arguments))</span>
<span id="cb395-21"><a href="#cb395-21"></a></span>
<span id="cb395-22"><a href="#cb395-22"></a>    <span class="co">// [...]</span></span>
<span id="cb395-23"><a href="#cb395-23"></a>    }</span>
<span id="cb395-24"><a href="#cb395-24"></a></span>
<span id="cb395-25"><a href="#cb395-25"></a>    <span class="co">// [...]</span></span>
<span id="cb395-26"><a href="#cb395-26"></a>}</span></code></pre></div>
<p>What hasn’t changed here is the compilation of the <code>node.Function</code>. But now, with the new calling convention, that’s only the first step. We also need to push the arguments to the function call on to the stack.</p>
<p>We do that by compiling the arguments in sequence, using a loop. Since each argument is an <code>*ast.Expression</code> it’s compiled to one or more instructions that push a value on to the stack. The result is that the arguments end up on the stack above the function we want to call, exactly where the calling convention needs them to be. And to tell our VM how many arguments are now sitting above the function, we use <code>len(node.Arguments)</code> as the operand to <code>OpCall</code>.</p>
<p>Done. The tests are green:</p>
<div class="sourceCode" id="cb396"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb396-1"><a href="#cb396-1"></a>$ go test ./compiler</span>
<span id="cb396-2"><a href="#cb396-2"></a>ok      monkey/compiler 0.008s</span></code></pre></div>
<p>We can now compile call expressions with arguments. <em>Now</em> we can start to think about using those arguments in the function’s body.</p>
<h3 id="resolving-references-to-arguments">Resolving References to Arguments</h3>
<p>Before we update our test cases and replace those empty function bodies, let’s be sure about what we expect from the compiler. At the time of a function call, the arguments will now sit on the stack. How do we access them while the function is executing?</p>
<p>Should we add a new opcode, something like <code>OpGetArgument</code>, that tells the VM to push the argument on to the stack? For that we would need to give the arguments their own scope and index in the symbol table. Otherwise we wouldn’t know which opcode to emit when we come across a reference to an argument.</p>
<p>That’s a viable solution and if our goal was to explicitly treat arguments different from local bindings, then we should choose it, because it offers much more flexibility in that direction. But we don’t. In Monkey there is no difference between arguments passed in to a function and a local binding created in the same function. The better option for us is to embrace that and treat them the same.</p>
<p>Once you look at the stack at the time of a function call, it also becomes the obvious choice. The arguments sit right above the function that’s being called. And you know what’s normally stored in this region of the stack? Exactly! Local bindings! So if we treat arguments as locals, they would already be exactly where they need to be. The only thing we would then have to do is to treat them as locals in the compiler.</p>
<p>In practical terms that means emitting <code>OpGetLocal</code> instructions for every reference to a function’s parameter. In order to test that, we update our last two test cases in <code>TestFunctionCalls</code>:</p>
<div class="sourceCode" id="cb397"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb397-1"><a href="#cb397-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb397-2"><a href="#cb397-2"></a></span>
<span id="cb397-3"><a href="#cb397-3"></a><span class="kw">func</span> TestFunctionCalls(t *testing.T) {</span>
<span id="cb397-4"><a href="#cb397-4"></a>    tests := []compilerTestCase{</span>
<span id="cb397-5"><a href="#cb397-5"></a>        <span class="co">// [...]</span></span>
<span id="cb397-6"><a href="#cb397-6"></a>        {</span>
<span id="cb397-7"><a href="#cb397-7"></a>            input: <span class="st">`</span></span>
<span id="cb397-8"><a href="#cb397-8"></a><span class="st">            let oneArg = fn(a) { a };</span></span>
<span id="cb397-9"><a href="#cb397-9"></a><span class="st">            oneArg(24);</span></span>
<span id="cb397-10"><a href="#cb397-10"></a><span class="st">            `</span>,</span>
<span id="cb397-11"><a href="#cb397-11"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb397-12"><a href="#cb397-12"></a>                []code.Instructions{</span>
<span id="cb397-13"><a href="#cb397-13"></a>                    code.Make(code.OpGetLocal, <span class="dv">0</span>),</span>
<span id="cb397-14"><a href="#cb397-14"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb397-15"><a href="#cb397-15"></a>                },</span>
<span id="cb397-16"><a href="#cb397-16"></a>                <span class="dv">24</span>,</span>
<span id="cb397-17"><a href="#cb397-17"></a>            },</span>
<span id="cb397-18"><a href="#cb397-18"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb397-19"><a href="#cb397-19"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb397-20"><a href="#cb397-20"></a>                code.Make(code.OpSetGlobal, <span class="dv">0</span>),</span>
<span id="cb397-21"><a href="#cb397-21"></a>                code.Make(code.OpGetGlobal, <span class="dv">0</span>),</span>
<span id="cb397-22"><a href="#cb397-22"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb397-23"><a href="#cb397-23"></a>                code.Make(code.OpCall, <span class="dv">1</span>),</span>
<span id="cb397-24"><a href="#cb397-24"></a>                code.Make(code.OpPop),</span>
<span id="cb397-25"><a href="#cb397-25"></a>            },</span>
<span id="cb397-26"><a href="#cb397-26"></a>        },</span>
<span id="cb397-27"><a href="#cb397-27"></a>        {</span>
<span id="cb397-28"><a href="#cb397-28"></a>            input: <span class="st">`</span></span>
<span id="cb397-29"><a href="#cb397-29"></a><span class="st">            let manyArg = fn(a, b, c) { a; b; c };</span></span>
<span id="cb397-30"><a href="#cb397-30"></a><span class="st">            manyArg(24, 25, 26);</span></span>
<span id="cb397-31"><a href="#cb397-31"></a><span class="st">            `</span>,</span>
<span id="cb397-32"><a href="#cb397-32"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb397-33"><a href="#cb397-33"></a>                []code.Instructions{</span>
<span id="cb397-34"><a href="#cb397-34"></a>                    code.Make(code.OpGetLocal, <span class="dv">0</span>),</span>
<span id="cb397-35"><a href="#cb397-35"></a>                    code.Make(code.OpPop),</span>
<span id="cb397-36"><a href="#cb397-36"></a>                    code.Make(code.OpGetLocal, <span class="dv">1</span>),</span>
<span id="cb397-37"><a href="#cb397-37"></a>                    code.Make(code.OpPop),</span>
<span id="cb397-38"><a href="#cb397-38"></a>                    code.Make(code.OpGetLocal, <span class="dv">2</span>),</span>
<span id="cb397-39"><a href="#cb397-39"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb397-40"><a href="#cb397-40"></a>                },</span>
<span id="cb397-41"><a href="#cb397-41"></a>                <span class="dv">24</span>,</span>
<span id="cb397-42"><a href="#cb397-42"></a>                <span class="dv">25</span>,</span>
<span id="cb397-43"><a href="#cb397-43"></a>                <span class="dv">26</span>,</span>
<span id="cb397-44"><a href="#cb397-44"></a>            },</span>
<span id="cb397-45"><a href="#cb397-45"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb397-46"><a href="#cb397-46"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb397-47"><a href="#cb397-47"></a>                code.Make(code.OpSetGlobal, <span class="dv">0</span>),</span>
<span id="cb397-48"><a href="#cb397-48"></a>                code.Make(code.OpGetGlobal, <span class="dv">0</span>),</span>
<span id="cb397-49"><a href="#cb397-49"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb397-50"><a href="#cb397-50"></a>                code.Make(code.OpConstant, <span class="dv">2</span>),</span>
<span id="cb397-51"><a href="#cb397-51"></a>                code.Make(code.OpConstant, <span class="dv">3</span>),</span>
<span id="cb397-52"><a href="#cb397-52"></a>                code.Make(code.OpCall, <span class="dv">3</span>),</span>
<span id="cb397-53"><a href="#cb397-53"></a>                code.Make(code.OpPop),</span>
<span id="cb397-54"><a href="#cb397-54"></a>            },</span>
<span id="cb397-55"><a href="#cb397-55"></a>        },</span>
<span id="cb397-56"><a href="#cb397-56"></a>    }</span>
<span id="cb397-57"><a href="#cb397-57"></a></span>
<span id="cb397-58"><a href="#cb397-58"></a>    runCompilerTests(t, tests)</span>
<span id="cb397-59"><a href="#cb397-59"></a>}</span></code></pre></div>
<p>Instead of empty function bodies, we now have references to the parameters of the functions. And the updated expectations tell the compiler that these references should be turned into <code>OpGetLocal</code> instructions that load the arguments on to the stack. The indexes to these <code>OpGetLocal</code> instructions start at <code>0</code> for the first argument and then increment with each next one. Just like other local bindings.</p>
<p>If we run the tests we can see that the compiler can’t resolve these references yet:</p>
<div class="sourceCode" id="cb398"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb398-1"><a href="#cb398-1"></a>$ go test ./compiler</span>
<span id="cb398-2"><a href="#cb398-2"></a>--- FAIL: TestFunctionCalls (0.00s)</span>
<span id="cb398-3"><a href="#cb398-3"></a> compiler_test.go:541: compiler error: undefined variable a</span>
<span id="cb398-4"><a href="#cb398-4"></a>FAIL</span>
<span id="cb398-5"><a href="#cb398-5"></a>FAIL    monkey/compiler 0.009s</span></code></pre></div>
<p>And here’s where we step into “oh, nice” territory. All it takes for us to fix this is to define the parameters of a function as a local binding. And “define” is meant to be taken literally here. It’s just one method call:</p>
<div class="sourceCode" id="cb399"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb399-1"><a href="#cb399-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb399-2"><a href="#cb399-2"></a></span>
<span id="cb399-3"><a href="#cb399-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb399-4"><a href="#cb399-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb399-5"><a href="#cb399-5"></a>    <span class="co">// [...]</span></span>
<span id="cb399-6"><a href="#cb399-6"></a></span>
<span id="cb399-7"><a href="#cb399-7"></a>    <span class="kw">case</span> *ast.FunctionLiteral:</span>
<span id="cb399-8"><a href="#cb399-8"></a>        c.enterScope()</span>
<span id="cb399-9"><a href="#cb399-9"></a></span>
<span id="cb399-10"><a href="#cb399-10"></a>        <span class="kw">for</span> _, p := <span class="kw">range</span> node.Parameters {</span>
<span id="cb399-11"><a href="#cb399-11"></a>            c.symbolTable.Define(p.Value)</span>
<span id="cb399-12"><a href="#cb399-12"></a>        }</span>
<span id="cb399-13"><a href="#cb399-13"></a></span>
<span id="cb399-14"><a href="#cb399-14"></a>        err := c.Compile(node.Body)</span>
<span id="cb399-15"><a href="#cb399-15"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb399-16"><a href="#cb399-16"></a>            <span class="kw">return</span> err</span>
<span id="cb399-17"><a href="#cb399-17"></a>        }</span>
<span id="cb399-18"><a href="#cb399-18"></a>        <span class="co">// [...]</span></span>
<span id="cb399-19"><a href="#cb399-19"></a></span>
<span id="cb399-20"><a href="#cb399-20"></a>    <span class="co">// [...]</span></span>
<span id="cb399-21"><a href="#cb399-21"></a>    }</span>
<span id="cb399-22"><a href="#cb399-22"></a></span>
<span id="cb399-23"><a href="#cb399-23"></a>    <span class="co">// [...]</span></span>
<span id="cb399-24"><a href="#cb399-24"></a>}</span></code></pre></div>
<p>After entering a new scope and right before compiling the function’s body we define each parameter in the scope of the function. That allows the symbol table (and in turn the compiler) to resolve the new references and treat them as locals when compiling the function’s body. Look:</p>
<div class="sourceCode" id="cb400"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb400-1"><a href="#cb400-1"></a>$ go test ./compiler</span>
<span id="cb400-2"><a href="#cb400-2"></a>ok      monkey/compiler 0.009s</span></code></pre></div>
<p>Isn’t that neat?</p>
<h3 id="arguments-in-the-vm">Arguments in the VM</h3>
<p>Remember that our goal is to compile and get this piece of Monkey code running in our VM:</p>
<div class="sourceCode" id="cb401"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb401-1"><a href="#cb401-1"></a><span class="kw">let</span> globalNum <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb401-2"><a href="#cb401-2"></a></span>
<span id="cb401-3"><a href="#cb401-3"></a><span class="kw">let</span> sum <span class="op">=</span> fn(a<span class="op">,</span> b) {</span>
<span id="cb401-4"><a href="#cb401-4"></a>  <span class="kw">let</span> c <span class="op">=</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb401-5"><a href="#cb401-5"></a>  c <span class="op">+</span> globalNum<span class="op">;</span></span>
<span id="cb401-6"><a href="#cb401-6"></a>}<span class="op">;</span></span>
<span id="cb401-7"><a href="#cb401-7"></a></span>
<span id="cb401-8"><a href="#cb401-8"></a><span class="kw">let</span> outer <span class="op">=</span> fn() {</span>
<span id="cb401-9"><a href="#cb401-9"></a>  sum(<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>) <span class="op">+</span> sum(<span class="dv">3</span><span class="op">,</span> <span class="dv">4</span>) <span class="op">+</span> globalNum<span class="op">;</span></span>
<span id="cb401-10"><a href="#cb401-10"></a>}<span class="op">;</span></span>
<span id="cb401-11"><a href="#cb401-11"></a></span>
<span id="cb401-12"><a href="#cb401-12"></a>outer() <span class="op">+</span> globalNum<span class="op">;</span></span></code></pre></div>
<p>We’re nearly there. We can already extract bits of this snippet and turn them into a test for the VM:</p>
<div class="sourceCode" id="cb402"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb402-1"><a href="#cb402-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb402-2"><a href="#cb402-2"></a></span>
<span id="cb402-3"><a href="#cb402-3"></a><span class="kw">func</span> TestCallingFunctionsWithArgumentsAndBindings(t *testing.T) {</span>
<span id="cb402-4"><a href="#cb402-4"></a>    tests := []vmTestCase{</span>
<span id="cb402-5"><a href="#cb402-5"></a>        {</span>
<span id="cb402-6"><a href="#cb402-6"></a>            input: <span class="st">`</span></span>
<span id="cb402-7"><a href="#cb402-7"></a><span class="st">        let identity = fn(a) { a; };</span></span>
<span id="cb402-8"><a href="#cb402-8"></a><span class="st">        identity(4);</span></span>
<span id="cb402-9"><a href="#cb402-9"></a><span class="st">        `</span>,</span>
<span id="cb402-10"><a href="#cb402-10"></a>            expected: <span class="dv">4</span>,</span>
<span id="cb402-11"><a href="#cb402-11"></a>        },</span>
<span id="cb402-12"><a href="#cb402-12"></a>        {</span>
<span id="cb402-13"><a href="#cb402-13"></a>            input: <span class="st">`</span></span>
<span id="cb402-14"><a href="#cb402-14"></a><span class="st">        let sum = fn(a, b) { a + b; };</span></span>
<span id="cb402-15"><a href="#cb402-15"></a><span class="st">        sum(1, 2);</span></span>
<span id="cb402-16"><a href="#cb402-16"></a><span class="st">        `</span>,</span>
<span id="cb402-17"><a href="#cb402-17"></a>            expected: <span class="dv">3</span>,</span>
<span id="cb402-18"><a href="#cb402-18"></a>        },</span>
<span id="cb402-19"><a href="#cb402-19"></a>    }</span>
<span id="cb402-20"><a href="#cb402-20"></a></span>
<span id="cb402-21"><a href="#cb402-21"></a>    runVmTests(t, tests)</span>
<span id="cb402-22"><a href="#cb402-22"></a>}</span></code></pre></div>
<p>That shows what we’re after in its most basic form. In the first test case we pass one argument to a function that only references its single argument and returns it. The second test case is the sanity check that makes sure we’re not hard-coding edge cases into our VM and can also handle multiple arguments. Both fail:</p>
<div class="sourceCode" id="cb403"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb403-1"><a href="#cb403-1"></a>$ go test ./vm</span>
<span id="cb403-2"><a href="#cb403-2"></a>--- FAIL: TestCallingFunctionsWithArgumentsAndBindings (0.00s)</span>
<span id="cb403-3"><a href="#cb403-3"></a> vm_test.go:709: vm error: calling non-function</span>
<span id="cb403-4"><a href="#cb403-4"></a>FAIL</span>
<span id="cb403-5"><a href="#cb403-5"></a>FAIL    monkey/vm   0.039s</span></code></pre></div>
<p>This is interesting. The test doesn’t fail because the VM can’t find the arguments on the stack. It fails because it can’t find the function. And that’s because it’s looking in the wrong place.</p>
<p>The VM still expects the function to sit on top of the stack – correct behaviour according to the <em>old</em> calling convention. But since we updated the compiler, the emitted instructions not only put the function on the stack, but also the arguments. That’s why the VM says it can’t call a non-function: it trips over the arguments.</p>
<p>The fix is to use the operand of the <code>OpCall</code> instruction as it was designed to be used: to reach further down the stack to get to the function.</p>
<div class="sourceCode" id="cb404"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb404-1"><a href="#cb404-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb404-2"><a href="#cb404-2"></a></span>
<span id="cb404-3"><a href="#cb404-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb404-4"><a href="#cb404-4"></a>    <span class="co">// [...]</span></span>
<span id="cb404-5"><a href="#cb404-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb404-6"><a href="#cb404-6"></a>        <span class="co">// [...]</span></span>
<span id="cb404-7"><a href="#cb404-7"></a></span>
<span id="cb404-8"><a href="#cb404-8"></a>        <span class="kw">case</span> code.OpCall:</span>
<span id="cb404-9"><a href="#cb404-9"></a>            numArgs := code.ReadUint8(ins[ip+<span class="dv">1</span>:])</span>
<span id="cb404-10"><a href="#cb404-10"></a>            vm.currentFrame().ip += <span class="dv">1</span></span>
<span id="cb404-11"><a href="#cb404-11"></a></span>
<span id="cb404-12"><a href="#cb404-12"></a>            fn, ok := vm.stack[vm.sp<span class="dv">-1</span>-<span class="dt">int</span>(numArgs)].(*object.CompiledFunction)</span>
<span id="cb404-13"><a href="#cb404-13"></a>            <span class="kw">if</span> !ok {</span>
<span id="cb404-14"><a href="#cb404-14"></a>                <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;calling non-function&quot;</span>)</span>
<span id="cb404-15"><a href="#cb404-15"></a>            }</span>
<span id="cb404-16"><a href="#cb404-16"></a>            frame := NewFrame(fn, vm.sp)</span>
<span id="cb404-17"><a href="#cb404-17"></a>            vm.pushFrame(frame)</span>
<span id="cb404-18"><a href="#cb404-18"></a>            vm.sp = frame.basePointer + fn.NumLocals</span>
<span id="cb404-19"><a href="#cb404-19"></a></span>
<span id="cb404-20"><a href="#cb404-20"></a>        <span class="co">// [...]</span></span>
<span id="cb404-21"><a href="#cb404-21"></a>        }</span>
<span id="cb404-22"><a href="#cb404-22"></a>    <span class="co">// [...]</span></span>
<span id="cb404-23"><a href="#cb404-23"></a>}</span></code></pre></div>
<p>Instead of simply grabbing the function off the top of the stack, we calculate its position by decoding the operand, <code>numArgs</code>, and subtracting it from <code>vm.sp</code>. The additional <code>-1</code> is there because <code>vm.sp</code> doesn’t point to the topmost element on the stack, but the slot where the next element will be pushed.</p>
<p>That gets us a little bit further, but not by much:</p>
<div class="sourceCode" id="cb405"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb405-1"><a href="#cb405-1"></a>$ go test ./vm</span>
<span id="cb405-2"><a href="#cb405-2"></a>--- FAIL: TestCallingFunctionsWithArgumentsAndBindings (0.00s)</span>
<span id="cb405-3"><a href="#cb405-3"></a> vm_test.go:357: testIntegerObject failed:\</span>
<span id="cb405-4"><a href="#cb405-4"></a>   object is not Integer. got=&lt;nil&gt; (&lt;nil&gt;)</span>
<span id="cb405-5"><a href="#cb405-5"></a>panic: runtime error: \</span>
<span id="cb405-6"><a href="#cb405-6"></a>  invalid memory address or nil pointer dereference [recovered]</span>
<span id="cb405-7"><a href="#cb405-7"></a> panic: runtime error: invalid memory address or nil pointer dereference</span>
<span id="cb405-8"><a href="#cb405-8"></a>[signal SIGSEGV: segmentation violation code=0x1 addr=0x20 pc=0x10f7841]</span>
<span id="cb405-9"><a href="#cb405-9"></a></span>
<span id="cb405-10"><a href="#cb405-10"></a>goroutine 13 [running]:</span>
<span id="cb405-11"><a href="#cb405-11"></a>testing.tRunner.func1(0xc4200a80f0)</span>
<span id="cb405-12"><a href="#cb405-12"></a> /usr/local/go/src/testing/testing.go:742 +0x29d</span>
<span id="cb405-13"><a href="#cb405-13"></a>panic(0x11215e0, 0x11fffa0)</span>
<span id="cb405-14"><a href="#cb405-14"></a> /usr/local/go/src/runtime/panic.go:502 +0x229</span>
<span id="cb405-15"><a href="#cb405-15"></a>monkey/vm.(*VM).executeBinaryOperation(0xc4204b3eb8, 0x1, 0x0, 0x0)</span>
<span id="cb405-16"><a href="#cb405-16"></a> /Users/mrnugget/code/07/src/monkey/vm/vm.go:270 +0xa1</span>
<span id="cb405-17"><a href="#cb405-17"></a>monkey/vm.(*VM).Run(0xc4204b3eb8, 0x10000, 0x10000)</span>
<span id="cb405-18"><a href="#cb405-18"></a> /Users/mrnugget/code/07/src/monkey/vm/vm.go:87 +0x155</span>
<span id="cb405-19"><a href="#cb405-19"></a>monkey/vm.runVmTests(0xc4200a80f0, 0xc4204b3f58, 0x2, 0x2)</span>
<span id="cb405-20"><a href="#cb405-20"></a> /Users/mrnugget/code/07/src/monkey/vm/vm_test.go:276 +0x5de</span>
<span id="cb405-21"><a href="#cb405-21"></a>monkey/vm.TestCallingFunctionsWithArgumentsAndBindings(0xc4200a80f0)</span>
<span id="cb405-22"><a href="#cb405-22"></a> /Users/mrnugget/code/07/src/monkey/vm/vm_test.go:357 +0x93</span>
<span id="cb405-23"><a href="#cb405-23"></a>testing.tRunner(0xc4200a80f0, 0x11540e8)</span>
<span id="cb405-24"><a href="#cb405-24"></a> /usr/local/go/src/testing/testing.go:777 +0xd0</span>
<span id="cb405-25"><a href="#cb405-25"></a>created by testing.(*T).Run</span>
<span id="cb405-26"><a href="#cb405-26"></a> /usr/local/go/src/testing/testing.go:824 +0x2e0</span>
<span id="cb405-27"><a href="#cb405-27"></a>FAIL    monkey/vm   0.049s</span></code></pre></div>
<p>The first test case tells us that the value that was last popped off the stack is not the expected <code>4</code>, but <code>nil</code>. Alright. Apparently the VM can’t find the arguments on the stack.</p>
<p>The second test case doesn’t tell us anything but blows up. Why it does that is not immediately visible and requires some walking up of the stack trace. And once we reach <code>vm.go</code> we find the reason for the <code>panic</code>: the VM tries to call the <code>object.Object.Type</code> method on two <code>nil</code> pointers, which it popped off the stack in order to add them together.</p>
<p>Both failures come down to the same thing: the VM tries to find the arguments on the stack but gets <code>nil</code>s instead.</p>
<p>That at least <em>something</em> doesn’t work is kinda what we expected. But then again, not really. The arguments sit on top of the stack, right above the function being called. That’s where local bindings are supposed to be stored. And since we treat arguments as locals and want to retrieve them with <code>OpGetLocal</code> instructions, that’s exactly where they should be. That’s the beauty behind the whole idea of treating arguments as locals. So why can’t the VM find them?</p>
<p>Short answer: because our stack pointer is too high. The way we initialize it together with <code>basePointer</code> when setting up a new frame is outdated.</p>
<p>Remember that the <code>basePointer</code> of <code>Frame</code> has two purposes. First, it serves as a reset button we can push to get rid of a just-executed function and everything the function left on the stack by setting <code>vm.sp</code> to the <code>basePointer - 1</code>.</p>
<p>The second one is to serve as a reference for local bindings. This is where the bug hides. Right before we execute a function we set <code>basePointer</code> to the current value of <code>vm.sp</code>. Then we increase <code>vm.sp</code> by the number of locals the function’s going to use, which gives us what we called “the hole”: N slots on the stack which we can use to store and retrieve local bindings.</p>
<p>What makes our tests fail is that before we execute the function, we already have things on the stack we want to use as locals: the arguments of the call. And we want to access them with the same formula we use for other local bindings: <code>basePointer</code> plus individual local-binding index. The problem is that when we now initialize a new frame, the stack looks like this:</p>
<!-- ./ascii_drawings/07/stack_function_call_arguments.monopic -->
<figure>
<img src="./images/07/stack_function_call_arguments_basepointer_wrong.svg" style="width:55.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>I bet you can see the problem. We set <code>basePointer</code> to the current value of <code>vm.sp</code> <em>after</em> we pushed the arguments on the stack. That leads to <code>basePointer</code> <em>plus</em> the index of the local binding pointing to empty stack slots. And the result of that is that the VM gets <code>nil</code>s instead of the arguments it wants.</p>
<p>We need to adjust the <code>basePointer</code>. We can’t just clone <code>vm.sp</code> anymore. But the new and correct formula for <code>basePointer</code> is not much harder to understand: <code>basePointer = vm.sp - numArguments</code>. That results in this stack layout at the start of a function call:</p>
<!-- ./ascii_drawings/07/stack_function_call_arguments.monopic -->
<figure>
<img src="./images/07/stack_function_call_arguments_basepointer_right.svg" style="width:55.0%" alt="" /><figcaption> </figcaption>
</figure>
<p>That would work. With this, if we’d compute <code>basePointer</code> <em>plus</em> local binding index of the argument, we’d get the correct slot. And on top of that (pun intended!) the <code>vm.sp</code> would still point to the next empty slot on the stack. Perfect!</p>
<p>Here is this idea’s translation into code:</p>
<div class="sourceCode" id="cb406"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb406-1"><a href="#cb406-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb406-2"><a href="#cb406-2"></a></span>
<span id="cb406-3"><a href="#cb406-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb406-4"><a href="#cb406-4"></a>    <span class="co">// [...]</span></span>
<span id="cb406-5"><a href="#cb406-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb406-6"><a href="#cb406-6"></a>        <span class="co">// [...]</span></span>
<span id="cb406-7"><a href="#cb406-7"></a></span>
<span id="cb406-8"><a href="#cb406-8"></a>        <span class="kw">case</span> code.OpCall:</span>
<span id="cb406-9"><a href="#cb406-9"></a>            numArgs := code.ReadUint8(ins[ip+<span class="dv">1</span>:])</span>
<span id="cb406-10"><a href="#cb406-10"></a>            vm.currentFrame().ip += <span class="dv">1</span></span>
<span id="cb406-11"><a href="#cb406-11"></a></span>
<span id="cb406-12"><a href="#cb406-12"></a>            err := vm.callFunction(<span class="dt">int</span>(numArgs))</span>
<span id="cb406-13"><a href="#cb406-13"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb406-14"><a href="#cb406-14"></a>                <span class="kw">return</span> err</span>
<span id="cb406-15"><a href="#cb406-15"></a>            }</span>
<span id="cb406-16"><a href="#cb406-16"></a></span>
<span id="cb406-17"><a href="#cb406-17"></a>        <span class="co">// [...]</span></span>
<span id="cb406-18"><a href="#cb406-18"></a>        }</span>
<span id="cb406-19"><a href="#cb406-19"></a>    <span class="co">// [...]</span></span>
<span id="cb406-20"><a href="#cb406-20"></a>}</span>
<span id="cb406-21"><a href="#cb406-21"></a></span>
<span id="cb406-22"><a href="#cb406-22"></a><span class="kw">func</span> (vm *VM) callFunction(numArgs <span class="dt">int</span>) <span class="dt">error</span> {</span>
<span id="cb406-23"><a href="#cb406-23"></a>    fn, ok := vm.stack[vm.sp<span class="dv">-1</span>-numArgs].(*object.CompiledFunction)</span>
<span id="cb406-24"><a href="#cb406-24"></a>    <span class="kw">if</span> !ok {</span>
<span id="cb406-25"><a href="#cb406-25"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;calling non-function&quot;</span>)</span>
<span id="cb406-26"><a href="#cb406-26"></a>    }</span>
<span id="cb406-27"><a href="#cb406-27"></a></span>
<span id="cb406-28"><a href="#cb406-28"></a>    frame := NewFrame(fn, vm.sp-numArgs)</span>
<span id="cb406-29"><a href="#cb406-29"></a>    vm.pushFrame(frame)</span>
<span id="cb406-30"><a href="#cb406-30"></a></span>
<span id="cb406-31"><a href="#cb406-31"></a>    vm.sp = frame.basePointer + fn.NumLocals</span>
<span id="cb406-32"><a href="#cb406-32"></a></span>
<span id="cb406-33"><a href="#cb406-33"></a>    <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb406-34"><a href="#cb406-34"></a>}</span></code></pre></div>
<p>Before it’s too late, we move the main part of the <code>OpCall</code> implementation to a new method, called <code>callFunction</code>. Don’t be fooled, though, barely anything has changed in the implementation itself. The only difference is the second argument in the call to <code>NewFrame</code>. Instead of passing in <code>vm.sp</code> as the future <code>basePointer</code> for the frame, we first subtract <code>numArgs</code>. That gives us the <code>basePointer</code> as pictured in the diagram earlier.</p>
<p>Now look at that:</p>
<div class="sourceCode" id="cb407"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb407-1"><a href="#cb407-1"></a>$ go test ./vm</span>
<span id="cb407-2"><a href="#cb407-2"></a>ok      monkey/vm   0.047s</span></code></pre></div>
<p><em>All</em> of our tests are passing! Let’s roll the dice, go even further and throw some more tests at our VM:</p>
<div class="sourceCode" id="cb408"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb408-1"><a href="#cb408-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb408-2"><a href="#cb408-2"></a></span>
<span id="cb408-3"><a href="#cb408-3"></a><span class="kw">func</span> TestCallingFunctionsWithArgumentsAndBindings(t *testing.T) {</span>
<span id="cb408-4"><a href="#cb408-4"></a>    tests := []vmTestCase {</span>
<span id="cb408-5"><a href="#cb408-5"></a>        <span class="co">// [...]</span></span>
<span id="cb408-6"><a href="#cb408-6"></a>        {</span>
<span id="cb408-7"><a href="#cb408-7"></a>            input: <span class="st">`</span></span>
<span id="cb408-8"><a href="#cb408-8"></a><span class="st">        let sum = fn(a, b) {</span></span>
<span id="cb408-9"><a href="#cb408-9"></a><span class="st">            let c = a + b;</span></span>
<span id="cb408-10"><a href="#cb408-10"></a><span class="st">            c;</span></span>
<span id="cb408-11"><a href="#cb408-11"></a><span class="st">        };</span></span>
<span id="cb408-12"><a href="#cb408-12"></a><span class="st">        sum(1, 2);</span></span>
<span id="cb408-13"><a href="#cb408-13"></a><span class="st">        `</span>,</span>
<span id="cb408-14"><a href="#cb408-14"></a>            expected: <span class="dv">3</span>,</span>
<span id="cb408-15"><a href="#cb408-15"></a>        },</span>
<span id="cb408-16"><a href="#cb408-16"></a>        {</span>
<span id="cb408-17"><a href="#cb408-17"></a>            input: <span class="st">`</span></span>
<span id="cb408-18"><a href="#cb408-18"></a><span class="st">        let sum = fn(a, b) {</span></span>
<span id="cb408-19"><a href="#cb408-19"></a><span class="st">            let c = a + b;</span></span>
<span id="cb408-20"><a href="#cb408-20"></a><span class="st">            c;</span></span>
<span id="cb408-21"><a href="#cb408-21"></a><span class="st">        };</span></span>
<span id="cb408-22"><a href="#cb408-22"></a><span class="st">        sum(1, 2) + sum(3, 4);`</span>,</span>
<span id="cb408-23"><a href="#cb408-23"></a>            expected: <span class="dv">10</span>,</span>
<span id="cb408-24"><a href="#cb408-24"></a>        },</span>
<span id="cb408-25"><a href="#cb408-25"></a>        {</span>
<span id="cb408-26"><a href="#cb408-26"></a>            input: <span class="st">`</span></span>
<span id="cb408-27"><a href="#cb408-27"></a><span class="st">        let sum = fn(a, b) {</span></span>
<span id="cb408-28"><a href="#cb408-28"></a><span class="st">            let c = a + b;</span></span>
<span id="cb408-29"><a href="#cb408-29"></a><span class="st">            c;</span></span>
<span id="cb408-30"><a href="#cb408-30"></a><span class="st">        };</span></span>
<span id="cb408-31"><a href="#cb408-31"></a><span class="st">        let outer = fn() {</span></span>
<span id="cb408-32"><a href="#cb408-32"></a><span class="st">            sum(1, 2) + sum(3, 4);</span></span>
<span id="cb408-33"><a href="#cb408-33"></a><span class="st">        };</span></span>
<span id="cb408-34"><a href="#cb408-34"></a><span class="st">        outer();</span></span>
<span id="cb408-35"><a href="#cb408-35"></a><span class="st">        `</span>,</span>
<span id="cb408-36"><a href="#cb408-36"></a>            expected: <span class="dv">10</span>,</span>
<span id="cb408-37"><a href="#cb408-37"></a>        },</span>
<span id="cb408-38"><a href="#cb408-38"></a>    }</span>
<span id="cb408-39"><a href="#cb408-39"></a></span>
<span id="cb408-40"><a href="#cb408-40"></a>    runVmTests(t, tests)</span>
<span id="cb408-41"><a href="#cb408-41"></a>}</span></code></pre></div>
<p>These test cases make sure that we can mix manually created local bindings with arguments: in one function, or in the same function that’s called multiple times or in one function that’s called multiple times in another function. They all pass:</p>
<div class="sourceCode" id="cb409"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb409-1"><a href="#cb409-1"></a>$ go test ./vm</span>
<span id="cb409-2"><a href="#cb409-2"></a>ok      monkey/vm   0.041s</span></code></pre></div>
<p>Now, let’s see whether we’ve reached our goal:</p>
<div class="sourceCode" id="cb410"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb410-1"><a href="#cb410-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb410-2"><a href="#cb410-2"></a></span>
<span id="cb410-3"><a href="#cb410-3"></a><span class="kw">func</span> TestCallingFunctionsWithArgumentsAndBindings(t *testing.T) {</span>
<span id="cb410-4"><a href="#cb410-4"></a>    tests := []vmTestCase {</span>
<span id="cb410-5"><a href="#cb410-5"></a>        <span class="co">// [...]</span></span>
<span id="cb410-6"><a href="#cb410-6"></a>        {</span>
<span id="cb410-7"><a href="#cb410-7"></a>            input: <span class="st">`</span></span>
<span id="cb410-8"><a href="#cb410-8"></a><span class="st">        let globalNum = 10;</span></span>
<span id="cb410-9"><a href="#cb410-9"></a></span>
<span id="cb410-10"><a href="#cb410-10"></a><span class="st">        let sum = fn(a, b) {</span></span>
<span id="cb410-11"><a href="#cb410-11"></a><span class="st">            let c = a + b;</span></span>
<span id="cb410-12"><a href="#cb410-12"></a><span class="st">            c + globalNum;</span></span>
<span id="cb410-13"><a href="#cb410-13"></a><span class="st">        };</span></span>
<span id="cb410-14"><a href="#cb410-14"></a></span>
<span id="cb410-15"><a href="#cb410-15"></a><span class="st">        let outer = fn() {</span></span>
<span id="cb410-16"><a href="#cb410-16"></a><span class="st">            sum(1, 2) + sum(3, 4) + globalNum;</span></span>
<span id="cb410-17"><a href="#cb410-17"></a><span class="st">        };</span></span>
<span id="cb410-18"><a href="#cb410-18"></a></span>
<span id="cb410-19"><a href="#cb410-19"></a><span class="st">        outer() + globalNum;</span></span>
<span id="cb410-20"><a href="#cb410-20"></a><span class="st">        `</span>,</span>
<span id="cb410-21"><a href="#cb410-21"></a>            expected: <span class="dv">50</span>,</span>
<span id="cb410-22"><a href="#cb410-22"></a>        },</span>
<span id="cb410-23"><a href="#cb410-23"></a>    }</span>
<span id="cb410-24"><a href="#cb410-24"></a></span>
<span id="cb410-25"><a href="#cb410-25"></a>    runVmTests(t, tests)</span>
<span id="cb410-26"><a href="#cb410-26"></a>}</span></code></pre></div>
<p>Running this test will tell us:</p>
<div class="sourceCode" id="cb411"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb411-1"><a href="#cb411-1"></a>$ go test ./vm</span>
<span id="cb411-2"><a href="#cb411-2"></a>ok      monkey/vm   0.035s</span></code></pre></div>
<p>Yes, we did! We’ve successfully added function call arguments to our compiler and our VM!</p>
<p>Now we just need to make sure that the stack doesn’t come tumbling down when we call a function with the wrong number of arguments, since a lot of our implementation hinges on that number:</p>
<div class="sourceCode" id="cb412"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb412-1"><a href="#cb412-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb412-2"><a href="#cb412-2"></a></span>
<span id="cb412-3"><a href="#cb412-3"></a><span class="kw">func</span> TestCallingFunctionsWithWrongArguments(t *testing.T) {</span>
<span id="cb412-4"><a href="#cb412-4"></a>    tests := []vmTestCase{</span>
<span id="cb412-5"><a href="#cb412-5"></a>        {</span>
<span id="cb412-6"><a href="#cb412-6"></a>            input:    <span class="st">`fn() { 1; }(1);`</span>,</span>
<span id="cb412-7"><a href="#cb412-7"></a>            expected: <span class="st">`wrong number of arguments: want=0, got=1`</span>,</span>
<span id="cb412-8"><a href="#cb412-8"></a>        },</span>
<span id="cb412-9"><a href="#cb412-9"></a>        {</span>
<span id="cb412-10"><a href="#cb412-10"></a>            input:    <span class="st">`fn(a) { a; }();`</span>,</span>
<span id="cb412-11"><a href="#cb412-11"></a>            expected: <span class="st">`wrong number of arguments: want=1, got=0`</span>,</span>
<span id="cb412-12"><a href="#cb412-12"></a>        },</span>
<span id="cb412-13"><a href="#cb412-13"></a>        {</span>
<span id="cb412-14"><a href="#cb412-14"></a>            input:    <span class="st">`fn(a, b) { a + b; }(1);`</span>,</span>
<span id="cb412-15"><a href="#cb412-15"></a>            expected: <span class="st">`wrong number of arguments: want=2, got=1`</span>,</span>
<span id="cb412-16"><a href="#cb412-16"></a>        },</span>
<span id="cb412-17"><a href="#cb412-17"></a>    }</span>
<span id="cb412-18"><a href="#cb412-18"></a></span>
<span id="cb412-19"><a href="#cb412-19"></a>    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</span>
<span id="cb412-20"><a href="#cb412-20"></a>        program := parse(tt.input)</span>
<span id="cb412-21"><a href="#cb412-21"></a></span>
<span id="cb412-22"><a href="#cb412-22"></a>        comp := compiler.New()</span>
<span id="cb412-23"><a href="#cb412-23"></a>        err := comp.Compile(program)</span>
<span id="cb412-24"><a href="#cb412-24"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb412-25"><a href="#cb412-25"></a>            t.Fatalf(<span class="st">&quot;compiler error: %s&quot;</span>, err)</span>
<span id="cb412-26"><a href="#cb412-26"></a>        }</span>
<span id="cb412-27"><a href="#cb412-27"></a></span>
<span id="cb412-28"><a href="#cb412-28"></a>        vm := New(comp.Bytecode())</span>
<span id="cb412-29"><a href="#cb412-29"></a>        err = vm.Run()</span>
<span id="cb412-30"><a href="#cb412-30"></a>        <span class="kw">if</span> err == <span class="ot">nil</span> {</span>
<span id="cb412-31"><a href="#cb412-31"></a>            t.Fatalf(<span class="st">&quot;expected VM error but resulted in none.&quot;</span>)</span>
<span id="cb412-32"><a href="#cb412-32"></a>        }</span>
<span id="cb412-33"><a href="#cb412-33"></a></span>
<span id="cb412-34"><a href="#cb412-34"></a>        <span class="kw">if</span> err.Error() != tt.expected {</span>
<span id="cb412-35"><a href="#cb412-35"></a>            t.Fatalf(<span class="st">&quot;wrong VM error: want=%q, got=%q&quot;</span>, tt.expected, err)</span>
<span id="cb412-36"><a href="#cb412-36"></a>        }</span>
<span id="cb412-37"><a href="#cb412-37"></a>    }</span>
<span id="cb412-38"><a href="#cb412-38"></a>}</span></code></pre></div>
<p>We want to make sure that we get a VM error when we call a function with the wrong number of arguments. So, yes, this time we <em>want</em> an error, but get none:</p>
<div class="sourceCode" id="cb413"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb413-1"><a href="#cb413-1"></a>$ go test ./vm</span>
<span id="cb413-2"><a href="#cb413-2"></a>--- FAIL: TestCallingFunctionsWithWrongArguments (0.00s)</span>
<span id="cb413-3"><a href="#cb413-3"></a> vm_test.go:801: expected VM error but resulted in none.</span>
<span id="cb413-4"><a href="#cb413-4"></a>FAIL</span>
<span id="cb413-5"><a href="#cb413-5"></a>FAIL    monkey/vm   0.053s</span></code></pre></div>
<p>To fix that we need to make quick trip to the <code>object</code> package and add a new field to the definition of <code>object.CompiledFunction</code>:</p>
<div class="sourceCode" id="cb414"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb414-1"><a href="#cb414-1"></a><span class="co">// object/object.go</span></span>
<span id="cb414-2"><a href="#cb414-2"></a></span>
<span id="cb414-3"><a href="#cb414-3"></a><span class="kw">type</span> CompiledFunction <span class="kw">struct</span> {</span>
<span id="cb414-4"><a href="#cb414-4"></a>    Instructions  code.Instructions</span>
<span id="cb414-5"><a href="#cb414-5"></a>    NumLocals     <span class="dt">int</span></span>
<span id="cb414-6"><a href="#cb414-6"></a>    NumParameters <span class="dt">int</span></span>
<span id="cb414-7"><a href="#cb414-7"></a>}</span></code></pre></div>
<p>We’ll now fill out this new <code>NumParameters</code> field in the compiler, where we have the number of parameters of a function literal at hand:</p>
<div class="sourceCode" id="cb415"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb415-1"><a href="#cb415-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb415-2"><a href="#cb415-2"></a></span>
<span id="cb415-3"><a href="#cb415-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb415-4"><a href="#cb415-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb415-5"><a href="#cb415-5"></a>    <span class="co">// [...]</span></span>
<span id="cb415-6"><a href="#cb415-6"></a></span>
<span id="cb415-7"><a href="#cb415-7"></a>    <span class="kw">case</span> *ast.FunctionLiteral:</span>
<span id="cb415-8"><a href="#cb415-8"></a>        <span class="co">// [...]</span></span>
<span id="cb415-9"><a href="#cb415-9"></a></span>
<span id="cb415-10"><a href="#cb415-10"></a>        compiledFn := &amp;object.CompiledFunction{</span>
<span id="cb415-11"><a href="#cb415-11"></a>            Instructions:  instructions,</span>
<span id="cb415-12"><a href="#cb415-12"></a>            NumLocals:     numLocals,</span>
<span id="cb415-13"><a href="#cb415-13"></a>            NumParameters: <span class="bu">len</span>(node.Parameters),</span>
<span id="cb415-14"><a href="#cb415-14"></a>        }</span>
<span id="cb415-15"><a href="#cb415-15"></a>        c.emit(code.OpConstant, c.addConstant(compiledFn))</span>
<span id="cb415-16"><a href="#cb415-16"></a></span>
<span id="cb415-17"><a href="#cb415-17"></a>    <span class="co">// [...]</span></span>
<span id="cb415-18"><a href="#cb415-18"></a>    }</span>
<span id="cb415-19"><a href="#cb415-19"></a></span>
<span id="cb415-20"><a href="#cb415-20"></a>    <span class="co">// [...]</span></span>
<span id="cb415-21"><a href="#cb415-21"></a>}</span></code></pre></div>
<p>In the VM we can use that field to make sure that we have the right number of arguments sitting on the stack:</p>
<div class="sourceCode" id="cb416"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb416-1"><a href="#cb416-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb416-2"><a href="#cb416-2"></a></span>
<span id="cb416-3"><a href="#cb416-3"></a><span class="kw">func</span> (vm *VM) callFunction(numArgs <span class="dt">int</span>) <span class="dt">error</span> {</span>
<span id="cb416-4"><a href="#cb416-4"></a>    fn, ok := vm.stack[vm.sp<span class="dv">-1</span>-numArgs].(*object.CompiledFunction)</span>
<span id="cb416-5"><a href="#cb416-5"></a>    <span class="kw">if</span> !ok {</span>
<span id="cb416-6"><a href="#cb416-6"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;calling non-function&quot;</span>)</span>
<span id="cb416-7"><a href="#cb416-7"></a>    }</span>
<span id="cb416-8"><a href="#cb416-8"></a></span>
<span id="cb416-9"><a href="#cb416-9"></a>    <span class="kw">if</span> numArgs != fn.NumParameters {</span>
<span id="cb416-10"><a href="#cb416-10"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;wrong number of arguments: want=%d, got=%d&quot;</span>,</span>
<span id="cb416-11"><a href="#cb416-11"></a>            fn.NumParameters, numArgs)</span>
<span id="cb416-12"><a href="#cb416-12"></a>    }</span>
<span id="cb416-13"><a href="#cb416-13"></a></span>
<span id="cb416-14"><a href="#cb416-14"></a>    <span class="co">// [...]</span></span>
<span id="cb416-15"><a href="#cb416-15"></a>}</span></code></pre></div>
<p>With that, we’re in safe territory:</p>
<div class="sourceCode" id="cb417"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb417-1"><a href="#cb417-1"></a>$ go test ./vm</span>
<span id="cb417-2"><a href="#cb417-2"></a>ok      monkey/vm       0.035s</span></code></pre></div>
<p>The stack will hold, even if we call a function with the wrong number of arguments.</p>
<p>Now we can enjoy the fact that we’ve implement functions and function calls in a bytecode compiler and VM, including arguments and local bindings. That’s certainly no small feat and puts us, again, in another league:</p>
<div class="sourceCode" id="cb418"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb418-1"><a href="#cb418-1"></a>$ go build -o monkey . &amp;&amp; ./monkey</span>
<span id="cb418-2"><a href="#cb418-2"></a>Hello mrnugget! This is the Monkey programming language!</span>
<span id="cb418-3"><a href="#cb418-3"></a>Feel free to type in commands</span>
<span id="cb418-4"><a href="#cb418-4"></a>&gt;&gt; let one = fn() { 1; };</span>
<span id="cb418-5"><a href="#cb418-5"></a>CompiledFunction[0xc42008a8d0]</span>
<span id="cb418-6"><a href="#cb418-6"></a>&gt;&gt; let two = fn() { let result = one(); return result + result; };</span>
<span id="cb418-7"><a href="#cb418-7"></a>CompiledFunction[0xc42008aba0]</span>
<span id="cb418-8"><a href="#cb418-8"></a>&gt;&gt; let three = fn(two) { two() + 1; };</span>
<span id="cb418-9"><a href="#cb418-9"></a>CompiledFunction[0xc42008ae40]</span>
<span id="cb418-10"><a href="#cb418-10"></a>&gt;&gt; three(two);</span>
<span id="cb418-11"><a href="#cb418-11"></a>3</span></code></pre></div>
<p>Time to add another type of function.</p>
<h1 id="built-in-functions">Built-in Functions</h1>
<p>In <em>Writing An Interpreter In Go</em> we did not only add the ability to define functions to our evaluator, but we also built functions right into it. These functions here:</p>
<div class="sourceCode" id="cb419"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb419-1"><a href="#cb419-1"></a>len([<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>])<span class="op">;</span>       <span class="co">// =&gt; 3</span></span>
<span id="cb419-2"><a href="#cb419-2"></a>first([<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>])<span class="op">;</span>     <span class="co">// =&gt; 1</span></span>
<span id="cb419-3"><a href="#cb419-3"></a>last([<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>])<span class="op">;</span>      <span class="co">// =&gt; 3</span></span>
<span id="cb419-4"><a href="#cb419-4"></a>rest([<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>])<span class="op">;</span>      <span class="co">// =&gt; [2, 3]</span></span>
<span id="cb419-5"><a href="#cb419-5"></a>push([<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">,</span> <span class="dv">4</span>)<span class="op">;</span>   <span class="co">// =&gt; [1, 2, 3, 4]</span></span>
<span id="cb419-6"><a href="#cb419-6"></a>puts(<span class="st">&quot;Hello World!&quot;</span>)<span class="op">;</span> <span class="co">// prints &quot;Hello World!&quot;</span></span></code></pre></div>
<p>Our goal for this chapter is to do the same for our new bytecode compiler and virtual machine and build these functions into them. That’s not as easy as one might think.</p>
<p>While these are Go functions and thus should be as portable as any other function we wrote, they took roots in the <code>evaluator</code> package. They’re defined as private, they use internal references and make use of private helper functions – not the best circumstances for using them in the <code>compiler</code> and the <code>vm</code> packages.</p>
<p>So, before we can start to think about executing these built-in functions in the VM, or even mention them in the compiler, we need to refactor some of our code from the previous book to make it easier for our new code to use it.</p>
<p>The obvious, first option is to make the function definitions public. Uppercase their names, done. That would work, yes, but it would also clash with something delicate – my taste. I don’t want the compiler nor the VM to depend on the evaluator, which is what this course of action would lead to. Instead, I want all three packages – <code>compiler</code>, <code>vm</code> and <code>evaluator</code> – to have equal access to the built-in functions.</p>
<p>That leads us to the second option: duplicate the definitions, keep one copy for the <code>evaluator</code> and create one for the <code>vm</code> and <code>compiler</code> packages. But then again, we’re programmers, we do not like duplication. In all seriousness, though: duplicating these built-in functions <em>would</em> be a bad idea. Encoded in them is a non-trivial amount of Monkey behaviour, which we don’t want to accidentally fork and diverge.</p>
<p>Instead, we’re going to move these built-in functions to the <code>object</code> package. That takes slightly more effort, but it’s also the most elegant choice, since it makes incorporating the built-in functions into the compiler and the VM much easier later on.</p>
<h2 id="making-the-change-easy">Making the Change Easy</h2>
<p>So, here’s the first task: move the built-in functions out of the <code>evaluator</code> package while keeping the <code>evaluator</code> working. Attached to that is a little sidequest: while moving them, we need to define the built-in functions so that we can use an index to access a single function and iterate through them <em>in a stable way</em>. The <code>builtins</code> we currently have in <code>evaluator</code> is a <code>map[string]*object.Builtin</code>, which gives us the indexing but not the guarantee of stable iteration.</p>
<p>Instead of a <code>map</code> we’re going to use a slice of structs in which we can pair an <code>*object.Builtin</code> with its name. That gives us stable iteration and, with the help of a small function, allows us to fetch a single function by name.</p>
<p>Doing this instead of simply cutting and pasting the existing <code>evaluator.builtins</code> definition, also gives us a chance to refreshen our memory by taking a look at each built-in function again.</p>
<p>Let’s start with <code>len</code>. It returns the length of an array or a string. We create a new file, <code>object/builtins.go</code>, and copy the definition of <code>len</code> from <code>evaluator/builtins.go</code> to the new file. Like this:</p>
<div class="sourceCode" id="cb420"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb420-1"><a href="#cb420-1"></a><span class="co">// object/builtins.go</span></span>
<span id="cb420-2"><a href="#cb420-2"></a></span>
<span id="cb420-3"><a href="#cb420-3"></a><span class="kw">package</span> object</span>
<span id="cb420-4"><a href="#cb420-4"></a></span>
<span id="cb420-5"><a href="#cb420-5"></a><span class="kw">import</span> <span class="st">&quot;fmt&quot;</span></span>
<span id="cb420-6"><a href="#cb420-6"></a></span>
<span id="cb420-7"><a href="#cb420-7"></a><span class="kw">var</span> Builtins = []<span class="kw">struct</span> {</span>
<span id="cb420-8"><a href="#cb420-8"></a>    Name    <span class="dt">string</span></span>
<span id="cb420-9"><a href="#cb420-9"></a>    Builtin *Builtin</span>
<span id="cb420-10"><a href="#cb420-10"></a>}{</span>
<span id="cb420-11"><a href="#cb420-11"></a>    {</span>
<span id="cb420-12"><a href="#cb420-12"></a>        <span class="st">&quot;len&quot;</span>,</span>
<span id="cb420-13"><a href="#cb420-13"></a>        &amp;Builtin{Fn: <span class="kw">func</span>(args ...Object) Object {</span>
<span id="cb420-14"><a href="#cb420-14"></a>            <span class="kw">if</span> <span class="bu">len</span>(args) != <span class="dv">1</span> {</span>
<span id="cb420-15"><a href="#cb420-15"></a>                <span class="kw">return</span> newError(<span class="st">&quot;wrong number of arguments. got=%d, want=1&quot;</span>,</span>
<span id="cb420-16"><a href="#cb420-16"></a>                    <span class="bu">len</span>(args))</span>
<span id="cb420-17"><a href="#cb420-17"></a>            }</span>
<span id="cb420-18"><a href="#cb420-18"></a></span>
<span id="cb420-19"><a href="#cb420-19"></a>            <span class="kw">switch</span> arg := args[<span class="dv">0</span>].(<span class="kw">type</span>) {</span>
<span id="cb420-20"><a href="#cb420-20"></a>            <span class="kw">case</span> *Array:</span>
<span id="cb420-21"><a href="#cb420-21"></a>                <span class="kw">return</span> &amp;Integer{Value: <span class="dt">int64</span>(<span class="bu">len</span>(arg.Elements))}</span>
<span id="cb420-22"><a href="#cb420-22"></a>            <span class="kw">case</span> *String:</span>
<span id="cb420-23"><a href="#cb420-23"></a>                <span class="kw">return</span> &amp;Integer{Value: <span class="dt">int64</span>(<span class="bu">len</span>(arg.Value))}</span>
<span id="cb420-24"><a href="#cb420-24"></a>            <span class="kw">default</span>:</span>
<span id="cb420-25"><a href="#cb420-25"></a>                <span class="kw">return</span> newError(<span class="st">&quot;argument to `len` not supported, got %s&quot;</span>,</span>
<span id="cb420-26"><a href="#cb420-26"></a>                    args[<span class="dv">0</span>].Type())</span>
<span id="cb420-27"><a href="#cb420-27"></a>            }</span>
<span id="cb420-28"><a href="#cb420-28"></a>        },</span>
<span id="cb420-29"><a href="#cb420-29"></a>        },</span>
<span id="cb420-30"><a href="#cb420-30"></a>    },</span>
<span id="cb420-31"><a href="#cb420-31"></a>}</span>
<span id="cb420-32"><a href="#cb420-32"></a></span>
<span id="cb420-33"><a href="#cb420-33"></a><span class="kw">func</span> newError(format <span class="dt">string</span>, a ...<span class="kw">interface</span>{}) *Error {</span>
<span id="cb420-34"><a href="#cb420-34"></a>    <span class="kw">return</span> &amp;Error{Message: fmt.Sprintf(format, a...)}</span>
<span id="cb420-35"><a href="#cb420-35"></a>}</span></code></pre></div>
<p><code>Builtins</code> is a slice of structs, where each struct contains the <code>name</code> and the <code>*Builtin</code> function itself.</p>
<p>While we did copy the <code>*Builtin</code> with the name <code>len</code>, please note that this is not mindless copy and pasting: in the <code>*Builtin</code> itself we had to remove references to the <code>object</code> package. They’re redundant now that we’re in <code>object</code>.</p>
<p>The <code>newError</code> function we also had to copy over since it’s heavily used by most of the built-in functions.</p>
<p>With <code>Builtins</code> defined and containing its first definition, we can now add a function called <code>GetBuiltinByName</code>:</p>
<div class="sourceCode" id="cb421"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb421-1"><a href="#cb421-1"></a><span class="co">// object/builtins.go</span></span>
<span id="cb421-2"><a href="#cb421-2"></a></span>
<span id="cb421-3"><a href="#cb421-3"></a><span class="kw">func</span> GetBuiltinByName(name <span class="dt">string</span>) *Builtin {</span>
<span id="cb421-4"><a href="#cb421-4"></a>    <span class="kw">for</span> _, def := <span class="kw">range</span> Builtins {</span>
<span id="cb421-5"><a href="#cb421-5"></a>        <span class="kw">if</span> def.Name == name {</span>
<span id="cb421-6"><a href="#cb421-6"></a>            <span class="kw">return</span> def.Builtin</span>
<span id="cb421-7"><a href="#cb421-7"></a>        }</span>
<span id="cb421-8"><a href="#cb421-8"></a>    }</span>
<span id="cb421-9"><a href="#cb421-9"></a>    <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb421-10"><a href="#cb421-10"></a>}</span></code></pre></div>
<p>There’s not much to explain here. It’s a function that allows us to fetch a built-in function by name. But with this in place, we can get rid of the duplication in <code>evaluator/builtins.go</code> and replace the old definition of <code>len</code> with this:</p>
<div class="sourceCode" id="cb422"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb422-1"><a href="#cb422-1"></a><span class="co">// evaluator/builtins.go</span></span>
<span id="cb422-2"><a href="#cb422-2"></a></span>
<span id="cb422-3"><a href="#cb422-3"></a><span class="kw">var</span> builtins = <span class="kw">map</span>[<span class="dt">string</span>]*object.Builtin{</span>
<span id="cb422-4"><a href="#cb422-4"></a>    <span class="st">&quot;len&quot;</span>: object.GetBuiltinByName(<span class="st">&quot;len&quot;</span>),</span>
<span id="cb422-5"><a href="#cb422-5"></a>    <span class="co">// [...]</span></span>
<span id="cb422-6"><a href="#cb422-6"></a>}</span></code></pre></div>
<p>That’s our first built-in function moved. Congratulations! And, look at that, the tests of the <code>evaluator</code> package are still working:</p>
<div class="sourceCode" id="cb423"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb423-1"><a href="#cb423-1"></a>$ go test ./evaluator</span>
<span id="cb423-2"><a href="#cb423-2"></a>ok      monkey/evaluator    0.009s</span></code></pre></div>
<p>Great! Now we can do the same for each function in <code>evaluator.builtins</code>. Next up is <code>puts</code>, which prints its arguments:</p>
<div class="sourceCode" id="cb424"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb424-1"><a href="#cb424-1"></a><span class="co">// object/builtins.go</span></span>
<span id="cb424-2"><a href="#cb424-2"></a></span>
<span id="cb424-3"><a href="#cb424-3"></a><span class="kw">var</span> Builtins = []<span class="kw">struct</span> {</span>
<span id="cb424-4"><a href="#cb424-4"></a>    Name    <span class="dt">string</span></span>
<span id="cb424-5"><a href="#cb424-5"></a>    Builtin *Builtin</span>
<span id="cb424-6"><a href="#cb424-6"></a>}{</span>
<span id="cb424-7"><a href="#cb424-7"></a>    <span class="co">// [...]</span></span>
<span id="cb424-8"><a href="#cb424-8"></a>    {</span>
<span id="cb424-9"><a href="#cb424-9"></a>        <span class="st">&quot;puts&quot;</span>,</span>
<span id="cb424-10"><a href="#cb424-10"></a>        &amp;Builtin{Fn: <span class="kw">func</span>(args ...Object) Object {</span>
<span id="cb424-11"><a href="#cb424-11"></a>            <span class="kw">for</span> _, arg := <span class="kw">range</span> args {</span>
<span id="cb424-12"><a href="#cb424-12"></a>                fmt.Println(arg.Inspect())</span>
<span id="cb424-13"><a href="#cb424-13"></a>            }</span>
<span id="cb424-14"><a href="#cb424-14"></a></span>
<span id="cb424-15"><a href="#cb424-15"></a>            <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb424-16"><a href="#cb424-16"></a>        },</span>
<span id="cb424-17"><a href="#cb424-17"></a>        },</span>
<span id="cb424-18"><a href="#cb424-18"></a>    },</span>
<span id="cb424-19"><a href="#cb424-19"></a>}</span></code></pre></div>
<p>Even though it doesn’t look like much, this new definition of <code>puts</code> contains one crucial change.</p>
<p>In its definition in the <code>evaluator</code> package, <code>puts</code> returns <code>evaluator.NULL</code>. That’s the evaluator’s counterpart to the VM’s <code>vm.Null</code>. But since keeping the reference to <code>evaluator.NULL</code> would mean juggling around two instances of <code>*object.Null</code> in the VM, we change <code>puts</code> to instead return <code>nil</code>.</p>
<p>That’s easy to replace with <code>vm.Null</code> once we’re in the VM. But since we want to use the new definition of <code>puts</code> in the evaluator too, we need to change the existing code to now check for <code>nil</code> and turn it into <code>NULL</code> if necessary:</p>
<div class="sourceCode" id="cb425"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb425-1"><a href="#cb425-1"></a><span class="co">// evaluator/evaluator.go</span></span>
<span id="cb425-2"><a href="#cb425-2"></a></span>
<span id="cb425-3"><a href="#cb425-3"></a><span class="kw">func</span> applyFunction(fn object.Object, args []object.Object) object.Object {</span>
<span id="cb425-4"><a href="#cb425-4"></a>    <span class="kw">switch</span> fn := fn.(<span class="kw">type</span>) {</span>
<span id="cb425-5"><a href="#cb425-5"></a></span>
<span id="cb425-6"><a href="#cb425-6"></a>    <span class="co">// [...]</span></span>
<span id="cb425-7"><a href="#cb425-7"></a></span>
<span id="cb425-8"><a href="#cb425-8"></a>    <span class="kw">case</span> *object.Builtin:</span>
<span id="cb425-9"><a href="#cb425-9"></a>        <span class="kw">if</span> result := fn.Fn(args...); result != <span class="ot">nil</span> {</span>
<span id="cb425-10"><a href="#cb425-10"></a>            <span class="kw">return</span> result</span>
<span id="cb425-11"><a href="#cb425-11"></a>        }</span>
<span id="cb425-12"><a href="#cb425-12"></a>        <span class="kw">return</span> NULL</span>
<span id="cb425-13"><a href="#cb425-13"></a></span>
<span id="cb425-14"><a href="#cb425-14"></a>    <span class="co">// [...]</span></span>
<span id="cb425-15"><a href="#cb425-15"></a>    }</span>
<span id="cb425-16"><a href="#cb425-16"></a>}</span></code></pre></div>
<p>The next function to move is <code>first</code>, which returns the first element of an array. It has to undergo the same treatment as <code>puts</code>: copy it from <code>evaluator/builtins.go</code> to <code>object/builtins.go</code>, remove references to the <code>object</code> package and return <code>nil</code> where it previously returned <code>evaluator.NULL</code>:</p>
<div class="sourceCode" id="cb426"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb426-1"><a href="#cb426-1"></a><span class="co">// object/builtins.go</span></span>
<span id="cb426-2"><a href="#cb426-2"></a></span>
<span id="cb426-3"><a href="#cb426-3"></a><span class="kw">var</span> Builtins = []<span class="kw">struct</span> {</span>
<span id="cb426-4"><a href="#cb426-4"></a>    Name    <span class="dt">string</span></span>
<span id="cb426-5"><a href="#cb426-5"></a>    Builtin *Builtin</span>
<span id="cb426-6"><a href="#cb426-6"></a>}{</span>
<span id="cb426-7"><a href="#cb426-7"></a>    <span class="co">// [...]</span></span>
<span id="cb426-8"><a href="#cb426-8"></a>    {</span>
<span id="cb426-9"><a href="#cb426-9"></a>        <span class="st">&quot;first&quot;</span>,</span>
<span id="cb426-10"><a href="#cb426-10"></a>        &amp;Builtin{Fn: <span class="kw">func</span>(args ...Object) Object {</span>
<span id="cb426-11"><a href="#cb426-11"></a>            <span class="kw">if</span> <span class="bu">len</span>(args) != <span class="dv">1</span> {</span>
<span id="cb426-12"><a href="#cb426-12"></a>                <span class="kw">return</span> newError(<span class="st">&quot;wrong number of arguments. got=%d, want=1&quot;</span>,</span>
<span id="cb426-13"><a href="#cb426-13"></a>                    <span class="bu">len</span>(args))</span>
<span id="cb426-14"><a href="#cb426-14"></a>            }</span>
<span id="cb426-15"><a href="#cb426-15"></a>            <span class="kw">if</span> args[<span class="dv">0</span>].Type() != ARRAY_OBJ {</span>
<span id="cb426-16"><a href="#cb426-16"></a>                <span class="kw">return</span> newError(<span class="st">&quot;argument to `first` must be ARRAY, got %s&quot;</span>,</span>
<span id="cb426-17"><a href="#cb426-17"></a>                    args[<span class="dv">0</span>].Type())</span>
<span id="cb426-18"><a href="#cb426-18"></a>            }</span>
<span id="cb426-19"><a href="#cb426-19"></a></span>
<span id="cb426-20"><a href="#cb426-20"></a>            arr := args[<span class="dv">0</span>].(*Array)</span>
<span id="cb426-21"><a href="#cb426-21"></a>            <span class="kw">if</span> <span class="bu">len</span>(arr.Elements) &gt; <span class="dv">0</span> {</span>
<span id="cb426-22"><a href="#cb426-22"></a>                <span class="kw">return</span> arr.Elements[<span class="dv">0</span>]</span>
<span id="cb426-23"><a href="#cb426-23"></a>            }</span>
<span id="cb426-24"><a href="#cb426-24"></a></span>
<span id="cb426-25"><a href="#cb426-25"></a>            <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb426-26"><a href="#cb426-26"></a>        },</span>
<span id="cb426-27"><a href="#cb426-27"></a>        },</span>
<span id="cb426-28"><a href="#cb426-28"></a>    },</span>
<span id="cb426-29"><a href="#cb426-29"></a>}</span></code></pre></div>
<p>Of course, we also defined a <code>last</code> function, for which we have to follow the same recipe:</p>
<div class="sourceCode" id="cb427"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb427-1"><a href="#cb427-1"></a><span class="co">// object/builtins.go</span></span>
<span id="cb427-2"><a href="#cb427-2"></a></span>
<span id="cb427-3"><a href="#cb427-3"></a><span class="kw">var</span> Builtins = []<span class="kw">struct</span> {</span>
<span id="cb427-4"><a href="#cb427-4"></a>    Name    <span class="dt">string</span></span>
<span id="cb427-5"><a href="#cb427-5"></a>    Builtin *Builtin</span>
<span id="cb427-6"><a href="#cb427-6"></a>}{</span>
<span id="cb427-7"><a href="#cb427-7"></a>    <span class="co">// [...]</span></span>
<span id="cb427-8"><a href="#cb427-8"></a>    {</span>
<span id="cb427-9"><a href="#cb427-9"></a>        <span class="st">&quot;last&quot;</span>,</span>
<span id="cb427-10"><a href="#cb427-10"></a>        &amp;Builtin{Fn: <span class="kw">func</span>(args ...Object) Object {</span>
<span id="cb427-11"><a href="#cb427-11"></a>            <span class="kw">if</span> <span class="bu">len</span>(args) != <span class="dv">1</span> {</span>
<span id="cb427-12"><a href="#cb427-12"></a>                <span class="kw">return</span> newError(<span class="st">&quot;wrong number of arguments. got=%d, want=1&quot;</span>,</span>
<span id="cb427-13"><a href="#cb427-13"></a>                    <span class="bu">len</span>(args))</span>
<span id="cb427-14"><a href="#cb427-14"></a>            }</span>
<span id="cb427-15"><a href="#cb427-15"></a>            <span class="kw">if</span> args[<span class="dv">0</span>].Type() != ARRAY_OBJ {</span>
<span id="cb427-16"><a href="#cb427-16"></a>                <span class="kw">return</span> newError(<span class="st">&quot;argument to `last` must be ARRAY, got %s&quot;</span>,</span>
<span id="cb427-17"><a href="#cb427-17"></a>                    args[<span class="dv">0</span>].Type())</span>
<span id="cb427-18"><a href="#cb427-18"></a>            }</span>
<span id="cb427-19"><a href="#cb427-19"></a></span>
<span id="cb427-20"><a href="#cb427-20"></a>            arr := args[<span class="dv">0</span>].(*Array)</span>
<span id="cb427-21"><a href="#cb427-21"></a>            length := <span class="bu">len</span>(arr.Elements)</span>
<span id="cb427-22"><a href="#cb427-22"></a>            <span class="kw">if</span> length &gt; <span class="dv">0</span> {</span>
<span id="cb427-23"><a href="#cb427-23"></a>                <span class="kw">return</span> arr.Elements[length<span class="dv">-1</span>]</span>
<span id="cb427-24"><a href="#cb427-24"></a>            }</span>
<span id="cb427-25"><a href="#cb427-25"></a></span>
<span id="cb427-26"><a href="#cb427-26"></a>            <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb427-27"><a href="#cb427-27"></a>        },</span>
<span id="cb427-28"><a href="#cb427-28"></a>        },</span>
<span id="cb427-29"><a href="#cb427-29"></a>    },</span>
<span id="cb427-30"><a href="#cb427-30"></a>}</span></code></pre></div>
<p>Besides getting the first and last elements of an array, it’s sometimes really useful to get every element except the first one, which is why we have <code>rest</code>:</p>
<div class="sourceCode" id="cb428"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb428-1"><a href="#cb428-1"></a><span class="co">// object/builtins.go</span></span>
<span id="cb428-2"><a href="#cb428-2"></a></span>
<span id="cb428-3"><a href="#cb428-3"></a><span class="kw">var</span> Builtins = []<span class="kw">struct</span> {</span>
<span id="cb428-4"><a href="#cb428-4"></a>    Name    <span class="dt">string</span></span>
<span id="cb428-5"><a href="#cb428-5"></a>    Builtin *Builtin</span>
<span id="cb428-6"><a href="#cb428-6"></a>}{</span>
<span id="cb428-7"><a href="#cb428-7"></a>    <span class="co">// [...]</span></span>
<span id="cb428-8"><a href="#cb428-8"></a>    {</span>
<span id="cb428-9"><a href="#cb428-9"></a>        <span class="st">&quot;rest&quot;</span>,</span>
<span id="cb428-10"><a href="#cb428-10"></a>        &amp;Builtin{Fn: <span class="kw">func</span>(args ...Object) Object {</span>
<span id="cb428-11"><a href="#cb428-11"></a>            <span class="kw">if</span> <span class="bu">len</span>(args) != <span class="dv">1</span> {</span>
<span id="cb428-12"><a href="#cb428-12"></a>                <span class="kw">return</span> newError(<span class="st">&quot;wrong number of arguments. got=%d, want=1&quot;</span>,</span>
<span id="cb428-13"><a href="#cb428-13"></a>                    <span class="bu">len</span>(args))</span>
<span id="cb428-14"><a href="#cb428-14"></a>            }</span>
<span id="cb428-15"><a href="#cb428-15"></a>            <span class="kw">if</span> args[<span class="dv">0</span>].Type() != ARRAY_OBJ {</span>
<span id="cb428-16"><a href="#cb428-16"></a>                <span class="kw">return</span> newError(<span class="st">&quot;argument to `rest` must be ARRAY, got %s&quot;</span>,</span>
<span id="cb428-17"><a href="#cb428-17"></a>                    args[<span class="dv">0</span>].Type())</span>
<span id="cb428-18"><a href="#cb428-18"></a>            }</span>
<span id="cb428-19"><a href="#cb428-19"></a></span>
<span id="cb428-20"><a href="#cb428-20"></a>            arr := args[<span class="dv">0</span>].(*Array)</span>
<span id="cb428-21"><a href="#cb428-21"></a>            length := <span class="bu">len</span>(arr.Elements)</span>
<span id="cb428-22"><a href="#cb428-22"></a>            <span class="kw">if</span> length &gt; <span class="dv">0</span> {</span>
<span id="cb428-23"><a href="#cb428-23"></a>                newElements := <span class="bu">make</span>([]Object, length<span class="dv">-1</span>, length<span class="dv">-1</span>)</span>
<span id="cb428-24"><a href="#cb428-24"></a>                <span class="bu">copy</span>(newElements, arr.Elements[<span class="dv">1</span>:length])</span>
<span id="cb428-25"><a href="#cb428-25"></a>                <span class="kw">return</span> &amp;Array{Elements: newElements}</span>
<span id="cb428-26"><a href="#cb428-26"></a>            }</span>
<span id="cb428-27"><a href="#cb428-27"></a></span>
<span id="cb428-28"><a href="#cb428-28"></a>            <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb428-29"><a href="#cb428-29"></a>        },</span>
<span id="cb428-30"><a href="#cb428-30"></a>        },</span>
<span id="cb428-31"><a href="#cb428-31"></a>    },</span>
<span id="cb428-32"><a href="#cb428-32"></a>}</span></code></pre></div>
<p>And then we define <code>push</code>, which adds an element to an array. It doesn’t mutate the array, but instead leaves it untouched and allocates a new one, containing the elements of the original array and the addition:</p>
<div class="sourceCode" id="cb429"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb429-1"><a href="#cb429-1"></a><span class="co">// object/builtins.go</span></span>
<span id="cb429-2"><a href="#cb429-2"></a></span>
<span id="cb429-3"><a href="#cb429-3"></a><span class="kw">var</span> Builtins = []<span class="kw">struct</span> {</span>
<span id="cb429-4"><a href="#cb429-4"></a>    Name    <span class="dt">string</span></span>
<span id="cb429-5"><a href="#cb429-5"></a>    Builtin *Builtin</span>
<span id="cb429-6"><a href="#cb429-6"></a>}{</span>
<span id="cb429-7"><a href="#cb429-7"></a>    <span class="co">// [...]</span></span>
<span id="cb429-8"><a href="#cb429-8"></a>    {</span>
<span id="cb429-9"><a href="#cb429-9"></a>        <span class="st">&quot;push&quot;</span>,</span>
<span id="cb429-10"><a href="#cb429-10"></a>        &amp;Builtin{Fn: <span class="kw">func</span>(args ...Object) Object {</span>
<span id="cb429-11"><a href="#cb429-11"></a>            <span class="kw">if</span> <span class="bu">len</span>(args) != <span class="dv">2</span> {</span>
<span id="cb429-12"><a href="#cb429-12"></a>                <span class="kw">return</span> newError(<span class="st">&quot;wrong number of arguments. got=%d, want=2&quot;</span>,</span>
<span id="cb429-13"><a href="#cb429-13"></a>                    <span class="bu">len</span>(args))</span>
<span id="cb429-14"><a href="#cb429-14"></a>            }</span>
<span id="cb429-15"><a href="#cb429-15"></a>            <span class="kw">if</span> args[<span class="dv">0</span>].Type() != ARRAY_OBJ {</span>
<span id="cb429-16"><a href="#cb429-16"></a>                <span class="kw">return</span> newError(<span class="st">&quot;argument to `push` must be ARRAY, got %s&quot;</span>,</span>
<span id="cb429-17"><a href="#cb429-17"></a>                    args[<span class="dv">0</span>].Type())</span>
<span id="cb429-18"><a href="#cb429-18"></a>            }</span>
<span id="cb429-19"><a href="#cb429-19"></a></span>
<span id="cb429-20"><a href="#cb429-20"></a>            arr := args[<span class="dv">0</span>].(*Array)</span>
<span id="cb429-21"><a href="#cb429-21"></a>            length := <span class="bu">len</span>(arr.Elements)</span>
<span id="cb429-22"><a href="#cb429-22"></a></span>
<span id="cb429-23"><a href="#cb429-23"></a>            newElements := <span class="bu">make</span>([]Object, length+<span class="dv">1</span>, length+<span class="dv">1</span>)</span>
<span id="cb429-24"><a href="#cb429-24"></a>            <span class="bu">copy</span>(newElements, arr.Elements)</span>
<span id="cb429-25"><a href="#cb429-25"></a>            newElements[length] = args[<span class="dv">1</span>]</span>
<span id="cb429-26"><a href="#cb429-26"></a></span>
<span id="cb429-27"><a href="#cb429-27"></a>            <span class="kw">return</span> &amp;Array{Elements: newElements}</span>
<span id="cb429-28"><a href="#cb429-28"></a>        },</span>
<span id="cb429-29"><a href="#cb429-29"></a>        },</span>
<span id="cb429-30"><a href="#cb429-30"></a>    },</span>
<span id="cb429-31"><a href="#cb429-31"></a>}</span></code></pre></div>
<p>And that was the last of the built-in functions we set out to implement. All of them are now defined in <code>object.Builtins</code>, stripped free of redundant references to the <code>object</code> package and making no mention of <code>evaluator.NULL</code>.</p>
<p>Now we can go back to <code>evaluator/builtins.go</code> and replace all of the currently-duplicated definitions with calls to <code>object.GetBuiltinByName</code>:</p>
<div class="sourceCode" id="cb430"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb430-1"><a href="#cb430-1"></a><span class="co">// evaluator/builtins.go</span></span>
<span id="cb430-2"><a href="#cb430-2"></a></span>
<span id="cb430-3"><a href="#cb430-3"></a><span class="kw">import</span> (</span>
<span id="cb430-4"><a href="#cb430-4"></a>    <span class="st">&quot;monkey/object&quot;</span></span>
<span id="cb430-5"><a href="#cb430-5"></a>)</span>
<span id="cb430-6"><a href="#cb430-6"></a></span>
<span id="cb430-7"><a href="#cb430-7"></a><span class="kw">var</span> builtins = <span class="kw">map</span>[<span class="dt">string</span>]*object.Builtin{</span>
<span id="cb430-8"><a href="#cb430-8"></a>    <span class="st">&quot;len&quot;</span>:   object.GetBuiltinByName(<span class="st">&quot;len&quot;</span>),</span>
<span id="cb430-9"><a href="#cb430-9"></a>    <span class="st">&quot;puts&quot;</span>:  object.GetBuiltinByName(<span class="st">&quot;puts&quot;</span>),</span>
<span id="cb430-10"><a href="#cb430-10"></a>    <span class="st">&quot;first&quot;</span>: object.GetBuiltinByName(<span class="st">&quot;first&quot;</span>),</span>
<span id="cb430-11"><a href="#cb430-11"></a>    <span class="st">&quot;last&quot;</span>:  object.GetBuiltinByName(<span class="st">&quot;last&quot;</span>),</span>
<span id="cb430-12"><a href="#cb430-12"></a>    <span class="st">&quot;rest&quot;</span>:  object.GetBuiltinByName(<span class="st">&quot;rest&quot;</span>),</span>
<span id="cb430-13"><a href="#cb430-13"></a>    <span class="st">&quot;push&quot;</span>:  object.GetBuiltinByName(<span class="st">&quot;push&quot;</span>),</span>
<span id="cb430-14"><a href="#cb430-14"></a>}</span></code></pre></div>
<p>Isn’t that neat? That’s the whole file! Now comes the sanity check to make sure that everything still works:</p>
<div class="sourceCode" id="cb431"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb431-1"><a href="#cb431-1"></a>$ go test ./evaluator</span>
<span id="cb431-2"><a href="#cb431-2"></a>ok      monkey/evaluator    0.009s</span></code></pre></div>
<p>Great! With that, built-in functions are now available to every package that imports the <code>object</code> package. They do not depend on <code>evaluator.NULL</code> anymore and follow a bring-your-own-null approach instead. The <code>evaluator</code> still works as it did at the end of <em>Writing An Interpreter In Go</em> and all tests pass.</p>
<p>Beautiful. That’s what I call a refactoring. It makes everything we now have to do easier.</p>
<h2 id="making-the-change-the-plan">Making the Change: the Plan</h2>
<p>You know what I like? Getting rid of edge cases and having as few of them as possible.</p>
<p>That’s why I want to keep our existing calling convention as it is, even for built-in functions. That means, in order to call a built-in function, you’d do the same as for any other function: push the built-in function on to the stack, push the arguments of the call and then call the function with an <code>OpCall</code> instruction.</p>
<p><em>How</em> the built-in function is going to be executed, that’s an implementation detail of the VM which we’ll worry about later.</p>
<p>From the compiler’s perspective, the only thing that should be different when compiling a call expression involving a built-in function is how the function ends up on the stack. For that, we really need to introduce another case, but not an edge case.</p>
<p>Built-in functions are neither defined in the global nor in a local scope. They live in their own scope. And we need to introduce that scope to the compiler and its symbol table, so they can correctly resolve references to built-in functions.</p>
<p>We’re going to call this scope the <code>BuiltinScope</code> and in it we’re going to define all the built-in functions we have just moved over to the <code>object.Builtins</code> slice of definitions – in exactly that order. That’s an important detail, because it’s our sidequest.</p>
<p>When the compiler (with the help of the symbol table) then detects a reference to a built-in function it will emit an <code>OpGetBuiltin</code> instruction. The operand in this instruction will be the index of the referenced function in <code>object.Builtins</code>.</p>
<p>Since <code>object.Builtins</code> is also accessible by the VM it can use the operand of the instruction to fetch the correct function from <code>object.Builtins</code> and push it on to the stack, where it can then be called.</p>
<p>Again, we can worry about how <em>that</em> happens later, once we’ve written our first VM test. But as our next step, we need to make sure that the compiler knows how to resolve references to built-ins. For that, we need a new opcode and a new scope.</p>
<h2 id="a-new-scope-for-built-in-functions">A New Scope for Built-in Functions</h2>
<p>First things first and as we know by now, that’s often a new opcode. This time it’s called <code>OpGetBuiltin</code>:</p>
<div class="sourceCode" id="cb432"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb432-1"><a href="#cb432-1"></a><span class="co">// code/code.go</span></span>
<span id="cb432-2"><a href="#cb432-2"></a></span>
<span id="cb432-3"><a href="#cb432-3"></a><span class="kw">const</span> (</span>
<span id="cb432-4"><a href="#cb432-4"></a>    <span class="co">// [...]</span></span>
<span id="cb432-5"><a href="#cb432-5"></a></span>
<span id="cb432-6"><a href="#cb432-6"></a>    OpGetBuiltin</span>
<span id="cb432-7"><a href="#cb432-7"></a>)</span>
<span id="cb432-8"><a href="#cb432-8"></a></span>
<span id="cb432-9"><a href="#cb432-9"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb432-10"><a href="#cb432-10"></a>    <span class="co">// [...]</span></span>
<span id="cb432-11"><a href="#cb432-11"></a></span>
<span id="cb432-12"><a href="#cb432-12"></a>    OpGetBuiltin: {<span class="st">&quot;OpGetBuiltin&quot;</span>, []<span class="dt">int</span>{<span class="dv">1</span>}},</span>
<span id="cb432-13"><a href="#cb432-13"></a>}</span></code></pre></div>
<p>The opcode comes with one operand that’s one byte wide. That means we can define up to 256 built-in functions. Sounds low? Let’s just say that once we’ve reached that limit, we can always make it two bytes.</p>
<p>You know the drill: opcodes first and compiler tests next. Now that we have <code>OpGetBuiltin</code>, we can write a test that expects our compiler to turn references to built-in functions into <code>OpGetBuiltin</code> instructions.</p>
<div class="sourceCode" id="cb433"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb433-1"><a href="#cb433-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb433-2"><a href="#cb433-2"></a></span>
<span id="cb433-3"><a href="#cb433-3"></a><span class="kw">func</span> TestBuiltins(t *testing.T) {</span>
<span id="cb433-4"><a href="#cb433-4"></a>    tests := []compilerTestCase{</span>
<span id="cb433-5"><a href="#cb433-5"></a>        {</span>
<span id="cb433-6"><a href="#cb433-6"></a>            input: <span class="st">`</span></span>
<span id="cb433-7"><a href="#cb433-7"></a><span class="st">            len([]);</span></span>
<span id="cb433-8"><a href="#cb433-8"></a><span class="st">            push([], 1);</span></span>
<span id="cb433-9"><a href="#cb433-9"></a><span class="st">            `</span>,</span>
<span id="cb433-10"><a href="#cb433-10"></a>            expectedConstants: []<span class="kw">interface</span>{}{<span class="dv">1</span>},</span>
<span id="cb433-11"><a href="#cb433-11"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb433-12"><a href="#cb433-12"></a>                code.Make(code.OpGetBuiltin, <span class="dv">0</span>),</span>
<span id="cb433-13"><a href="#cb433-13"></a>                code.Make(code.OpArray, <span class="dv">0</span>),</span>
<span id="cb433-14"><a href="#cb433-14"></a>                code.Make(code.OpCall, <span class="dv">1</span>),</span>
<span id="cb433-15"><a href="#cb433-15"></a>                code.Make(code.OpPop),</span>
<span id="cb433-16"><a href="#cb433-16"></a>                code.Make(code.OpGetBuiltin, <span class="dv">5</span>),</span>
<span id="cb433-17"><a href="#cb433-17"></a>                code.Make(code.OpArray, <span class="dv">0</span>),</span>
<span id="cb433-18"><a href="#cb433-18"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb433-19"><a href="#cb433-19"></a>                code.Make(code.OpCall, <span class="dv">2</span>),</span>
<span id="cb433-20"><a href="#cb433-20"></a>                code.Make(code.OpPop),</span>
<span id="cb433-21"><a href="#cb433-21"></a>            },</span>
<span id="cb433-22"><a href="#cb433-22"></a>        },</span>
<span id="cb433-23"><a href="#cb433-23"></a>        {</span>
<span id="cb433-24"><a href="#cb433-24"></a>            input: <span class="st">`fn() { len([]) }`</span>,</span>
<span id="cb433-25"><a href="#cb433-25"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb433-26"><a href="#cb433-26"></a>                []code.Instructions{</span>
<span id="cb433-27"><a href="#cb433-27"></a>                    code.Make(code.OpGetBuiltin, <span class="dv">0</span>),</span>
<span id="cb433-28"><a href="#cb433-28"></a>                    code.Make(code.OpArray, <span class="dv">0</span>),</span>
<span id="cb433-29"><a href="#cb433-29"></a>                    code.Make(code.OpCall, <span class="dv">1</span>),</span>
<span id="cb433-30"><a href="#cb433-30"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb433-31"><a href="#cb433-31"></a>                },</span>
<span id="cb433-32"><a href="#cb433-32"></a>            },</span>
<span id="cb433-33"><a href="#cb433-33"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb433-34"><a href="#cb433-34"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb433-35"><a href="#cb433-35"></a>                code.Make(code.OpPop),</span>
<span id="cb433-36"><a href="#cb433-36"></a>            },</span>
<span id="cb433-37"><a href="#cb433-37"></a>        },</span>
<span id="cb433-38"><a href="#cb433-38"></a>    }</span>
<span id="cb433-39"><a href="#cb433-39"></a></span>
<span id="cb433-40"><a href="#cb433-40"></a>    runCompilerTests(t, tests)</span>
<span id="cb433-41"><a href="#cb433-41"></a>}</span></code></pre></div>
<p>The first of these two test cases makes sure of two things. First, calling a built-in function follows our established calling convention and, second, the operand of the <code>OpGetBuiltin</code> instruction is the index of the referenced function in <code>object.Builtins</code>.</p>
<p>The second test case then makes sure that references to built-in functions are correctly resolved, independent of the scope in which they occur, which is different from the existing behaviour of local and global scopes.</p>
<p>If we run the tests, we get a compiler error:</p>
<div class="sourceCode" id="cb434"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb434-1"><a href="#cb434-1"></a>$ go test ./compiler</span>
<span id="cb434-2"><a href="#cb434-2"></a>--- FAIL: TestBuiltins (0.00s)</span>
<span id="cb434-3"><a href="#cb434-3"></a> compiler_test.go:1049: compiler error: undefined variable len</span>
<span id="cb434-4"><a href="#cb434-4"></a>FAIL</span>
<span id="cb434-5"><a href="#cb434-5"></a>FAIL    monkey/compiler 0.008s</span></code></pre></div>
<p>Since the fix for this failing test includes our compiler correctly resolving references, our next stop is the place where the compiler goes to for its resolving needs: the symbol table.</p>
<p>Here, too, we need to write a test to make sure that built-in functions <em>always</em> resolve to a symbol in the <code>BuiltinScope</code>, regardless of how many times the symbol table has been enclosed in another one:</p>
<div class="sourceCode" id="cb435"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb435-1"><a href="#cb435-1"></a><span class="co">// compiler/symbol_table_test.go</span></span>
<span id="cb435-2"><a href="#cb435-2"></a></span>
<span id="cb435-3"><a href="#cb435-3"></a><span class="kw">func</span> TestDefineResolveBuiltins(t *testing.T) {</span>
<span id="cb435-4"><a href="#cb435-4"></a>    global := NewSymbolTable()</span>
<span id="cb435-5"><a href="#cb435-5"></a>    firstLocal := NewEnclosedSymbolTable(global)</span>
<span id="cb435-6"><a href="#cb435-6"></a>    secondLocal := NewEnclosedSymbolTable(firstLocal)</span>
<span id="cb435-7"><a href="#cb435-7"></a></span>
<span id="cb435-8"><a href="#cb435-8"></a>    expected := []Symbol{</span>
<span id="cb435-9"><a href="#cb435-9"></a>        Symbol{Name: <span class="st">&quot;a&quot;</span>, Scope: BuiltinScope, Index: <span class="dv">0</span>},</span>
<span id="cb435-10"><a href="#cb435-10"></a>        Symbol{Name: <span class="st">&quot;c&quot;</span>, Scope: BuiltinScope, Index: <span class="dv">1</span>},</span>
<span id="cb435-11"><a href="#cb435-11"></a>        Symbol{Name: <span class="st">&quot;e&quot;</span>, Scope: BuiltinScope, Index: <span class="dv">2</span>},</span>
<span id="cb435-12"><a href="#cb435-12"></a>        Symbol{Name: <span class="st">&quot;f&quot;</span>, Scope: BuiltinScope, Index: <span class="dv">3</span>},</span>
<span id="cb435-13"><a href="#cb435-13"></a>    }</span>
<span id="cb435-14"><a href="#cb435-14"></a></span>
<span id="cb435-15"><a href="#cb435-15"></a>    <span class="kw">for</span> i, v := <span class="kw">range</span> expected {</span>
<span id="cb435-16"><a href="#cb435-16"></a>        global.DefineBuiltin(i, v.Name)</span>
<span id="cb435-17"><a href="#cb435-17"></a>    }</span>
<span id="cb435-18"><a href="#cb435-18"></a></span>
<span id="cb435-19"><a href="#cb435-19"></a>    <span class="kw">for</span> _, table := <span class="kw">range</span> []*SymbolTable{global, firstLocal, secondLocal} {</span>
<span id="cb435-20"><a href="#cb435-20"></a>        <span class="kw">for</span> _, sym := <span class="kw">range</span> expected {</span>
<span id="cb435-21"><a href="#cb435-21"></a>            result, ok := table.Resolve(sym.Name)</span>
<span id="cb435-22"><a href="#cb435-22"></a>            <span class="kw">if</span> !ok {</span>
<span id="cb435-23"><a href="#cb435-23"></a>                t.Errorf(<span class="st">&quot;name %s not resolvable&quot;</span>, sym.Name)</span>
<span id="cb435-24"><a href="#cb435-24"></a>                <span class="kw">continue</span></span>
<span id="cb435-25"><a href="#cb435-25"></a>            }</span>
<span id="cb435-26"><a href="#cb435-26"></a>            <span class="kw">if</span> result != sym {</span>
<span id="cb435-27"><a href="#cb435-27"></a>                t.Errorf(<span class="st">&quot;expected %s to resolve to %+v, got=%+v&quot;</span>,</span>
<span id="cb435-28"><a href="#cb435-28"></a>                    sym.Name, sym, result)</span>
<span id="cb435-29"><a href="#cb435-29"></a>            }</span>
<span id="cb435-30"><a href="#cb435-30"></a>        }</span>
<span id="cb435-31"><a href="#cb435-31"></a>    }</span>
<span id="cb435-32"><a href="#cb435-32"></a>}</span></code></pre></div>
<p>In this test we define three scopes, nested within each other, and expect every symbol that’s been defined in the global scope with <code>DefineBuiltin</code> to resolve to the new <code>BuiltinScope</code>.</p>
<p>Since <code>DefineBuiltin</code> and <code>BuiltinScope</code> do not exist yet, there’s no need to run the tests yet, but it also doesn’t hurt to make sure that they blow up as expected:</p>
<div class="sourceCode" id="cb436"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb436-1"><a href="#cb436-1"></a>$ go test -run TestDefineResolveBuiltins ./compiler</span>
<span id="cb436-2"><a href="#cb436-2"></a># monkey/compiler</span>
<span id="cb436-3"><a href="#cb436-3"></a>compiler/symbol_table_test.go:162:28: undefined: BuiltinScope</span>
<span id="cb436-4"><a href="#cb436-4"></a>compiler/symbol_table_test.go:163:28: undefined: BuiltinScope</span>
<span id="cb436-5"><a href="#cb436-5"></a>compiler/symbol_table_test.go:164:28: undefined: BuiltinScope</span>
<span id="cb436-6"><a href="#cb436-6"></a>compiler/symbol_table_test.go:165:28: undefined: BuiltinScope</span>
<span id="cb436-7"><a href="#cb436-7"></a>compiler/symbol_table_test.go:169:9: global.DefineBuiltin undefined\</span>
<span id="cb436-8"><a href="#cb436-8"></a>  (type *SymbolTable has no field or method DefineBuiltin)</span>
<span id="cb436-9"><a href="#cb436-9"></a>FAIL    monkey/compiler [build failed]</span></code></pre></div>
<p>As expected. Defining <code>BuiltinScope</code> is the easier of the two necessary steps, so we do that first:</p>
<div class="sourceCode" id="cb437"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb437-1"><a href="#cb437-1"></a><span class="co">// compiler/symbol_table.go</span></span>
<span id="cb437-2"><a href="#cb437-2"></a></span>
<span id="cb437-3"><a href="#cb437-3"></a><span class="kw">const</span> (</span>
<span id="cb437-4"><a href="#cb437-4"></a>    <span class="co">// [...]</span></span>
<span id="cb437-5"><a href="#cb437-5"></a>    BuiltinScope SymbolScope = <span class="st">&quot;BUILTIN&quot;</span></span>
<span id="cb437-6"><a href="#cb437-6"></a>)</span></code></pre></div>
<p>But it’s not that much harder to write the <code>DefineBuiltin</code> method:</p>
<div class="sourceCode" id="cb438"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb438-1"><a href="#cb438-1"></a><span class="co">// compiler/symbol_table.go</span></span>
<span id="cb438-2"><a href="#cb438-2"></a></span>
<span id="cb438-3"><a href="#cb438-3"></a><span class="kw">func</span> (s *SymbolTable) DefineBuiltin(index <span class="dt">int</span>, name <span class="dt">string</span>) Symbol {</span>
<span id="cb438-4"><a href="#cb438-4"></a>    symbol := Symbol{Name: name, Index: index, Scope: BuiltinScope}</span>
<span id="cb438-5"><a href="#cb438-5"></a>    s.store[name] = symbol</span>
<span id="cb438-6"><a href="#cb438-6"></a>    <span class="kw">return</span> symbol</span>
<span id="cb438-7"><a href="#cb438-7"></a>}</span></code></pre></div>
<p>Compared to the existing <code>Define</code> method, this one here is much simpler. Define the given name with the given index in the <code>BuiltinScope</code>, ignore whether you’re enclosed in another symbol table or not, and done:</p>
<div class="sourceCode" id="cb439"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb439-1"><a href="#cb439-1"></a>$ go test -run TestDefineResolveBuiltins ./compiler</span>
<span id="cb439-2"><a href="#cb439-2"></a>ok      monkey/compiler 0.007s</span></code></pre></div>
<p>Now we can go back and use <code>DefineBuiltin</code> method in the compiler:</p>
<div class="sourceCode" id="cb440"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb440-1"><a href="#cb440-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb440-2"><a href="#cb440-2"></a></span>
<span id="cb440-3"><a href="#cb440-3"></a><span class="kw">func</span> New() *Compiler {</span>
<span id="cb440-4"><a href="#cb440-4"></a>    <span class="co">// [...]</span></span>
<span id="cb440-5"><a href="#cb440-5"></a></span>
<span id="cb440-6"><a href="#cb440-6"></a>    symbolTable := NewSymbolTable()</span>
<span id="cb440-7"><a href="#cb440-7"></a></span>
<span id="cb440-8"><a href="#cb440-8"></a>    <span class="kw">for</span> i, v := <span class="kw">range</span> object.Builtins {</span>
<span id="cb440-9"><a href="#cb440-9"></a>        symbolTable.DefineBuiltin(i, v.Name)</span>
<span id="cb440-10"><a href="#cb440-10"></a>    }</span>
<span id="cb440-11"><a href="#cb440-11"></a></span>
<span id="cb440-12"><a href="#cb440-12"></a>    <span class="kw">return</span> &amp;Compiler{</span>
<span id="cb440-13"><a href="#cb440-13"></a>        <span class="co">// [...]</span></span>
<span id="cb440-14"><a href="#cb440-14"></a>        symbolTable:       symbolTable,</span>
<span id="cb440-15"><a href="#cb440-15"></a>        <span class="co">// [...]</span></span>
<span id="cb440-16"><a href="#cb440-16"></a>    }</span>
<span id="cb440-17"><a href="#cb440-17"></a>}</span></code></pre></div>
<p>When initializing a new <code>*Compiler</code> we iterate through all of the functions in <code>object.Builtins</code> and define them in the <code>BuiltinScope</code> by using the <code>DefineBuiltin</code> method on the global symbol table.</p>
<p>That should fix our compiler test, because the compiler can now resolve the references to the built-in functions:</p>
<div class="sourceCode" id="cb441"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb441-1"><a href="#cb441-1"></a>$ go test ./compiler</span>
<span id="cb441-2"><a href="#cb441-2"></a>--- FAIL: TestBuiltins (0.00s)</span>
<span id="cb441-3"><a href="#cb441-3"></a> compiler_test.go:1056: testInstructions failed: wrong instruction at 0.</span>
<span id="cb441-4"><a href="#cb441-4"></a>  want=&quot;0000 OpGetBuiltin 0\n0002 OpArray 0\n0005 OpCall 1\n0007 OpPop\n\</span>
<span id="cb441-5"><a href="#cb441-5"></a>    0008 OpGetBuiltin 5\n0010 OpArray 0\n0013 OpConstant 0\n\</span>
<span id="cb441-6"><a href="#cb441-6"></a>    0016 OpCall 2\n0018 OpPop\n&quot;</span>
<span id="cb441-7"><a href="#cb441-7"></a>  got =&quot;0000 OpGetLocal 0\n0002 OpArray 0\n0005 OpCall 1\n0007 OpPop\n\</span>
<span id="cb441-8"><a href="#cb441-8"></a>    0008 OpGetLocal 5\n0010 OpArray 0\n0013 OpConstant 0\n\</span>
<span id="cb441-9"><a href="#cb441-9"></a>    0016 OpCall 2\n0018 OpPop\n&quot;</span>
<span id="cb441-10"><a href="#cb441-10"></a>FAIL</span>
<span id="cb441-11"><a href="#cb441-11"></a>FAIL    monkey/compiler 0.009s</span></code></pre></div>
<p>Except, it doesn’t and that’s because our compiler ignores half of what the symbol table is saying. In its current state, after using the symbol table to resolve a name, the compiler only checks whether a symbol’s scope is <code>GlobalScope</code> or not. But we can’t get away with an if-else check anymore.</p>
<p>We have a third scope now and have to actually listen to what the symbol table has to say. And we best do that in a separate method:</p>
<div class="sourceCode" id="cb442"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb442-1"><a href="#cb442-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb442-2"><a href="#cb442-2"></a></span>
<span id="cb442-3"><a href="#cb442-3"></a><span class="kw">func</span> (c *Compiler) loadSymbol(s Symbol) {</span>
<span id="cb442-4"><a href="#cb442-4"></a>    <span class="kw">switch</span> s.Scope {</span>
<span id="cb442-5"><a href="#cb442-5"></a>    <span class="kw">case</span> GlobalScope:</span>
<span id="cb442-6"><a href="#cb442-6"></a>        c.emit(code.OpGetGlobal, s.Index)</span>
<span id="cb442-7"><a href="#cb442-7"></a>    <span class="kw">case</span> LocalScope:</span>
<span id="cb442-8"><a href="#cb442-8"></a>        c.emit(code.OpGetLocal, s.Index)</span>
<span id="cb442-9"><a href="#cb442-9"></a>    <span class="kw">case</span> BuiltinScope:</span>
<span id="cb442-10"><a href="#cb442-10"></a>        c.emit(code.OpGetBuiltin, s.Index)</span>
<span id="cb442-11"><a href="#cb442-11"></a>    }</span>
<span id="cb442-12"><a href="#cb442-12"></a>}</span></code></pre></div>
<p>When we now use <code>loadSymbol</code> to compile an <code>*ast.Identifier</code>, we emit the correct instruction for each symbol we resolve:</p>
<div class="sourceCode" id="cb443"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb443-1"><a href="#cb443-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb443-2"><a href="#cb443-2"></a></span>
<span id="cb443-3"><a href="#cb443-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb443-4"><a href="#cb443-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb443-5"><a href="#cb443-5"></a></span>
<span id="cb443-6"><a href="#cb443-6"></a>    <span class="co">// [...]</span></span>
<span id="cb443-7"><a href="#cb443-7"></a></span>
<span id="cb443-8"><a href="#cb443-8"></a>    <span class="kw">case</span> *ast.Identifier:</span>
<span id="cb443-9"><a href="#cb443-9"></a>        symbol, ok := c.symbolTable.Resolve(node.Value)</span>
<span id="cb443-10"><a href="#cb443-10"></a>        <span class="kw">if</span> !ok {</span>
<span id="cb443-11"><a href="#cb443-11"></a>            <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;undefined variable %s&quot;</span>, node.Value)</span>
<span id="cb443-12"><a href="#cb443-12"></a>        }</span>
<span id="cb443-13"><a href="#cb443-13"></a></span>
<span id="cb443-14"><a href="#cb443-14"></a>        c.loadSymbol(symbol)</span>
<span id="cb443-15"><a href="#cb443-15"></a></span>
<span id="cb443-16"><a href="#cb443-16"></a>    <span class="co">// [...]</span></span>
<span id="cb443-17"><a href="#cb443-17"></a>    }</span>
<span id="cb443-18"><a href="#cb443-18"></a></span>
<span id="cb443-19"><a href="#cb443-19"></a>    <span class="co">// [...]</span></span>
<span id="cb443-20"><a href="#cb443-20"></a>}</span></code></pre></div>
<p>Yep, that did it:</p>
<div class="sourceCode" id="cb444"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb444-1"><a href="#cb444-1"></a>$ go test ./compiler</span>
<span id="cb444-2"><a href="#cb444-2"></a>ok      monkey/compiler 0.008s</span></code></pre></div>
<p>That means, the compiler now compiles references to built-in functions. And the best bit is that it also upholds our existing calling convention – without us having to do anything. Sweet!</p>
<p>Time to start worrying about the implementation detail that is the execution of built-in functions.</p>
<h2 id="executing-built-in-functions">Executing built-in functions</h2>
<p>“Implementation detail” always sounds like it’s about of the size of the change, when it’s really about visibility, abstraction. The user of a feature shouldn’t have to worry about <em>how</em> it’s implemented – the detail – but only about using it.</p>
<p>A Monkey user shouldn’t have to worry about how to execute a built-in function. Neither should the compiler. That should solely be the concern of the VM. And that gives us a lot of freedom: freedom of implementation and also freedom of tests. We can simply write down what we want the VM to do and only then worry about the <em>how</em>:</p>
<div class="sourceCode" id="cb445"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb445-1"><a href="#cb445-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb445-2"><a href="#cb445-2"></a></span>
<span id="cb445-3"><a href="#cb445-3"></a><span class="kw">func</span> TestBuiltinFunctions(t *testing.T) {</span>
<span id="cb445-4"><a href="#cb445-4"></a>    tests := []vmTestCase{</span>
<span id="cb445-5"><a href="#cb445-5"></a>        {<span class="st">`len(&quot;&quot;)`</span>, <span class="dv">0</span>},</span>
<span id="cb445-6"><a href="#cb445-6"></a>        {<span class="st">`len(&quot;four&quot;)`</span>, <span class="dv">4</span>},</span>
<span id="cb445-7"><a href="#cb445-7"></a>        {<span class="st">`len(&quot;hello world&quot;)`</span>, <span class="dv">11</span>},</span>
<span id="cb445-8"><a href="#cb445-8"></a>        {</span>
<span id="cb445-9"><a href="#cb445-9"></a>            <span class="st">`len(1)`</span>,</span>
<span id="cb445-10"><a href="#cb445-10"></a>            &amp;object.Error{</span>
<span id="cb445-11"><a href="#cb445-11"></a>                Message: <span class="st">&quot;argument to `len` not supported, got INTEGER&quot;</span>,</span>
<span id="cb445-12"><a href="#cb445-12"></a>            },</span>
<span id="cb445-13"><a href="#cb445-13"></a>        },</span>
<span id="cb445-14"><a href="#cb445-14"></a>        {<span class="st">`len(&quot;one&quot;, &quot;two&quot;)`</span>,</span>
<span id="cb445-15"><a href="#cb445-15"></a>            &amp;object.Error{</span>
<span id="cb445-16"><a href="#cb445-16"></a>                Message: <span class="st">&quot;wrong number of arguments. got=2, want=1&quot;</span>,</span>
<span id="cb445-17"><a href="#cb445-17"></a>            },</span>
<span id="cb445-18"><a href="#cb445-18"></a>        },</span>
<span id="cb445-19"><a href="#cb445-19"></a>        {<span class="st">`len([1, 2, 3])`</span>, <span class="dv">3</span>},</span>
<span id="cb445-20"><a href="#cb445-20"></a>        {<span class="st">`len([])`</span>, <span class="dv">0</span>},</span>
<span id="cb445-21"><a href="#cb445-21"></a>        {<span class="st">`puts(&quot;hello&quot;, &quot;world!&quot;)`</span>, Null},</span>
<span id="cb445-22"><a href="#cb445-22"></a>        {<span class="st">`first([1, 2, 3])`</span>, <span class="dv">1</span>},</span>
<span id="cb445-23"><a href="#cb445-23"></a>        {<span class="st">`first([])`</span>, Null},</span>
<span id="cb445-24"><a href="#cb445-24"></a>        {<span class="st">`first(1)`</span>,</span>
<span id="cb445-25"><a href="#cb445-25"></a>            &amp;object.Error{</span>
<span id="cb445-26"><a href="#cb445-26"></a>                Message: <span class="st">&quot;argument to `first` must be ARRAY, got INTEGER&quot;</span>,</span>
<span id="cb445-27"><a href="#cb445-27"></a>            },</span>
<span id="cb445-28"><a href="#cb445-28"></a>        },</span>
<span id="cb445-29"><a href="#cb445-29"></a>        {<span class="st">`last([1, 2, 3])`</span>, <span class="dv">3</span>},</span>
<span id="cb445-30"><a href="#cb445-30"></a>        {<span class="st">`last([])`</span>, Null},</span>
<span id="cb445-31"><a href="#cb445-31"></a>        {<span class="st">`last(1)`</span>,</span>
<span id="cb445-32"><a href="#cb445-32"></a>            &amp;object.Error{</span>
<span id="cb445-33"><a href="#cb445-33"></a>                Message: <span class="st">&quot;argument to `last` must be ARRAY, got INTEGER&quot;</span>,</span>
<span id="cb445-34"><a href="#cb445-34"></a>            },</span>
<span id="cb445-35"><a href="#cb445-35"></a>        },</span>
<span id="cb445-36"><a href="#cb445-36"></a>        {<span class="st">`rest([1, 2, 3])`</span>, []<span class="dt">int</span>{<span class="dv">2</span>, <span class="dv">3</span>}},</span>
<span id="cb445-37"><a href="#cb445-37"></a>        {<span class="st">`rest([])`</span>, Null},</span>
<span id="cb445-38"><a href="#cb445-38"></a>        {<span class="st">`push([], 1)`</span>, []<span class="dt">int</span>{<span class="dv">1</span>}},</span>
<span id="cb445-39"><a href="#cb445-39"></a>        {<span class="st">`push(1, 1)`</span>,</span>
<span id="cb445-40"><a href="#cb445-40"></a>            &amp;object.Error{</span>
<span id="cb445-41"><a href="#cb445-41"></a>                Message: <span class="st">&quot;argument to `push` must be ARRAY, got INTEGER&quot;</span>,</span>
<span id="cb445-42"><a href="#cb445-42"></a>            },</span>
<span id="cb445-43"><a href="#cb445-43"></a>        },</span>
<span id="cb445-44"><a href="#cb445-44"></a>    }</span>
<span id="cb445-45"><a href="#cb445-45"></a></span>
<span id="cb445-46"><a href="#cb445-46"></a>    runVmTests(t, tests)</span>
<span id="cb445-47"><a href="#cb445-47"></a>}</span>
<span id="cb445-48"><a href="#cb445-48"></a></span>
<span id="cb445-49"><a href="#cb445-49"></a><span class="kw">func</span> testExpectedObject(</span>
<span id="cb445-50"><a href="#cb445-50"></a>    t *testing.T,</span>
<span id="cb445-51"><a href="#cb445-51"></a>    expected <span class="kw">interface</span>{},</span>
<span id="cb445-52"><a href="#cb445-52"></a>    actual object.Object,</span>
<span id="cb445-53"><a href="#cb445-53"></a>) {</span>
<span id="cb445-54"><a href="#cb445-54"></a>    t.Helper()</span>
<span id="cb445-55"><a href="#cb445-55"></a></span>
<span id="cb445-56"><a href="#cb445-56"></a>    <span class="kw">switch</span> expected := expected.(<span class="kw">type</span>) {</span>
<span id="cb445-57"><a href="#cb445-57"></a>    <span class="co">// [...]</span></span>
<span id="cb445-58"><a href="#cb445-58"></a></span>
<span id="cb445-59"><a href="#cb445-59"></a>    <span class="kw">case</span> *object.Error:</span>
<span id="cb445-60"><a href="#cb445-60"></a>        errObj, ok := actual.(*object.Error)</span>
<span id="cb445-61"><a href="#cb445-61"></a>        <span class="kw">if</span> !ok {</span>
<span id="cb445-62"><a href="#cb445-62"></a>            t.Errorf(<span class="st">&quot;object is not Error: %T (%+v)&quot;</span>, actual, actual)</span>
<span id="cb445-63"><a href="#cb445-63"></a>            <span class="kw">return</span></span>
<span id="cb445-64"><a href="#cb445-64"></a>        }</span>
<span id="cb445-65"><a href="#cb445-65"></a>        <span class="kw">if</span> errObj.Message != expected.Message {</span>
<span id="cb445-66"><a href="#cb445-66"></a>            t.Errorf(<span class="st">&quot;wrong error message. expected=%q, got=%q&quot;</span>,</span>
<span id="cb445-67"><a href="#cb445-67"></a>                expected.Message, errObj.Message)</span>
<span id="cb445-68"><a href="#cb445-68"></a>        }</span>
<span id="cb445-69"><a href="#cb445-69"></a>    }</span>
<span id="cb445-70"><a href="#cb445-70"></a>}</span></code></pre></div>
<p>This test is an updated version of the <code>TestBuiltinFunctions</code> test in the <code>evaluator</code> package. The references to <code>evaluator.NULL</code> have been changed to <code>vm.Null</code> and the testing of the result has been updated to use our new test helpers. Other than that, it does the same thing as its precursor: make sure that all built-in functions work as expected, including error handling.</p>
<p>None of the functions work yet, of course. Instead, we get a <code>panic</code> when we try to run the tests. I won’t show it to you – to save half a book page and to spare you the headache of looking at it. Rest assured, though, that the main reason for the <code>panic</code> is that the VM doesn’t decode and execute the <code>OpGetBuiltin</code> instructions yet. That’s our first task:</p>
<div class="sourceCode" id="cb446"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb446-1"><a href="#cb446-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb446-2"><a href="#cb446-2"></a></span>
<span id="cb446-3"><a href="#cb446-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb446-4"><a href="#cb446-4"></a>    <span class="co">// [...]</span></span>
<span id="cb446-5"><a href="#cb446-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb446-6"><a href="#cb446-6"></a>        <span class="co">// [...]</span></span>
<span id="cb446-7"><a href="#cb446-7"></a></span>
<span id="cb446-8"><a href="#cb446-8"></a>        <span class="kw">case</span> code.OpGetBuiltin:</span>
<span id="cb446-9"><a href="#cb446-9"></a>            builtinIndex := code.ReadUint8(ins[ip+<span class="dv">1</span>:])</span>
<span id="cb446-10"><a href="#cb446-10"></a>            vm.currentFrame().ip += <span class="dv">1</span></span>
<span id="cb446-11"><a href="#cb446-11"></a></span>
<span id="cb446-12"><a href="#cb446-12"></a>            definition := object.Builtins[builtinIndex]</span>
<span id="cb446-13"><a href="#cb446-13"></a></span>
<span id="cb446-14"><a href="#cb446-14"></a>            err := vm.push(definition.Builtin)</span>
<span id="cb446-15"><a href="#cb446-15"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb446-16"><a href="#cb446-16"></a>                <span class="kw">return</span> err</span>
<span id="cb446-17"><a href="#cb446-17"></a>            }</span>
<span id="cb446-18"><a href="#cb446-18"></a></span>
<span id="cb446-19"><a href="#cb446-19"></a>        <span class="co">// [...]</span></span>
<span id="cb446-20"><a href="#cb446-20"></a>        }</span>
<span id="cb446-21"><a href="#cb446-21"></a></span>
<span id="cb446-22"><a href="#cb446-22"></a>    <span class="co">// [...]</span></span>
<span id="cb446-23"><a href="#cb446-23"></a>}</span></code></pre></div>
<p>We decode the operand, use it as an index into <code>object.Builtins</code>, get the definition of the built-in function and then push the <code>*object.Builtin</code> on to the stack. That’s the first part of our calling convention, the part in which you get the function you want to call on to the stack.</p>
<p>When we now run the tests, the <code>panic</code> is gone, replaced with something much more helpful:</p>
<div class="sourceCode" id="cb447"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb447-1"><a href="#cb447-1"></a>$ go test ./vm</span>
<span id="cb447-2"><a href="#cb447-2"></a>--- FAIL: TestBuiltinFunctions (0.00s)</span>
<span id="cb447-3"><a href="#cb447-3"></a> vm_test.go:847: vm error: calling non-function</span>
<span id="cb447-4"><a href="#cb447-4"></a>FAIL</span>
<span id="cb447-5"><a href="#cb447-5"></a>FAIL    monkey/vm   0.036s</span></code></pre></div>
<p>The VM tells us that it can only execute user-defined functions. To fix that, we have to change how we execute <code>OpCall</code> instructions. Instead of directly calling the <code>callFunction</code> method, as we currently do, we first need to check what it is that we’re supposed to call and then dispatch the appropriate method. For that, we introduce an <code>executeCall</code> method:</p>
<div class="sourceCode" id="cb448"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb448-1"><a href="#cb448-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb448-2"><a href="#cb448-2"></a></span>
<span id="cb448-3"><a href="#cb448-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb448-4"><a href="#cb448-4"></a>    <span class="co">// [...]</span></span>
<span id="cb448-5"><a href="#cb448-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb448-6"><a href="#cb448-6"></a>        <span class="co">// [...]</span></span>
<span id="cb448-7"><a href="#cb448-7"></a></span>
<span id="cb448-8"><a href="#cb448-8"></a>        <span class="kw">case</span> code.OpCall:</span>
<span id="cb448-9"><a href="#cb448-9"></a>            numArgs := code.ReadUint8(ins[ip+<span class="dv">1</span>:])</span>
<span id="cb448-10"><a href="#cb448-10"></a>            vm.currentFrame().ip += <span class="dv">1</span></span>
<span id="cb448-11"><a href="#cb448-11"></a></span>
<span id="cb448-12"><a href="#cb448-12"></a>            err := vm.executeCall(<span class="dt">int</span>(numArgs))</span>
<span id="cb448-13"><a href="#cb448-13"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb448-14"><a href="#cb448-14"></a>                <span class="kw">return</span> err</span>
<span id="cb448-15"><a href="#cb448-15"></a>            }</span>
<span id="cb448-16"><a href="#cb448-16"></a></span>
<span id="cb448-17"><a href="#cb448-17"></a>        <span class="co">// [...]</span></span>
<span id="cb448-18"><a href="#cb448-18"></a>        }</span>
<span id="cb448-19"><a href="#cb448-19"></a></span>
<span id="cb448-20"><a href="#cb448-20"></a>    <span class="co">// [...]</span></span>
<span id="cb448-21"><a href="#cb448-21"></a>}</span>
<span id="cb448-22"><a href="#cb448-22"></a></span>
<span id="cb448-23"><a href="#cb448-23"></a><span class="kw">func</span> (vm *VM) executeCall(numArgs <span class="dt">int</span>) <span class="dt">error</span> {</span>
<span id="cb448-24"><a href="#cb448-24"></a>    callee := vm.stack[vm.sp<span class="dv">-1</span>-numArgs]</span>
<span id="cb448-25"><a href="#cb448-25"></a>    <span class="kw">switch</span> callee := callee.(<span class="kw">type</span>) {</span>
<span id="cb448-26"><a href="#cb448-26"></a>    <span class="kw">case</span> *object.CompiledFunction:</span>
<span id="cb448-27"><a href="#cb448-27"></a>        <span class="kw">return</span> vm.callFunction(callee, numArgs)</span>
<span id="cb448-28"><a href="#cb448-28"></a>    <span class="kw">case</span> *object.Builtin:</span>
<span id="cb448-29"><a href="#cb448-29"></a>        <span class="kw">return</span> vm.callBuiltin(callee, numArgs)</span>
<span id="cb448-30"><a href="#cb448-30"></a>    <span class="kw">default</span>:</span>
<span id="cb448-31"><a href="#cb448-31"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;calling non-function and non-built-in&quot;</span>)</span>
<span id="cb448-32"><a href="#cb448-32"></a>    }</span>
<span id="cb448-33"><a href="#cb448-33"></a>}</span>
<span id="cb448-34"><a href="#cb448-34"></a></span>
<span id="cb448-35"><a href="#cb448-35"></a><span class="kw">func</span> (vm *VM) callFunction(fn *object.CompiledFunction, numArgs <span class="dt">int</span>) <span class="dt">error</span> {</span>
<span id="cb448-36"><a href="#cb448-36"></a>    <span class="kw">if</span> numArgs != fn.NumParameters {</span>
<span id="cb448-37"><a href="#cb448-37"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;wrong number of arguments: want=%d, got=%d&quot;</span>,</span>
<span id="cb448-38"><a href="#cb448-38"></a>            fn.NumParameters, numArgs)</span>
<span id="cb448-39"><a href="#cb448-39"></a>    }</span>
<span id="cb448-40"><a href="#cb448-40"></a></span>
<span id="cb448-41"><a href="#cb448-41"></a>    frame := NewFrame(fn, vm.sp-numArgs)</span>
<span id="cb448-42"><a href="#cb448-42"></a>    vm.pushFrame(frame)</span>
<span id="cb448-43"><a href="#cb448-43"></a></span>
<span id="cb448-44"><a href="#cb448-44"></a>    vm.sp = frame.basePointer + fn.NumLocals</span>
<span id="cb448-45"><a href="#cb448-45"></a></span>
<span id="cb448-46"><a href="#cb448-46"></a>    <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb448-47"><a href="#cb448-47"></a>}</span></code></pre></div>
<p><code>executeCall</code> now does some of the things that were previously done by <code>callFunction</code>, namely the type checking and error generation. That in turn makes <code>callFunction</code> smaller and requires a different interface, where we pass in the function that’s to be called and the number of arguments of the call.</p>
<p>But that’s mainly code being moved around. What’s new is the addition of the <code>case *object.Builtin</code> branch and the <code>callBuiltin</code> method, which takes care of executing built-in functions:</p>
<div class="sourceCode" id="cb449"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb449-1"><a href="#cb449-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb449-2"><a href="#cb449-2"></a></span>
<span id="cb449-3"><a href="#cb449-3"></a><span class="kw">func</span> (vm *VM) callBuiltin(builtin *object.Builtin, numArgs <span class="dt">int</span>) <span class="dt">error</span> {</span>
<span id="cb449-4"><a href="#cb449-4"></a>    args := vm.stack[vm.sp-numArgs : vm.sp]</span>
<span id="cb449-5"><a href="#cb449-5"></a></span>
<span id="cb449-6"><a href="#cb449-6"></a>    result := builtin.Fn(args...)</span>
<span id="cb449-7"><a href="#cb449-7"></a>    vm.sp = vm.sp - numArgs - <span class="dv">1</span></span>
<span id="cb449-8"><a href="#cb449-8"></a></span>
<span id="cb449-9"><a href="#cb449-9"></a>    <span class="kw">if</span> result != <span class="ot">nil</span> {</span>
<span id="cb449-10"><a href="#cb449-10"></a>        vm.push(result)</span>
<span id="cb449-11"><a href="#cb449-11"></a>    } <span class="kw">else</span> {</span>
<span id="cb449-12"><a href="#cb449-12"></a>        vm.push(Null)</span>
<span id="cb449-13"><a href="#cb449-13"></a>    }</span>
<span id="cb449-14"><a href="#cb449-14"></a></span>
<span id="cb449-15"><a href="#cb449-15"></a>    <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb449-16"><a href="#cb449-16"></a>}</span></code></pre></div>
<p>Here’s finally the <em>how</em> of executing built-in functions.</p>
<p>We take the arguments from the stack (without removing them yet) and pass them to the <code>object.BuiltinFunction</code> that’s contained in the <code>*object.Builtin</code>’s <code>Fn</code> field. That’s the central part, the execution of the built-in function itself.</p>
<p>After that, we decrease the <code>vm.sp</code> to take the arguments and the function we just executed off the stack. As per our calling convention, doing that is the duty of the VM.</p>
<p>Once the stack is cleaned up, we check whether the result of the call is <code>nil</code> or not. If it’s not <code>nil</code>, we push the result on to the stack; but if it is, we push <code>vm.Null</code>. That’s the bring-your-own-null strategy at work again.</p>
<p>And now, to the sound of us whispering an impressed <em>nice</em> under our breath, we can see that every built-in function works as expected – in our compiler and our VM:</p>
<div class="sourceCode" id="cb450"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb450-1"><a href="#cb450-1"></a>$ go test ./vm</span>
<span id="cb450-2"><a href="#cb450-2"></a>ok      monkey/vm   0.045s</span></code></pre></div>
<p>But while that euphoric <code>"ok"</code> screams for celebration, as a last step, we also have to take care of the REPL. Although we define every built-in function on the compiler’s symbol table in the <code>compiler.New</code> function, that doesn’t have an effect on the REPL and it won’t find those built-in functions.</p>
<p>That’s because we’re not using <code>compiler.New</code> but <code>compiler.NewWithState</code> in the REPL. <code>NewWithState</code> allows us to reuse one symbol table across REPL prompts by overwriting the symbol table that’s been initialized by <code>New</code> with a global one. And since no built-in functions have been defined in this global table, that’s what we have to change:</p>
<div class="sourceCode" id="cb451"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb451-1"><a href="#cb451-1"></a><span class="co">// repl/repl.go</span></span>
<span id="cb451-2"><a href="#cb451-2"></a></span>
<span id="cb451-3"><a href="#cb451-3"></a><span class="kw">func</span> Start(in io.Reader, out io.Writer) {</span>
<span id="cb451-4"><a href="#cb451-4"></a>    <span class="co">// [...]</span></span>
<span id="cb451-5"><a href="#cb451-5"></a></span>
<span id="cb451-6"><a href="#cb451-6"></a>    symbolTable := compiler.NewSymbolTable()</span>
<span id="cb451-7"><a href="#cb451-7"></a>    <span class="kw">for</span> i, v := <span class="kw">range</span> object.Builtins {</span>
<span id="cb451-8"><a href="#cb451-8"></a>        symbolTable.DefineBuiltin(i, v.Name)</span>
<span id="cb451-9"><a href="#cb451-9"></a>    }</span>
<span id="cb451-10"><a href="#cb451-10"></a></span>
<span id="cb451-11"><a href="#cb451-11"></a>    <span class="kw">for</span> {</span>
<span id="cb451-12"><a href="#cb451-12"></a>        <span class="co">// [...]</span></span>
<span id="cb451-13"><a href="#cb451-13"></a>    }</span>
<span id="cb451-14"><a href="#cb451-14"></a>}</span></code></pre></div>
<p>With that, we can use built-in functions even in our REPL:</p>
<div class="sourceCode" id="cb452"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb452-1"><a href="#cb452-1"></a>$ go build -o monkey . &amp;&amp; ./monkey</span>
<span id="cb452-2"><a href="#cb452-2"></a>Hello mrnugget! This is the Monkey programming language!</span>
<span id="cb452-3"><a href="#cb452-3"></a>Feel free to type in commands</span>
<span id="cb452-4"><a href="#cb452-4"></a>&gt;&gt; let array = [1, 2, 3];</span>
<span id="cb452-5"><a href="#cb452-5"></a>[1, 2, 3]</span>
<span id="cb452-6"><a href="#cb452-6"></a>&gt;&gt; len(array)</span>
<span id="cb452-7"><a href="#cb452-7"></a>3</span>
<span id="cb452-8"><a href="#cb452-8"></a>&gt;&gt; push(array, 1)</span>
<span id="cb452-9"><a href="#cb452-9"></a>[1, 2, 3, 1]</span>
<span id="cb452-10"><a href="#cb452-10"></a>&gt;&gt; rest(array)</span>
<span id="cb452-11"><a href="#cb452-11"></a>[2, 3]</span>
<span id="cb452-12"><a href="#cb452-12"></a>&gt;&gt; first(array)</span>
<span id="cb452-13"><a href="#cb452-13"></a>1</span>
<span id="cb452-14"><a href="#cb452-14"></a>&gt;&gt; last(array)</span>
<span id="cb452-15"><a href="#cb452-15"></a>3</span>
<span id="cb452-16"><a href="#cb452-16"></a>&gt;&gt; first(rest(push(array, 4)))</span>
<span id="cb452-17"><a href="#cb452-17"></a>2</span></code></pre></div>
<p>Perfect! That’s a far better output to end a chapter on than the measly <code>ok</code> of our tests.</p>
<p>Now, onwards, to the final frontier of function implementation: closures.</p>
<h1 id="closures">Closures</h1>
<p>It’s time to complete our new implementation of Monkey and add the last missing piece – closures. This is by far the most precious and one of those category-defining features in the realm of bytecode compilers and virtual machines. There aren’t that many that support it and soon enough, you’ll see why that is.</p>
<p>First, a little refresher of what closures are and how they work. Here’s the prime example:</p>
<div class="sourceCode" id="cb453"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb453-1"><a href="#cb453-1"></a><span class="kw">let</span> newAdder <span class="op">=</span> fn(a) {</span>
<span id="cb453-2"><a href="#cb453-2"></a>  <span class="kw">let</span> adder <span class="op">=</span> fn(b) { a <span class="op">+</span> b<span class="op">;</span> }<span class="op">;</span></span>
<span id="cb453-3"><a href="#cb453-3"></a>  <span class="cf">return</span> adder<span class="op">;</span></span>
<span id="cb453-4"><a href="#cb453-4"></a>}<span class="op">;</span></span>
<span id="cb453-5"><a href="#cb453-5"></a></span>
<span id="cb453-6"><a href="#cb453-6"></a><span class="kw">let</span> addTwo <span class="op">=</span> newAdder(<span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb453-7"><a href="#cb453-7"></a>addTwo(<span class="dv">3</span>)<span class="op">;</span> <span class="co">// =&gt; 5</span></span></code></pre></div>
<p>The <code>newAdder</code> function returns a closure called <code>adder</code>. It’s a closure because it not only makes use of its own parameter, <code>b</code>, but also accesses <code>a</code>, the parameter defined in <code>newAdder</code>. After <code>adder</code> is returned from <code>newAdder</code> it still has access to <em>both</em> of them. That’s what makes <code>adder</code> a closure and why <code>addTwo</code> returns <code>5</code> when called with <code>3</code> – it’s a version of the <code>adder</code> function that can still access the previous value of <code>a</code>, which was <code>2</code>.</p>
<p>That’s “what’s a closure?” in six lines of code.</p>
<p>Our interpreter in <em>Writing An Interpreter In Go</em> also had support for closures and while that implementation is markedly different from what we’re going to build in this chapter, a little recap helps to set the stage, so here’s a rough sketch of our path to closures in <em>Writing An Interpreter In Go</em>.</p>
<p>The first thing we did was to add an <code>Env</code> field to <code>object.Function</code> to hold an <code>*object.Environment</code>, which is what we used to store global and local bindings. When we evaluated an <code>*ast.FunctionLiteral</code>, which turns it into an <code>*object.Function</code>, we put a pointer to the <em>current environment</em> in the <code>Env</code> field of the new function.</p>
<p>When the function was called, we evaluated its body in <em>this environment</em>, the one we put in the <code>Env</code> field. The practical effect of all this was that functions always had access to the bindings of the environment in which they were defined, even much later and in any place. This ability is what makes closures <em>closures</em> and separates them from normal functions.</p>
<p>The reason I wanted to go over the old implementation again is because of how closely it maps to the way we think about closures: they’re functions that “close over” their environment at the time of their definition, wrap around it and carry it with them, just like the pointer to the <code>*object.Environment</code> in the <code>Env</code> field. That’s the most important thing to understand about closures.</p>
<p>Now we need to implement closures again, only this time we don’t have a tree-walking interpreter. We have a compiler and a VM and that poses a fundamental problem.</p>
<h2 id="the-problem">The Problem</h2>
<p>It’s not that we don’t <em>evaluate</em> function literals anymore; the problem is not the <em>evaluation</em> per se. In our current implementation we still turn <code>*ast.FunctionLiteral</code>s into <code>object.Object</code>s; meaning that we turn them into something that can be passed around and, most importantly, something that can be called and executed. In that sense, the semantics haven’t changed.</p>
<p>What’s changed are the time and place when closures are created.</p>
<p>In our old interpreter the conversion of a function literal into an <code>object.Function</code> and the closing over the environment, which sets the <code>Env</code> field on said <code>object.Function</code>, happened at <em>exactly the same time</em> and even <em>in the same code block</em>.</p>
<p>In our new Monkey implementation this does not only happen at different times, but also in two different packages: we compile function literals in our compiler and we build up an environment in our VM. The consequence is that we can’t close over an environment when we compile functions because, well, there is no environment yet.</p>
<p>Let’s try to make this more tangible by mentally following the snippet from above as it moves through our current implementation.</p>
<p>The first thing that happens is that we compile it. Both functions – <code>newAdder</code> and <code>adder</code> – are turned into a series of instructions and added to the constant pool. After that, we emit <code>OpConstant</code> instructions to instruct the VM to load the functions on to the stack. At that point, compilation is done and nobody knows yet which value <code>a</code> is going to have.</p>
<p>In the VM, however, the value is known as soon as we execute <code>newAdder</code>. By that time, though, <code>adder</code> has already been compiled and its instructions will simply be loaded on to the stack, contained in an <code>*object.CompiledFunction</code>, and returned from <code>newAdder</code> – without any chance to “close over” <code>a</code>.</p>
<p>You can see where the challenge lies. In the VM, we need to get the value of <code>a</code> into an <em>already-compiled</em> <code>adder</code> function before it’s returned from <code>newAdder</code>, and we need to do it in such a way that an <code>adder</code> later on can access it.</p>
<p>Yes, that means the compiler must have previously emitted the instructions that get <code>a</code> on to the stack whenever an <code>adder</code> references it. Quite the feat, considering that <code>a</code> is neither a local nor a global binding and its “location” changes between the time we execute <code>newAdder</code> and, later on, call the returned <code>adder</code> function. First it’s in scope and then it… well, then it has to be <em>somewhere</em> where <code>adder</code> can still access it.</p>
<p>In other words: we need to give <em>compiled</em> functions the ability to hold bindings that are only created at run time and their instructions must already reference said bindings. And then, at run time, we need to instruct the VM to make these bindings available to the function at the right time.</p>
<p>Quite the tall order, isn’t it? On top of that comes the fact that we don’t have a single environment anymore. What was the environment in our tree-walking interpreter is now scattered among the globals store and different regions of the stack, all of which can be wiped out with a return from a function.</p>
<p>If you just let out a little “whew”, here’s another one: we’re also still facing the problem of nested local bindings. That’s fine, though, because the solution to this problem is closely entwined with our future implementation of closures. You can, of course, implement nested local bindings without thinking about closures for one second, but we’re going to get two features for one implementation.</p>
<p>Let’s get to work and make a plan.</p>
<h2 id="the-plan-1">The Plan</h2>
<p>There is not one true way to implement closures. On the contrary, there are quite a few, all of them peculiar in their own way. Not all of them are publicly documented in prose, most only in code, and that is often optimized to save the last byte of memory and gain precious milliseconds in performance, which – generally speaking – doesn’t help its accessibility. And if you narrow the search down to bytecode compilers and virtual machines, a willingness to dig into the code becomes a hard requirement.</p>
<p>Our implementation will be based on the resources and codebases I found most accessible and transferable to Monkey. Leading here as the main influence is <a href="https://www.gnu.org/software/guile/">GNU Guile</a>, a Scheme implementation with amazing debugging tools. It’s followed by multiple implementations of Lua and the beautiful codebase of <a href="https://github.com/munificent/wren">Wren</a>, which has previously inspired <em>Writing An Interpreter In Go</em>. <a href="http://matt.might.net/articles">Matt Might’s writing</a> on the topic of compiling closures was also invaluable and comes highly recommended, in case you want to dive even deeper into the topic.</p>
<p>Before we get down to the details and formulate a plan for our implementation, we need to expand our vocabulary and introduce a new term, which can be found at the center of all of the previously-mentioned implementations and resources. It’s this one: “free variable”. Take another look at this part of the code snippet:</p>
<div class="sourceCode" id="cb454"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb454-1"><a href="#cb454-1"></a><span class="kw">let</span> newAdder <span class="op">=</span> fn(a) {</span>
<span id="cb454-2"><a href="#cb454-2"></a>  <span class="kw">let</span> adder <span class="op">=</span> fn(b) { a <span class="op">+</span> b<span class="op">;</span> }<span class="op">;</span></span>
<span id="cb454-3"><a href="#cb454-3"></a>  <span class="cf">return</span> adder<span class="op">;</span></span>
<span id="cb454-4"><a href="#cb454-4"></a>}<span class="op">;</span></span></code></pre></div>
<p>From <code>adder</code>’s point of view <code>a</code> is <em>a free variable</em>. I have to admit that this was never an intuitive name to me, but <a href="https://en.wikipedia.org/wiki/Free_variables_and_bound_variables">free variables</a> are those which are neither defined in the current local scope nor are they parameters of the current function. Since they’re not bound to the current scope, they are free. Another definition explains that free variables are those that are used locally, but defined in an enclosing scope.</p>
<p>Implementing closures with a compiler and a VM revolves around free variables. The compiler needs to detect references to them and emit instructions that will load them on to the stack, even later on, when they’re already out of scope. In the object system, compiled functions must be able to carry free variables with them. And the VM must not only resolve references to free variables correctly, but also store them on compiled functions.</p>
<p>Here’s how we’re going to pull this off: we’re going to turn every function into a closure. Yes, not every function <em>is</em> a closure, but we’ll treat them as such anyway. That’s a common way to keep the architectures of the compiler and the VM simple and also helps us by reducing some of the cognitive load. (If you’re after performance, you’ll find a ton of possible optimizations created through this decision.)</p>
<p>Let’s translate this into practical terms. First, we’ll define a new object in our <code>object</code> package, called <code>Closure</code>. It will have a pointer to an <code>*object.CompiledFunction</code> and a place to store the free variables it references and carries around.</p>
<p>The compilation of functions itself, though, won’t change. We’ll still compile an <code>*ast.FunctionLiteral</code> into an <code>*object.CompiledFunction</code> and add it to the constant pool.</p>
<p>But while compiling the function’s body we’ll inspect each symbol we resolve to find out whether it’s a reference to a free variable. If it is, we won’t emit an <code>OpGetLocal</code> or a <code>OpGetGlobal</code> instruction, but instead a new opcode that loads the value from the “store for the free variables” part of the <code>object.Closure</code>. We’ll have to extend our <code>SymbolTable</code> so it can take care of this part for us.</p>
<p>After the function’s body is compiled and we left its scope in the compiler, we’ll check whether it did reference any free variables. Our upgraded <code>SymbolTable</code> should then tell us how many were referenced and in which scope they were originally defined. This last attribute is especially important, since the next step is to transfer these free variables to the compiled function – at run time. For that, we’ll first have to emit instructions that get the referenced free variables on to the stack and in order to do that we have to know in which scope the bindings were created. Otherwise we won’t know which instructions to emit.</p>
<p>After that we’ll emit another new opcode to tell the VM to fetch the specified function from the constant pool, take the just-pushed free variables off the stack and transfer them to the compiled function. This is what turns the <code>*object.CompiledFunction</code> into an <code>*object.Closure</code> and pushes it on to the stack. While on the stack it can be called just like an <code>*object.CompiledFunction</code>s before, except that it now has access to the free variables its instructions reference. It’s been turned into a closure.</p>
<p>In summary: detect references to free variables while compiling a function, get the referenced values on to the stack, merge the values and the compiled function into a closure and leave it on the stack where it can then be called. Let’s go.</p>
<h2 id="everythings-a-closure">Everything’s a closure</h2>
<p>As always, we are working towards our goal by taking baby steps. In order to make that possible and avoid having to take risky strides later on, our first step is to start treating every function as a closure. Again, not every function <em>is</em> a closure, but it can nonetheless be treated as one and that makes adding “real” closures later on incredibly smooth. You’ll see.</p>
<p>In order to treat functions as closures, we need to represent them as such, so here’s our new Monkey object, the <code>Closure</code>:</p>
<div class="sourceCode" id="cb455"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb455-1"><a href="#cb455-1"></a><span class="co">// object/object.go</span></span>
<span id="cb455-2"><a href="#cb455-2"></a></span>
<span id="cb455-3"><a href="#cb455-3"></a><span class="kw">const</span> (</span>
<span id="cb455-4"><a href="#cb455-4"></a>    <span class="co">// [...]</span></span>
<span id="cb455-5"><a href="#cb455-5"></a>    CLOSURE_OBJ = <span class="st">&quot;CLOSURE&quot;</span></span>
<span id="cb455-6"><a href="#cb455-6"></a>)</span>
<span id="cb455-7"><a href="#cb455-7"></a></span>
<span id="cb455-8"><a href="#cb455-8"></a><span class="kw">type</span> Closure <span class="kw">struct</span> {</span>
<span id="cb455-9"><a href="#cb455-9"></a>    Fn   *CompiledFunction</span>
<span id="cb455-10"><a href="#cb455-10"></a>    Free []Object</span>
<span id="cb455-11"><a href="#cb455-11"></a>}</span>
<span id="cb455-12"><a href="#cb455-12"></a></span>
<span id="cb455-13"><a href="#cb455-13"></a><span class="kw">func</span> (c *Closure) Type() ObjectType { <span class="kw">return</span> CLOSURE_OBJ }</span>
<span id="cb455-14"><a href="#cb455-14"></a><span class="kw">func</span> (c *Closure) Inspect() <span class="dt">string</span> {</span>
<span id="cb455-15"><a href="#cb455-15"></a>    <span class="kw">return</span> fmt.Sprintf(<span class="st">&quot;Closure[%p]&quot;</span>, c)</span>
<span id="cb455-16"><a href="#cb455-16"></a>}</span></code></pre></div>
<p>It has a pointer to the function it wraps, <code>Fn</code>, and a place to keep the free variables it carries around, <code>Free</code>. Semantically speaking, the latter is the equivalent to the <code>Env</code> field we added to the <code>*object.Function</code> in <em>Writing An Interpreter in Go</em>.</p>
<p>Since closures are created at run time, we can’t use <code>object.Closure</code> in the compiler. What we need to do instead is send a message into the future. This message, a new opcode called <code>OpClosure</code>, is sent by the compiler to the VM and tells it to wrap the specified <code>*object.CompiledFunction</code> in an <code>*object.Closure</code>:</p>
<div class="sourceCode" id="cb456"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb456-1"><a href="#cb456-1"></a><span class="co">// code/code.go</span></span>
<span id="cb456-2"><a href="#cb456-2"></a></span>
<span id="cb456-3"><a href="#cb456-3"></a><span class="kw">const</span> (</span>
<span id="cb456-4"><a href="#cb456-4"></a>    <span class="co">// [...]</span></span>
<span id="cb456-5"><a href="#cb456-5"></a></span>
<span id="cb456-6"><a href="#cb456-6"></a>    OpClosure</span>
<span id="cb456-7"><a href="#cb456-7"></a>)</span>
<span id="cb456-8"><a href="#cb456-8"></a></span>
<span id="cb456-9"><a href="#cb456-9"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb456-10"><a href="#cb456-10"></a>    <span class="co">// [...]</span></span>
<span id="cb456-11"><a href="#cb456-11"></a></span>
<span id="cb456-12"><a href="#cb456-12"></a>    OpClosure: {<span class="st">&quot;OpClosure&quot;</span>, []<span class="dt">int</span>{<span class="dv">2</span>, <span class="dv">1</span>}},</span>
<span id="cb456-13"><a href="#cb456-13"></a>}</span></code></pre></div>
<p>Now, this is interesting. <code>OpClosure</code> has <em>two</em> operands! We haven’t had that before. Allow me to explain.</p>
<p>The first operand, two bytes wide, is the <em>constant index</em>. It specifies where in the constant pool we can find the <code>*object.CompiledFunction</code> that’s to be converted into a closure. It’s two bytes wide, because the operand of <code>OpConstant</code> is also two bytes wide. By keeping this consistent we ensure that we never run into the case where we can load a function from the constant pool and put it on the stack, but can’t convert it into a closure, because it’s index is too high.</p>
<p>The second operand, one byte wide, specifies how many <em>free variables</em> sit on the stack and need to be transferred to the about-to-be-created closure. Why one byte? Well, 256 free variables should be plenty. If a Monkey function needs more, I’m happy to say that this VM will refuse to execute it.</p>
<p>We don’t have to worry too much about the second parameter, since right now we’re only concerned about treating functions as closures, not about implementing free variables. That comes later.</p>
<p>What we need to take care of, though, is that our tooling can support an opcode with two operands. At the moment, it kinda does, but not fully and without any tests. Let’s change that by adding them:</p>
<div class="sourceCode" id="cb457"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb457-1"><a href="#cb457-1"></a><span class="co">// code/code_test.go</span></span>
<span id="cb457-2"><a href="#cb457-2"></a></span>
<span id="cb457-3"><a href="#cb457-3"></a><span class="kw">func</span> TestMake(t *testing.T) {</span>
<span id="cb457-4"><a href="#cb457-4"></a>    tests := []<span class="kw">struct</span> {</span>
<span id="cb457-5"><a href="#cb457-5"></a>        op       Opcode</span>
<span id="cb457-6"><a href="#cb457-6"></a>        operands []<span class="dt">int</span></span>
<span id="cb457-7"><a href="#cb457-7"></a>        expected []<span class="dt">byte</span></span>
<span id="cb457-8"><a href="#cb457-8"></a>    }{</span>
<span id="cb457-9"><a href="#cb457-9"></a>        <span class="co">// [...]</span></span>
<span id="cb457-10"><a href="#cb457-10"></a>        {OpClosure, []<span class="dt">int</span>{<span class="dv">65534</span>, <span class="dv">255</span>}, []<span class="dt">byte</span>{<span class="dt">byte</span>(OpClosure), <span class="dv">255</span>, <span class="dv">254</span>, <span class="dv">255</span>}},</span>
<span id="cb457-11"><a href="#cb457-11"></a>    }</span>
<span id="cb457-12"><a href="#cb457-12"></a></span>
<span id="cb457-13"><a href="#cb457-13"></a>    <span class="co">// [...]</span></span>
<span id="cb457-14"><a href="#cb457-14"></a>}</span>
<span id="cb457-15"><a href="#cb457-15"></a></span>
<span id="cb457-16"><a href="#cb457-16"></a><span class="kw">func</span> TestInstructionsString(t *testing.T) {</span>
<span id="cb457-17"><a href="#cb457-17"></a>    instructions := []Instructions{</span>
<span id="cb457-18"><a href="#cb457-18"></a>        Make(OpAdd),</span>
<span id="cb457-19"><a href="#cb457-19"></a>        Make(OpGetLocal, <span class="dv">1</span>),</span>
<span id="cb457-20"><a href="#cb457-20"></a>        Make(OpConstant, <span class="dv">2</span>),</span>
<span id="cb457-21"><a href="#cb457-21"></a>        Make(OpConstant, <span class="dv">65535</span>),</span>
<span id="cb457-22"><a href="#cb457-22"></a>        Make(OpClosure, <span class="dv">65535</span>, <span class="dv">255</span>),</span>
<span id="cb457-23"><a href="#cb457-23"></a>    }</span>
<span id="cb457-24"><a href="#cb457-24"></a></span>
<span id="cb457-25"><a href="#cb457-25"></a>    expected := <span class="st">`0000 OpAdd</span></span>
<span id="cb457-26"><a href="#cb457-26"></a><span class="st">0001 OpGetLocal 1</span></span>
<span id="cb457-27"><a href="#cb457-27"></a><span class="st">0003 OpConstant 2</span></span>
<span id="cb457-28"><a href="#cb457-28"></a><span class="st">0006 OpConstant 65535</span></span>
<span id="cb457-29"><a href="#cb457-29"></a><span class="st">0009 OpClosure 65535 255</span></span>
<span id="cb457-30"><a href="#cb457-30"></a><span class="st">`</span></span>
<span id="cb457-31"><a href="#cb457-31"></a></span>
<span id="cb457-32"><a href="#cb457-32"></a>    <span class="co">// [...]</span></span>
<span id="cb457-33"><a href="#cb457-33"></a>}</span>
<span id="cb457-34"><a href="#cb457-34"></a></span>
<span id="cb457-35"><a href="#cb457-35"></a><span class="kw">func</span> TestReadOperands(t *testing.T) {</span>
<span id="cb457-36"><a href="#cb457-36"></a>    tests := []<span class="kw">struct</span> {</span>
<span id="cb457-37"><a href="#cb457-37"></a>        op        Opcode</span>
<span id="cb457-38"><a href="#cb457-38"></a>        operands  []<span class="dt">int</span></span>
<span id="cb457-39"><a href="#cb457-39"></a>        bytesRead <span class="dt">int</span></span>
<span id="cb457-40"><a href="#cb457-40"></a>    }{</span>
<span id="cb457-41"><a href="#cb457-41"></a>        <span class="co">// [...]</span></span>
<span id="cb457-42"><a href="#cb457-42"></a>        {OpClosure, []<span class="dt">int</span>{<span class="dv">65535</span>, <span class="dv">255</span>}, <span class="dv">3</span>},</span>
<span id="cb457-43"><a href="#cb457-43"></a>    }</span>
<span id="cb457-44"><a href="#cb457-44"></a></span>
<span id="cb457-45"><a href="#cb457-45"></a>    <span class="co">// [...]</span></span>
<span id="cb457-46"><a href="#cb457-46"></a>}</span></code></pre></div>
<p>When we now run the tests of the <code>code</code> package, we see this:</p>
<div class="sourceCode" id="cb458"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb458-1"><a href="#cb458-1"></a>$ go test ./code</span>
<span id="cb458-2"><a href="#cb458-2"></a>--- FAIL: TestInstructionsString (0.00s)</span>
<span id="cb458-3"><a href="#cb458-3"></a> code_test.go:56: instructions wrongly formatted.</span>
<span id="cb458-4"><a href="#cb458-4"></a>  want=&quot;0000 OpAdd\n0001 OpGetLocal 1\n0003 OpConstant 2\n\</span>
<span id="cb458-5"><a href="#cb458-5"></a>    0006 OpConstant 65535\n0009 OpClosure 65535 255\n&quot;</span>
<span id="cb458-6"><a href="#cb458-6"></a>  got=&quot;0000 OpAdd\n0001 OpGetLocal 1\n0003 OpConstant 2\n\</span>
<span id="cb458-7"><a href="#cb458-7"></a>    0006 OpConstant 65535\n\</span>
<span id="cb458-8"><a href="#cb458-8"></a>    0009 ERROR: unhandled operandCount for OpClosure\n\n&quot;</span>
<span id="cb458-9"><a href="#cb458-9"></a>FAIL</span>
<span id="cb458-10"><a href="#cb458-10"></a>FAIL    monkey/code 0.007s</span></code></pre></div>
<p>Looks like we only need to fix the <code>fmtInstruction</code> method on <code>Instructions</code>:</p>
<div class="sourceCode" id="cb459"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb459-1"><a href="#cb459-1"></a><span class="co">// code/code.go</span></span>
<span id="cb459-2"><a href="#cb459-2"></a></span>
<span id="cb459-3"><a href="#cb459-3"></a><span class="kw">func</span> (ins Instructions) fmtInstruction(def *Definition, operands []<span class="dt">int</span>) <span class="dt">string</span> {</span>
<span id="cb459-4"><a href="#cb459-4"></a>    <span class="co">// [...]</span></span>
<span id="cb459-5"><a href="#cb459-5"></a></span>
<span id="cb459-6"><a href="#cb459-6"></a>    <span class="kw">switch</span> operandCount {</span>
<span id="cb459-7"><a href="#cb459-7"></a>    <span class="kw">case</span> <span class="dv">0</span>:</span>
<span id="cb459-8"><a href="#cb459-8"></a>        <span class="kw">return</span> def.Name</span>
<span id="cb459-9"><a href="#cb459-9"></a>    <span class="kw">case</span> <span class="dv">1</span>:</span>
<span id="cb459-10"><a href="#cb459-10"></a>        <span class="kw">return</span> fmt.Sprintf(<span class="st">&quot;%s %d&quot;</span>, def.Name, operands[<span class="dv">0</span>])</span>
<span id="cb459-11"><a href="#cb459-11"></a>    <span class="kw">case</span> <span class="dv">2</span>:</span>
<span id="cb459-12"><a href="#cb459-12"></a>        <span class="kw">return</span> fmt.Sprintf(<span class="st">&quot;%s %d %d&quot;</span>, def.Name, operands[<span class="dv">0</span>], operands[<span class="dv">1</span>])</span>
<span id="cb459-13"><a href="#cb459-13"></a>    }</span>
<span id="cb459-14"><a href="#cb459-14"></a></span>
<span id="cb459-15"><a href="#cb459-15"></a>    <span class="co">// [...]</span></span>
<span id="cb459-16"><a href="#cb459-16"></a>}</span></code></pre></div>
<p>Another <code>case</code> branch and we’re back in business, because <code>code.Make</code> and <code>code.ReadOperands</code> can already handle two operands per opcode:</p>
<div class="sourceCode" id="cb460"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb460-1"><a href="#cb460-1"></a>$ go test ./code</span>
<span id="cb460-2"><a href="#cb460-2"></a>ok      monkey/code 0.008s</span></code></pre></div>
<p>We’ve paved the way and can start to treat functions as closures.</p>
<p>In compiler terms, that means we will now emit <code>OpClosure</code> instructions instead of <code>OpConstant</code> ones to get functions on the stack. Everything else will stay the same for now. We’ll compile functions to <code>*object.CompiledFunction</code>s and we’ll add them to the constant pool. But instead of taking the index for the constant pool and using it as an operand to <code>OpConstant</code>, we’ll give it to an <code>OpClosure</code> instruction instead. As the second operand to <code>OpClosure</code>, the number of free variables sitting on the stack, we’ll use <code>0</code> for now.</p>
<p>If we were to jump straight into <code>compiler.go</code> now and replace the <code>OpConstant</code> instructions with <code>OpClosure</code> ones, we’d end up with a whole lot of failing compiler tests. Unintended failing tests are always a bad thing, so let’s get ahead of the issue and adjust our tests first. All we need to do is change the <code>OpConstant</code> into an <code>OpClosure</code> wherever we expected functions to be loaded on to the stack:</p>
<div class="sourceCode" id="cb461"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb461-1"><a href="#cb461-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb461-2"><a href="#cb461-2"></a></span>
<span id="cb461-3"><a href="#cb461-3"></a><span class="kw">func</span> TestFunctions(t *testing.T) {</span>
<span id="cb461-4"><a href="#cb461-4"></a>    tests := []compilerTestCase{</span>
<span id="cb461-5"><a href="#cb461-5"></a>        {</span>
<span id="cb461-6"><a href="#cb461-6"></a>            input: <span class="st">`fn() { return 5 + 10 }`</span>,</span>
<span id="cb461-7"><a href="#cb461-7"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb461-8"><a href="#cb461-8"></a>                <span class="co">// [...]</span></span>
<span id="cb461-9"><a href="#cb461-9"></a>            },</span>
<span id="cb461-10"><a href="#cb461-10"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb461-11"><a href="#cb461-11"></a>                code.Make(code.OpClosure, <span class="dv">2</span>, <span class="dv">0</span>),</span>
<span id="cb461-12"><a href="#cb461-12"></a>                code.Make(code.OpPop),</span>
<span id="cb461-13"><a href="#cb461-13"></a>            },</span>
<span id="cb461-14"><a href="#cb461-14"></a>        },</span>
<span id="cb461-15"><a href="#cb461-15"></a>        {</span>
<span id="cb461-16"><a href="#cb461-16"></a>            input: <span class="st">`fn() { 5 + 10 }`</span>,</span>
<span id="cb461-17"><a href="#cb461-17"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb461-18"><a href="#cb461-18"></a>                <span class="co">// [...]</span></span>
<span id="cb461-19"><a href="#cb461-19"></a>            },</span>
<span id="cb461-20"><a href="#cb461-20"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb461-21"><a href="#cb461-21"></a>                code.Make(code.OpClosure, <span class="dv">2</span>, <span class="dv">0</span>),</span>
<span id="cb461-22"><a href="#cb461-22"></a>                code.Make(code.OpPop),</span>
<span id="cb461-23"><a href="#cb461-23"></a>            },</span>
<span id="cb461-24"><a href="#cb461-24"></a>        },</span>
<span id="cb461-25"><a href="#cb461-25"></a>        {</span>
<span id="cb461-26"><a href="#cb461-26"></a>            input: <span class="st">`fn() { 1; 2 }`</span>,</span>
<span id="cb461-27"><a href="#cb461-27"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb461-28"><a href="#cb461-28"></a>                <span class="co">// [...]</span></span>
<span id="cb461-29"><a href="#cb461-29"></a>            },</span>
<span id="cb461-30"><a href="#cb461-30"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb461-31"><a href="#cb461-31"></a>                code.Make(code.OpClosure, <span class="dv">2</span>, <span class="dv">0</span>),</span>
<span id="cb461-32"><a href="#cb461-32"></a>                code.Make(code.OpPop),</span>
<span id="cb461-33"><a href="#cb461-33"></a>            },</span>
<span id="cb461-34"><a href="#cb461-34"></a>        },</span>
<span id="cb461-35"><a href="#cb461-35"></a>    }</span>
<span id="cb461-36"><a href="#cb461-36"></a></span>
<span id="cb461-37"><a href="#cb461-37"></a>    runCompilerTests(t, tests)</span>
<span id="cb461-38"><a href="#cb461-38"></a>}</span></code></pre></div>
<p>This looks like more than it is, but that’s only because I want to give you some context to these changes. In the <code>expectedInstructions</code> of each test case we change the previous <code>OpConstant</code> to <code>OpClosure</code> and add the second operand, <code>0</code>. That’s it. Now we need to do the same in the other tests where we load functions:</p>
<div class="sourceCode" id="cb462"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb462-1"><a href="#cb462-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb462-2"><a href="#cb462-2"></a></span>
<span id="cb462-3"><a href="#cb462-3"></a><span class="kw">func</span> TestFunctionsWithoutReturnValue(t *testing.T) {</span>
<span id="cb462-4"><a href="#cb462-4"></a>    tests := []compilerTestCase{</span>
<span id="cb462-5"><a href="#cb462-5"></a>        {</span>
<span id="cb462-6"><a href="#cb462-6"></a>            input: <span class="st">`fn() { }`</span>,</span>
<span id="cb462-7"><a href="#cb462-7"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb462-8"><a href="#cb462-8"></a>                <span class="co">// [...]</span></span>
<span id="cb462-9"><a href="#cb462-9"></a>            },</span>
<span id="cb462-10"><a href="#cb462-10"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb462-11"><a href="#cb462-11"></a>                code.Make(code.OpClosure, <span class="dv">0</span>, <span class="dv">0</span>),</span>
<span id="cb462-12"><a href="#cb462-12"></a>                code.Make(code.OpPop),</span>
<span id="cb462-13"><a href="#cb462-13"></a>            },</span>
<span id="cb462-14"><a href="#cb462-14"></a>        },</span>
<span id="cb462-15"><a href="#cb462-15"></a>    }</span>
<span id="cb462-16"><a href="#cb462-16"></a></span>
<span id="cb462-17"><a href="#cb462-17"></a>    runCompilerTests(t, tests)</span>
<span id="cb462-18"><a href="#cb462-18"></a>}</span>
<span id="cb462-19"><a href="#cb462-19"></a></span>
<span id="cb462-20"><a href="#cb462-20"></a><span class="kw">func</span> TestFunctionCalls(t *testing.T) {</span>
<span id="cb462-21"><a href="#cb462-21"></a>    tests := []compilerTestCase{</span>
<span id="cb462-22"><a href="#cb462-22"></a>        {</span>
<span id="cb462-23"><a href="#cb462-23"></a>            input: <span class="st">`fn() { 24 }();`</span>,</span>
<span id="cb462-24"><a href="#cb462-24"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb462-25"><a href="#cb462-25"></a>                <span class="co">// [...]</span></span>
<span id="cb462-26"><a href="#cb462-26"></a>            },</span>
<span id="cb462-27"><a href="#cb462-27"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb462-28"><a href="#cb462-28"></a>                code.Make(code.OpClosure, <span class="dv">1</span>, <span class="dv">0</span>),</span>
<span id="cb462-29"><a href="#cb462-29"></a>                code.Make(code.OpCall, <span class="dv">0</span>),</span>
<span id="cb462-30"><a href="#cb462-30"></a>                code.Make(code.OpPop),</span>
<span id="cb462-31"><a href="#cb462-31"></a>            },</span>
<span id="cb462-32"><a href="#cb462-32"></a>        },</span>
<span id="cb462-33"><a href="#cb462-33"></a>        {</span>
<span id="cb462-34"><a href="#cb462-34"></a>            input: <span class="st">`</span></span>
<span id="cb462-35"><a href="#cb462-35"></a><span class="st">            let noArg = fn() { 24 };</span></span>
<span id="cb462-36"><a href="#cb462-36"></a><span class="st">            noArg();</span></span>
<span id="cb462-37"><a href="#cb462-37"></a><span class="st">            `</span>,</span>
<span id="cb462-38"><a href="#cb462-38"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb462-39"><a href="#cb462-39"></a>                <span class="co">// [...]</span></span>
<span id="cb462-40"><a href="#cb462-40"></a>            },</span>
<span id="cb462-41"><a href="#cb462-41"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb462-42"><a href="#cb462-42"></a>                code.Make(code.OpClosure, <span class="dv">1</span>, <span class="dv">0</span>),</span>
<span id="cb462-43"><a href="#cb462-43"></a>                code.Make(code.OpSetGlobal, <span class="dv">0</span>),</span>
<span id="cb462-44"><a href="#cb462-44"></a>                code.Make(code.OpGetGlobal, <span class="dv">0</span>),</span>
<span id="cb462-45"><a href="#cb462-45"></a>                code.Make(code.OpCall, <span class="dv">0</span>),</span>
<span id="cb462-46"><a href="#cb462-46"></a>                code.Make(code.OpPop),</span>
<span id="cb462-47"><a href="#cb462-47"></a>            },</span>
<span id="cb462-48"><a href="#cb462-48"></a>        },</span>
<span id="cb462-49"><a href="#cb462-49"></a>        {</span>
<span id="cb462-50"><a href="#cb462-50"></a>            input: <span class="st">`</span></span>
<span id="cb462-51"><a href="#cb462-51"></a><span class="st">            let oneArg = fn(a) { a };</span></span>
<span id="cb462-52"><a href="#cb462-52"></a><span class="st">            oneArg(1);</span></span>
<span id="cb462-53"><a href="#cb462-53"></a><span class="st">            `</span>,</span>
<span id="cb462-54"><a href="#cb462-54"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb462-55"><a href="#cb462-55"></a>                <span class="co">// [...]</span></span>
<span id="cb462-56"><a href="#cb462-56"></a>            },</span>
<span id="cb462-57"><a href="#cb462-57"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb462-58"><a href="#cb462-58"></a>                code.Make(code.OpClosure, <span class="dv">0</span>, <span class="dv">0</span>),</span>
<span id="cb462-59"><a href="#cb462-59"></a>                code.Make(code.OpSetGlobal, <span class="dv">0</span>),</span>
<span id="cb462-60"><a href="#cb462-60"></a>                code.Make(code.OpGetGlobal, <span class="dv">0</span>),</span>
<span id="cb462-61"><a href="#cb462-61"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb462-62"><a href="#cb462-62"></a>                code.Make(code.OpCall, <span class="dv">1</span>),</span>
<span id="cb462-63"><a href="#cb462-63"></a>                code.Make(code.OpPop),</span>
<span id="cb462-64"><a href="#cb462-64"></a>            },</span>
<span id="cb462-65"><a href="#cb462-65"></a>        },</span>
<span id="cb462-66"><a href="#cb462-66"></a>        {</span>
<span id="cb462-67"><a href="#cb462-67"></a>            input: <span class="st">`</span></span>
<span id="cb462-68"><a href="#cb462-68"></a><span class="st">            let manyArg = fn(a, b, c) { a; b; c };</span></span>
<span id="cb462-69"><a href="#cb462-69"></a><span class="st">            manyArg(1, 2, 3);</span></span>
<span id="cb462-70"><a href="#cb462-70"></a><span class="st">            `</span>,</span>
<span id="cb462-71"><a href="#cb462-71"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb462-72"><a href="#cb462-72"></a>                <span class="co">// [...]</span></span>
<span id="cb462-73"><a href="#cb462-73"></a>            },</span>
<span id="cb462-74"><a href="#cb462-74"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb462-75"><a href="#cb462-75"></a>                code.Make(code.OpClosure, <span class="dv">0</span>, <span class="dv">0</span>),</span>
<span id="cb462-76"><a href="#cb462-76"></a>                code.Make(code.OpSetGlobal, <span class="dv">0</span>),</span>
<span id="cb462-77"><a href="#cb462-77"></a>                code.Make(code.OpGetGlobal, <span class="dv">0</span>),</span>
<span id="cb462-78"><a href="#cb462-78"></a>                code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb462-79"><a href="#cb462-79"></a>                code.Make(code.OpConstant, <span class="dv">2</span>),</span>
<span id="cb462-80"><a href="#cb462-80"></a>                code.Make(code.OpConstant, <span class="dv">3</span>),</span>
<span id="cb462-81"><a href="#cb462-81"></a>                code.Make(code.OpCall, <span class="dv">3</span>),</span>
<span id="cb462-82"><a href="#cb462-82"></a>                code.Make(code.OpPop),</span>
<span id="cb462-83"><a href="#cb462-83"></a>            },</span>
<span id="cb462-84"><a href="#cb462-84"></a>        },</span>
<span id="cb462-85"><a href="#cb462-85"></a>    }</span>
<span id="cb462-86"><a href="#cb462-86"></a></span>
<span id="cb462-87"><a href="#cb462-87"></a>    runCompilerTests(t, tests)</span>
<span id="cb462-88"><a href="#cb462-88"></a>}</span>
<span id="cb462-89"><a href="#cb462-89"></a></span>
<span id="cb462-90"><a href="#cb462-90"></a><span class="kw">func</span> TestLetStatementScopes(t *testing.T) {</span>
<span id="cb462-91"><a href="#cb462-91"></a>    tests := []compilerTestCase{</span>
<span id="cb462-92"><a href="#cb462-92"></a>        {</span>
<span id="cb462-93"><a href="#cb462-93"></a>            input: <span class="st">`</span></span>
<span id="cb462-94"><a href="#cb462-94"></a><span class="st">            let num = 55;</span></span>
<span id="cb462-95"><a href="#cb462-95"></a><span class="st">            fn() { num }`</span>,</span>
<span id="cb462-96"><a href="#cb462-96"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb462-97"><a href="#cb462-97"></a>                <span class="co">// [...]</span></span>
<span id="cb462-98"><a href="#cb462-98"></a>            },</span>
<span id="cb462-99"><a href="#cb462-99"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb462-100"><a href="#cb462-100"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb462-101"><a href="#cb462-101"></a>                code.Make(code.OpSetGlobal, <span class="dv">0</span>),</span>
<span id="cb462-102"><a href="#cb462-102"></a>                code.Make(code.OpClosure, <span class="dv">1</span>, <span class="dv">0</span>),</span>
<span id="cb462-103"><a href="#cb462-103"></a>                code.Make(code.OpPop),</span>
<span id="cb462-104"><a href="#cb462-104"></a>            },</span>
<span id="cb462-105"><a href="#cb462-105"></a>        },</span>
<span id="cb462-106"><a href="#cb462-106"></a>        {</span>
<span id="cb462-107"><a href="#cb462-107"></a>            input: <span class="st">`</span></span>
<span id="cb462-108"><a href="#cb462-108"></a><span class="st">            fn() {</span></span>
<span id="cb462-109"><a href="#cb462-109"></a><span class="st">                let num = 55;</span></span>
<span id="cb462-110"><a href="#cb462-110"></a><span class="st">                num</span></span>
<span id="cb462-111"><a href="#cb462-111"></a><span class="st">            }</span></span>
<span id="cb462-112"><a href="#cb462-112"></a><span class="st">            `</span>,</span>
<span id="cb462-113"><a href="#cb462-113"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb462-114"><a href="#cb462-114"></a>                <span class="co">// [...]</span></span>
<span id="cb462-115"><a href="#cb462-115"></a>            },</span>
<span id="cb462-116"><a href="#cb462-116"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb462-117"><a href="#cb462-117"></a>                code.Make(code.OpClosure, <span class="dv">1</span>, <span class="dv">0</span>),</span>
<span id="cb462-118"><a href="#cb462-118"></a>                code.Make(code.OpPop),</span>
<span id="cb462-119"><a href="#cb462-119"></a>            },</span>
<span id="cb462-120"><a href="#cb462-120"></a>        },</span>
<span id="cb462-121"><a href="#cb462-121"></a>        {</span>
<span id="cb462-122"><a href="#cb462-122"></a>            input: <span class="st">`</span></span>
<span id="cb462-123"><a href="#cb462-123"></a><span class="st">            fn() {</span></span>
<span id="cb462-124"><a href="#cb462-124"></a><span class="st">                let a = 55;</span></span>
<span id="cb462-125"><a href="#cb462-125"></a><span class="st">                let b = 77;</span></span>
<span id="cb462-126"><a href="#cb462-126"></a><span class="st">                a + b</span></span>
<span id="cb462-127"><a href="#cb462-127"></a><span class="st">            }</span></span>
<span id="cb462-128"><a href="#cb462-128"></a><span class="st">            `</span>,</span>
<span id="cb462-129"><a href="#cb462-129"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb462-130"><a href="#cb462-130"></a>                <span class="co">// [...]</span></span>
<span id="cb462-131"><a href="#cb462-131"></a>            },</span>
<span id="cb462-132"><a href="#cb462-132"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb462-133"><a href="#cb462-133"></a>                code.Make(code.OpClosure, <span class="dv">2</span>, <span class="dv">0</span>),</span>
<span id="cb462-134"><a href="#cb462-134"></a>                code.Make(code.OpPop),</span>
<span id="cb462-135"><a href="#cb462-135"></a>            },</span>
<span id="cb462-136"><a href="#cb462-136"></a>        },</span>
<span id="cb462-137"><a href="#cb462-137"></a>    }</span>
<span id="cb462-138"><a href="#cb462-138"></a></span>
<span id="cb462-139"><a href="#cb462-139"></a>    runCompilerTests(t, tests)</span>
<span id="cb462-140"><a href="#cb462-140"></a>}</span>
<span id="cb462-141"><a href="#cb462-141"></a></span>
<span id="cb462-142"><a href="#cb462-142"></a><span class="kw">func</span> TestBuiltins(t *testing.T) {</span>
<span id="cb462-143"><a href="#cb462-143"></a>    tests := []compilerTestCase{</span>
<span id="cb462-144"><a href="#cb462-144"></a>        <span class="co">// [...]</span></span>
<span id="cb462-145"><a href="#cb462-145"></a>        {</span>
<span id="cb462-146"><a href="#cb462-146"></a>            input: <span class="st">`fn() { len([]) }`</span>,</span>
<span id="cb462-147"><a href="#cb462-147"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb462-148"><a href="#cb462-148"></a>                <span class="co">// [...]</span></span>
<span id="cb462-149"><a href="#cb462-149"></a>            },</span>
<span id="cb462-150"><a href="#cb462-150"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb462-151"><a href="#cb462-151"></a>                code.Make(code.OpClosure, <span class="dv">0</span>, <span class="dv">0</span>),</span>
<span id="cb462-152"><a href="#cb462-152"></a>                code.Make(code.OpPop),</span>
<span id="cb462-153"><a href="#cb462-153"></a>            },</span>
<span id="cb462-154"><a href="#cb462-154"></a>        },</span>
<span id="cb462-155"><a href="#cb462-155"></a>    }</span>
<span id="cb462-156"><a href="#cb462-156"></a></span>
<span id="cb462-157"><a href="#cb462-157"></a>    runCompilerTests(t, tests)</span>
<span id="cb462-158"><a href="#cb462-158"></a>}</span></code></pre></div>
<p>With updated expectations but an old compiler, we now have failing tests:</p>
<div class="sourceCode" id="cb463"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb463-1"><a href="#cb463-1"></a>$ go test ./compiler</span>
<span id="cb463-2"><a href="#cb463-2"></a>--- FAIL: TestFunctions (0.00s)</span>
<span id="cb463-3"><a href="#cb463-3"></a> compiler_test.go:688: testInstructions failed: wrong instructions length.</span>
<span id="cb463-4"><a href="#cb463-4"></a>  want=&quot;0000 OpClosure 2 0\n0004 OpPop\n&quot;</span>
<span id="cb463-5"><a href="#cb463-5"></a>  got =&quot;0000 OpConstant 2\n0003 OpPop\n&quot;</span>
<span id="cb463-6"><a href="#cb463-6"></a>--- FAIL: TestFunctionsWithoutReturnValue (0.00s)</span>
<span id="cb463-7"><a href="#cb463-7"></a> compiler_test.go:779: testInstructions failed: wrong instructions length.</span>
<span id="cb463-8"><a href="#cb463-8"></a>  want=&quot;0000 OpClosure 0 0\n0004 OpPop\n&quot;</span>
<span id="cb463-9"><a href="#cb463-9"></a>  got =&quot;0000 OpConstant 0\n0003 OpPop\n&quot;</span>
<span id="cb463-10"><a href="#cb463-10"></a>--- FAIL: TestFunctionCalls (0.00s)</span>
<span id="cb463-11"><a href="#cb463-11"></a> compiler_test.go:895: testInstructions failed: wrong instructions length.</span>
<span id="cb463-12"><a href="#cb463-12"></a>  want=&quot;0000 OpClosure 1 0\n0004 OpCall 0\n0006 OpPop\n&quot;</span>
<span id="cb463-13"><a href="#cb463-13"></a>  got =&quot;0000 OpConstant 1\n0003 OpCall 0\n0005 OpPop\n&quot;</span>
<span id="cb463-14"><a href="#cb463-14"></a>--- FAIL: TestLetStatementScopes (0.00s)</span>
<span id="cb463-15"><a href="#cb463-15"></a> compiler_test.go:992: testInstructions failed: wrong instructions length.</span>
<span id="cb463-16"><a href="#cb463-16"></a>  want=&quot;0000 OpConstant 0\n0003 OpSetGlobal 0\n\</span>
<span id="cb463-17"><a href="#cb463-17"></a>    0006 OpClosure 1 0\n0010 OpPop\n&quot;</span>
<span id="cb463-18"><a href="#cb463-18"></a>  got =&quot;0000 OpConstant 0\n0003 OpSetGlobal 0\n\</span>
<span id="cb463-19"><a href="#cb463-19"></a>    0006 OpConstant 1\n0009 OpPop\n&quot;</span>
<span id="cb463-20"><a href="#cb463-20"></a>--- FAIL: TestBuiltins (0.00s)</span>
<span id="cb463-21"><a href="#cb463-21"></a> compiler_test.go:1056: testInstructions failed: wrong instructions length.</span>
<span id="cb463-22"><a href="#cb463-22"></a>  want=&quot;0000 OpClosure 0 0\n0004 OpPop\n&quot;</span>
<span id="cb463-23"><a href="#cb463-23"></a>  got =&quot;0000 OpConstant 0\n0003 OpPop\n&quot;</span>
<span id="cb463-24"><a href="#cb463-24"></a>FAIL</span>
<span id="cb463-25"><a href="#cb463-25"></a>FAIL    monkey/compiler 0.010s</span></code></pre></div>
<p>As expected: we want an <code>OpClosure</code> instead of an <code>OpConstant</code>. Perfect. Now we can change the compiler and what a change it is:</p>
<div class="sourceCode" id="cb464"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb464-1"><a href="#cb464-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb464-2"><a href="#cb464-2"></a></span>
<span id="cb464-3"><a href="#cb464-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb464-4"><a href="#cb464-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb464-5"><a href="#cb464-5"></a>    <span class="co">// [...]</span></span>
<span id="cb464-6"><a href="#cb464-6"></a></span>
<span id="cb464-7"><a href="#cb464-7"></a>    <span class="kw">case</span> *ast.FunctionLiteral:</span>
<span id="cb464-8"><a href="#cb464-8"></a>        <span class="co">// [...]</span></span>
<span id="cb464-9"><a href="#cb464-9"></a></span>
<span id="cb464-10"><a href="#cb464-10"></a>        fnIndex := c.addConstant(compiledFn)</span>
<span id="cb464-11"><a href="#cb464-11"></a>        c.emit(code.OpClosure, fnIndex, <span class="dv">0</span>)</span>
<span id="cb464-12"><a href="#cb464-12"></a></span>
<span id="cb464-13"><a href="#cb464-13"></a>    <span class="co">// [...]</span></span>
<span id="cb464-14"><a href="#cb464-14"></a>    }</span>
<span id="cb464-15"><a href="#cb464-15"></a></span>
<span id="cb464-16"><a href="#cb464-16"></a>    <span class="co">// [...]</span></span>
<span id="cb464-17"><a href="#cb464-17"></a>}</span></code></pre></div>
<p>These are the new last two lines of the <code>case</code> branch for <code>*ast.FunctionLiteral</code>. Instead of emitting <code>OpConstant</code>, we emit an <code>OpClosure</code> instruction. That’s all that needs to be changed and it’s enough to get the tests working again:</p>
<div class="sourceCode" id="cb465"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb465-1"><a href="#cb465-1"></a>$ go test ./compiler</span>
<span id="cb465-2"><a href="#cb465-2"></a>ok      monkey/compiler 0.008s</span></code></pre></div>
<p>The frontend of our Monkey implementation now treats every function as a closure. The VM, however, isn’t on the same page yet:</p>
<div class="sourceCode" id="cb466"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb466-1"><a href="#cb466-1"></a>$ go test ./vm</span>
<span id="cb466-2"><a href="#cb466-2"></a>--- FAIL: TestCallingFunctionsWithoutArguments (0.00s)</span>
<span id="cb466-3"><a href="#cb466-3"></a>panic: runtime error: index out of range [recovered]</span>
<span id="cb466-4"><a href="#cb466-4"></a> panic: runtime error: index out of range</span>
<span id="cb466-5"><a href="#cb466-5"></a></span>
<span id="cb466-6"><a href="#cb466-6"></a>[...]</span>
<span id="cb466-7"><a href="#cb466-7"></a>FAIL    monkey/vm   0.038s</span></code></pre></div>
<p>The upside is that we don’t have to change any VM tests, we just have to get them to pass again. First step: wrap the <code>mainFn</code> we’re executing in a closure and update the initialization code for the <code>VM</code>.</p>
<div class="sourceCode" id="cb467"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb467-1"><a href="#cb467-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb467-2"><a href="#cb467-2"></a></span>
<span id="cb467-3"><a href="#cb467-3"></a><span class="kw">func</span> New(bytecode *compiler.Bytecode) *VM {</span>
<span id="cb467-4"><a href="#cb467-4"></a>    mainFn := &amp;object.CompiledFunction{Instructions: bytecode.Instructions}</span>
<span id="cb467-5"><a href="#cb467-5"></a>    mainClosure := &amp;object.Closure{Fn: mainFn}</span>
<span id="cb467-6"><a href="#cb467-6"></a>    mainFrame := NewFrame(mainClosure, <span class="dv">0</span>)</span>
<span id="cb467-7"><a href="#cb467-7"></a></span>
<span id="cb467-8"><a href="#cb467-8"></a>    <span class="co">// [...]</span></span>
<span id="cb467-9"><a href="#cb467-9"></a>}</span></code></pre></div>
<p>That doesn’t get us too far, because <code>NewFrame</code> and the underlying <code>Frame</code>s do not know how to work with closures yet. What we need to do is make <code>Frame</code> keep a reference to a <code>*object.Closure</code>:</p>
<div class="sourceCode" id="cb468"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb468-1"><a href="#cb468-1"></a><span class="co">// vm/frame.go</span></span>
<span id="cb468-2"><a href="#cb468-2"></a></span>
<span id="cb468-3"><a href="#cb468-3"></a><span class="kw">type</span> Frame <span class="kw">struct</span> {</span>
<span id="cb468-4"><a href="#cb468-4"></a>    cl          *object.Closure</span>
<span id="cb468-5"><a href="#cb468-5"></a>    ip          <span class="dt">int</span></span>
<span id="cb468-6"><a href="#cb468-6"></a>    basePointer <span class="dt">int</span></span>
<span id="cb468-7"><a href="#cb468-7"></a>}</span>
<span id="cb468-8"><a href="#cb468-8"></a></span>
<span id="cb468-9"><a href="#cb468-9"></a><span class="kw">func</span> NewFrame(cl *object.Closure, basePointer <span class="dt">int</span>) *Frame {</span>
<span id="cb468-10"><a href="#cb468-10"></a>    f := &amp;Frame{</span>
<span id="cb468-11"><a href="#cb468-11"></a>        cl:          cl,</span>
<span id="cb468-12"><a href="#cb468-12"></a>        ip:          <span class="dv">-1</span>,</span>
<span id="cb468-13"><a href="#cb468-13"></a>        basePointer: basePointer,</span>
<span id="cb468-14"><a href="#cb468-14"></a>    }</span>
<span id="cb468-15"><a href="#cb468-15"></a></span>
<span id="cb468-16"><a href="#cb468-16"></a>    <span class="kw">return</span> f</span>
<span id="cb468-17"><a href="#cb468-17"></a>}</span>
<span id="cb468-18"><a href="#cb468-18"></a></span>
<span id="cb468-19"><a href="#cb468-19"></a><span class="kw">func</span> (f *Frame) Instructions() code.Instructions {</span>
<span id="cb468-20"><a href="#cb468-20"></a>    <span class="kw">return</span> f.cl.Fn.Instructions</span>
<span id="cb468-21"><a href="#cb468-21"></a>}</span></code></pre></div>
<p>What these changes come down to is another level of indirection. Instead of the <code>fn</code> that holds an <code>*object.CompiledFunction</code>, a <code>Frame</code> now has a <code>cl</code> field, pointing to an <code>object.Closure</code>. To get to the <code>Instructions</code> we now have to go through the <code>cl</code> field first and then through the <code>Fn</code> the closure is wrapping.</p>
<p>And now that our frames assume they only have to work with closures, we actually need to give them closures when we initialize and push them on to our frame stack. The initialization previously happened in the <code>callFunction</code> method of <code>VM</code>. Now is the time to rename it to <code>callClosure</code> and initialize frames with closures:</p>
<div class="sourceCode" id="cb469"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb469-1"><a href="#cb469-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb469-2"><a href="#cb469-2"></a></span>
<span id="cb469-3"><a href="#cb469-3"></a><span class="kw">func</span> (vm *VM) executeCall(numArgs <span class="dt">int</span>) <span class="dt">error</span> {</span>
<span id="cb469-4"><a href="#cb469-4"></a>    callee := vm.stack[vm.sp<span class="dv">-1</span>-numArgs]</span>
<span id="cb469-5"><a href="#cb469-5"></a>    <span class="kw">switch</span> callee := callee.(<span class="kw">type</span>) {</span>
<span id="cb469-6"><a href="#cb469-6"></a>    <span class="kw">case</span> *object.Closure:</span>
<span id="cb469-7"><a href="#cb469-7"></a>        <span class="kw">return</span> vm.callClosure(callee, numArgs)</span>
<span id="cb469-8"><a href="#cb469-8"></a>    <span class="kw">case</span> *object.Builtin:</span>
<span id="cb469-9"><a href="#cb469-9"></a>        <span class="kw">return</span> vm.callBuiltin(callee, numArgs)</span>
<span id="cb469-10"><a href="#cb469-10"></a>    <span class="kw">default</span>:</span>
<span id="cb469-11"><a href="#cb469-11"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;calling non-closure and non-builtin&quot;</span>)</span>
<span id="cb469-12"><a href="#cb469-12"></a>    }</span>
<span id="cb469-13"><a href="#cb469-13"></a>}</span>
<span id="cb469-14"><a href="#cb469-14"></a></span>
<span id="cb469-15"><a href="#cb469-15"></a><span class="kw">func</span> (vm *VM) callClosure(cl *object.Closure, numArgs <span class="dt">int</span>) <span class="dt">error</span> {</span>
<span id="cb469-16"><a href="#cb469-16"></a>    <span class="kw">if</span> numArgs != cl.Fn.NumParameters {</span>
<span id="cb469-17"><a href="#cb469-17"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;wrong number of arguments: want=%d, got=%d&quot;</span>,</span>
<span id="cb469-18"><a href="#cb469-18"></a>            cl.Fn.NumParameters, numArgs)</span>
<span id="cb469-19"><a href="#cb469-19"></a>    }</span>
<span id="cb469-20"><a href="#cb469-20"></a></span>
<span id="cb469-21"><a href="#cb469-21"></a>    frame := NewFrame(cl, vm.sp-numArgs)</span>
<span id="cb469-22"><a href="#cb469-22"></a>    vm.pushFrame(frame)</span>
<span id="cb469-23"><a href="#cb469-23"></a></span>
<span id="cb469-24"><a href="#cb469-24"></a>    vm.sp = frame.basePointer + cl.Fn.NumLocals</span>
<span id="cb469-25"><a href="#cb469-25"></a></span>
<span id="cb469-26"><a href="#cb469-26"></a>    <span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb469-27"><a href="#cb469-27"></a>}</span></code></pre></div>
<p>Make no mistake: <code>callClosure</code> is just a revamped <code>callFunction</code>. The name has been changed and the local variable has been renamed from <code>fn</code> to <code>cl</code>, because it’s now an <code>*object.Closure</code> that’s being called. That brings with it that we also have to ask <code>cl.Fn</code> for the <code>NumParameters</code> and <code>NumLocals</code>. What the method does, though, is the same.</p>
<p>The same renaming was necessary in <code>executeCall</code>, of course, where we now expect an <code>*object.Closure</code> to sit on the stack instead of an <code>*object.CompiledFunction</code>.</p>
<p>All that’s left to do now is to actually handle the <code>OpClosure</code> instructions. That means getting functions from the constant pool, wrapping them in a closure and pushing that on to the stack, where it can be called:</p>
<div class="sourceCode" id="cb470"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb470-1"><a href="#cb470-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb470-2"><a href="#cb470-2"></a></span>
<span id="cb470-3"><a href="#cb470-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb470-4"><a href="#cb470-4"></a>    <span class="co">// [...]</span></span>
<span id="cb470-5"><a href="#cb470-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb470-6"><a href="#cb470-6"></a>        <span class="co">// [...]</span></span>
<span id="cb470-7"><a href="#cb470-7"></a></span>
<span id="cb470-8"><a href="#cb470-8"></a>        <span class="kw">case</span> code.OpClosure:</span>
<span id="cb470-9"><a href="#cb470-9"></a>            constIndex := code.ReadUint16(ins[ip+<span class="dv">1</span>:])</span>
<span id="cb470-10"><a href="#cb470-10"></a>            _ = code.ReadUint8(ins[ip+<span class="dv">3</span>:])</span>
<span id="cb470-11"><a href="#cb470-11"></a>            vm.currentFrame().ip += <span class="dv">3</span></span>
<span id="cb470-12"><a href="#cb470-12"></a></span>
<span id="cb470-13"><a href="#cb470-13"></a>            err := vm.pushClosure(<span class="dt">int</span>(constIndex))</span>
<span id="cb470-14"><a href="#cb470-14"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb470-15"><a href="#cb470-15"></a>                <span class="kw">return</span> err</span>
<span id="cb470-16"><a href="#cb470-16"></a>            }</span>
<span id="cb470-17"><a href="#cb470-17"></a></span>
<span id="cb470-18"><a href="#cb470-18"></a>        <span class="co">// [...]</span></span>
<span id="cb470-19"><a href="#cb470-19"></a>        }</span>
<span id="cb470-20"><a href="#cb470-20"></a>    <span class="co">// [...]</span></span>
<span id="cb470-21"><a href="#cb470-21"></a>}</span>
<span id="cb470-22"><a href="#cb470-22"></a></span>
<span id="cb470-23"><a href="#cb470-23"></a><span class="kw">func</span> (vm *VM) pushClosure(constIndex <span class="dt">int</span>) <span class="dt">error</span> {</span>
<span id="cb470-24"><a href="#cb470-24"></a>    constant := vm.constants[constIndex]</span>
<span id="cb470-25"><a href="#cb470-25"></a>    function, ok := constant.(*object.CompiledFunction)</span>
<span id="cb470-26"><a href="#cb470-26"></a>    <span class="kw">if</span> !ok {</span>
<span id="cb470-27"><a href="#cb470-27"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;not a function: %+v&quot;</span>, constant)</span>
<span id="cb470-28"><a href="#cb470-28"></a>    }</span>
<span id="cb470-29"><a href="#cb470-29"></a></span>
<span id="cb470-30"><a href="#cb470-30"></a>    closure := &amp;object.Closure{Fn: function}</span>
<span id="cb470-31"><a href="#cb470-31"></a>    <span class="kw">return</span> vm.push(closure)</span>
<span id="cb470-32"><a href="#cb470-32"></a>}</span></code></pre></div>
<p>Since <code>OpClosure</code> instructions have two operands, we need to either decode or skip both of them, even though we only need one. If we fail do that, the rest of the VM will trip over the unused operand. And while a manual increment of <code>ip</code> is enough to advance it past both operands, we still put a symbolic and absolutely useless <code>ReadUint8</code> in place, to show us where we will later decode the second operand. The <code>_</code> is a little reminder that we still have work to do.</p>
<p>We then pass the first operand, <code>constIndex</code>, to the new <code>pushClosure</code> method, which in turn takes care of finding the specified function in the <code>constants</code>, turns it into an <code>*object.Closure</code> and puts it on the stack. There it can be passed around or called, just like <code>*object.CompiledFunction</code>s before, which is to say that it did the trick:</p>
<div class="sourceCode" id="cb471"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb471-1"><a href="#cb471-1"></a>$ go test ./vm</span>
<span id="cb471-2"><a href="#cb471-2"></a>ok      monkey/vm   0.051s</span></code></pre></div>
<p>Now, everything’s a closure. Time to add closures.</p>
<h2 id="compiling-and-resolving-free-variables">Compiling and resolving free variables</h2>
<p>As I said before, compiling closures revolves around free variables and how to tame them. On that front, we’re doing well. With the <code>Free</code> field on <code>object.Closure</code> we have a place where we can store free variables, and with the <code>OpClosure</code> opcode we can tell the VM to store them there.</p>
<p>But what we also need is an opcode to retrieve the values in the <code>Free</code> field and put them on to the stack. Since our other opcodes to retrieve values are called <code>OpGetLocal</code>, <code>OpGetGlobal</code> and <code>OpGetBuiltin</code> it only makes sense to call this one <code>OpGetFree</code>:</p>
<div class="sourceCode" id="cb472"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb472-1"><a href="#cb472-1"></a><span class="co">// code/code.go</span></span>
<span id="cb472-2"><a href="#cb472-2"></a></span>
<span id="cb472-3"><a href="#cb472-3"></a><span class="kw">const</span> (</span>
<span id="cb472-4"><a href="#cb472-4"></a>    <span class="co">// [...]</span></span>
<span id="cb472-5"><a href="#cb472-5"></a></span>
<span id="cb472-6"><a href="#cb472-6"></a>    OpGetFree</span>
<span id="cb472-7"><a href="#cb472-7"></a>)</span>
<span id="cb472-8"><a href="#cb472-8"></a></span>
<span id="cb472-9"><a href="#cb472-9"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb472-10"><a href="#cb472-10"></a>    <span class="co">// [...]</span></span>
<span id="cb472-11"><a href="#cb472-11"></a></span>
<span id="cb472-12"><a href="#cb472-12"></a>    OpGetFree: {<span class="st">&quot;OpGetFree&quot;</span>, []<span class="dt">int</span>{<span class="dv">1</span>}},</span>
<span id="cb472-13"><a href="#cb472-13"></a>}</span></code></pre></div>
<p>Now that we have it, we can write a first compiler test in which we use <code>OpGetFree</code> to retrieve the free variables referenced in a <em>real</em> closure:</p>
<div class="sourceCode" id="cb473"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb473-1"><a href="#cb473-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb473-2"><a href="#cb473-2"></a></span>
<span id="cb473-3"><a href="#cb473-3"></a><span class="kw">func</span> TestClosures(t *testing.T) {</span>
<span id="cb473-4"><a href="#cb473-4"></a>    tests := []compilerTestCase{</span>
<span id="cb473-5"><a href="#cb473-5"></a>        {</span>
<span id="cb473-6"><a href="#cb473-6"></a>            input: <span class="st">`</span></span>
<span id="cb473-7"><a href="#cb473-7"></a><span class="st">            fn(a) {</span></span>
<span id="cb473-8"><a href="#cb473-8"></a><span class="st">                fn(b) {</span></span>
<span id="cb473-9"><a href="#cb473-9"></a><span class="st">                    a + b</span></span>
<span id="cb473-10"><a href="#cb473-10"></a><span class="st">                }</span></span>
<span id="cb473-11"><a href="#cb473-11"></a><span class="st">            }</span></span>
<span id="cb473-12"><a href="#cb473-12"></a><span class="st">            `</span>,</span>
<span id="cb473-13"><a href="#cb473-13"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb473-14"><a href="#cb473-14"></a>                []code.Instructions{</span>
<span id="cb473-15"><a href="#cb473-15"></a>                    code.Make(code.OpGetFree, <span class="dv">0</span>),</span>
<span id="cb473-16"><a href="#cb473-16"></a>                    code.Make(code.OpGetLocal, <span class="dv">0</span>),</span>
<span id="cb473-17"><a href="#cb473-17"></a>                    code.Make(code.OpAdd),</span>
<span id="cb473-18"><a href="#cb473-18"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb473-19"><a href="#cb473-19"></a>                },</span>
<span id="cb473-20"><a href="#cb473-20"></a>                []code.Instructions{</span>
<span id="cb473-21"><a href="#cb473-21"></a>                    code.Make(code.OpGetLocal, <span class="dv">0</span>),</span>
<span id="cb473-22"><a href="#cb473-22"></a>                    code.Make(code.OpClosure, <span class="dv">0</span>, <span class="dv">1</span>),</span>
<span id="cb473-23"><a href="#cb473-23"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb473-24"><a href="#cb473-24"></a>                },</span>
<span id="cb473-25"><a href="#cb473-25"></a>            },</span>
<span id="cb473-26"><a href="#cb473-26"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb473-27"><a href="#cb473-27"></a>                code.Make(code.OpClosure, <span class="dv">1</span>, <span class="dv">0</span>),</span>
<span id="cb473-28"><a href="#cb473-28"></a>                code.Make(code.OpPop),</span>
<span id="cb473-29"><a href="#cb473-29"></a>            },</span>
<span id="cb473-30"><a href="#cb473-30"></a>        },</span>
<span id="cb473-31"><a href="#cb473-31"></a>    }</span>
<span id="cb473-32"><a href="#cb473-32"></a></span>
<span id="cb473-33"><a href="#cb473-33"></a>    runCompilerTests(t, tests)</span>
<span id="cb473-34"><a href="#cb473-34"></a>}</span></code></pre></div>
<p>This test succinctly shows how our implementation of closures is supposed to work.</p>
<p>The innermost function in the test input, the one with the <code>b</code> parameter, is a <em>real</em> closure: it references not only the local <code>b</code> but also <code>a</code>, which was defined in an enclosing scope. From this function’s perspective <code>a</code> is a free variable and we expect the compiler to emit an <code>OpGetFree</code> instructions to get it on to the stack. The <code>b</code> will be pushed on to the stack with an ordinary <code>OpGetLocal</code>.</p>
<p>In the outer function, <code>a</code> is supposed to be loaded on to the stack with <code>OpGetLocal</code> – despite the function itself never referencing it. But since it’s referenced by the inner function it has to be put on the stack before the VM executes the next instruction: <code>OpClosure</code>.</p>
<p>The second operand of <code>OpClosure</code> is now in use and has the value <code>1</code>, because there’s one free variable sitting on the stack, <code>a</code>, waiting to be saved into the <code>Free</code> field of an <code>object.Closure</code>.</p>
<p>In the <code>expectedInstructions</code> of the main program another <code>OpClosure</code> takes care of creating a closure, but this time it’s the old use case we already know, without any free variables.</p>
<p>That’s how we’re going to implement closures, expressed as expectations in a compiler test. That’s not all, though. We also want to support deeply-nested closures:</p>
<div class="sourceCode" id="cb474"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb474-1"><a href="#cb474-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb474-2"><a href="#cb474-2"></a></span>
<span id="cb474-3"><a href="#cb474-3"></a><span class="kw">func</span> TestClosures(t *testing.T) {</span>
<span id="cb474-4"><a href="#cb474-4"></a>    tests := []compilerTestCase{</span>
<span id="cb474-5"><a href="#cb474-5"></a>        <span class="co">// [...]</span></span>
<span id="cb474-6"><a href="#cb474-6"></a>        {</span>
<span id="cb474-7"><a href="#cb474-7"></a>            input: <span class="st">`</span></span>
<span id="cb474-8"><a href="#cb474-8"></a><span class="st">            fn(a) {</span></span>
<span id="cb474-9"><a href="#cb474-9"></a><span class="st">                fn(b) {</span></span>
<span id="cb474-10"><a href="#cb474-10"></a><span class="st">                    fn(c) {</span></span>
<span id="cb474-11"><a href="#cb474-11"></a><span class="st">                        a + b + c</span></span>
<span id="cb474-12"><a href="#cb474-12"></a><span class="st">                    }</span></span>
<span id="cb474-13"><a href="#cb474-13"></a><span class="st">                }</span></span>
<span id="cb474-14"><a href="#cb474-14"></a><span class="st">            };</span></span>
<span id="cb474-15"><a href="#cb474-15"></a><span class="st">            `</span>,</span>
<span id="cb474-16"><a href="#cb474-16"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb474-17"><a href="#cb474-17"></a>                []code.Instructions{</span>
<span id="cb474-18"><a href="#cb474-18"></a>                    code.Make(code.OpGetFree, <span class="dv">0</span>),</span>
<span id="cb474-19"><a href="#cb474-19"></a>                    code.Make(code.OpGetFree, <span class="dv">1</span>),</span>
<span id="cb474-20"><a href="#cb474-20"></a>                    code.Make(code.OpAdd),</span>
<span id="cb474-21"><a href="#cb474-21"></a>                    code.Make(code.OpGetLocal, <span class="dv">0</span>),</span>
<span id="cb474-22"><a href="#cb474-22"></a>                    code.Make(code.OpAdd),</span>
<span id="cb474-23"><a href="#cb474-23"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb474-24"><a href="#cb474-24"></a>                },</span>
<span id="cb474-25"><a href="#cb474-25"></a>                []code.Instructions{</span>
<span id="cb474-26"><a href="#cb474-26"></a>                    code.Make(code.OpGetFree, <span class="dv">0</span>),</span>
<span id="cb474-27"><a href="#cb474-27"></a>                    code.Make(code.OpGetLocal, <span class="dv">0</span>),</span>
<span id="cb474-28"><a href="#cb474-28"></a>                    code.Make(code.OpClosure, <span class="dv">0</span>, <span class="dv">2</span>),</span>
<span id="cb474-29"><a href="#cb474-29"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb474-30"><a href="#cb474-30"></a>                },</span>
<span id="cb474-31"><a href="#cb474-31"></a>                []code.Instructions{</span>
<span id="cb474-32"><a href="#cb474-32"></a>                    code.Make(code.OpGetLocal, <span class="dv">0</span>),</span>
<span id="cb474-33"><a href="#cb474-33"></a>                    code.Make(code.OpClosure, <span class="dv">1</span>, <span class="dv">1</span>),</span>
<span id="cb474-34"><a href="#cb474-34"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb474-35"><a href="#cb474-35"></a>                },</span>
<span id="cb474-36"><a href="#cb474-36"></a>            },</span>
<span id="cb474-37"><a href="#cb474-37"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb474-38"><a href="#cb474-38"></a>                code.Make(code.OpClosure, <span class="dv">2</span>, <span class="dv">0</span>),</span>
<span id="cb474-39"><a href="#cb474-39"></a>                code.Make(code.OpPop),</span>
<span id="cb474-40"><a href="#cb474-40"></a>            },</span>
<span id="cb474-41"><a href="#cb474-41"></a>        },</span>
<span id="cb474-42"><a href="#cb474-42"></a>    }</span>
<span id="cb474-43"><a href="#cb474-43"></a></span>
<span id="cb474-44"><a href="#cb474-44"></a>    runCompilerTests(t, tests)</span>
<span id="cb474-45"><a href="#cb474-45"></a>}</span></code></pre></div>
<p>Here we have three nested functions. The innermost function, the one with the <code>c</code> parameter, references two free variables: <code>a</code> and <code>b</code>. <code>b</code> is defined in the immediate enclosing scope, but <code>a</code> is defined in the outermost function, two scopes removed.</p>
<p>The middle function is expected to contain an <code>OpClosure</code> instruction that turns the innermost function into a closure. Since the second operand is <code>2</code>, there are supposed to be two free variables sitting on the stack when the VM executes it. What’s curious is how these values are being put on to the stack: an <code>OpGetLocal</code> instruction for the <code>b</code> and – this is the interesting bit – an <code>OpGetFree</code> instruction for the outer <code>a</code>.</p>
<p>Why <code>OpGetFree</code>? Because from the perspective of the middle function, <code>a</code> is also a free variable: neither defined in scope nor as a parameter. And since it needs to get <code>a</code> on to the stack, so it can be transferred to the innermost function’s <code>Free</code> field, we expect an <code>OpGetFree</code> instruction.</p>
<p>That’s how a function will be able to access local bindings from an outer scope; it’s how we implement nested local bindings by implementing closures. We treat every non-local, non-global, non-built-in binding as a free variable.</p>
<p>Let’s add a test that makes this goal clearer:</p>
<div class="sourceCode" id="cb475"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb475-1"><a href="#cb475-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb475-2"><a href="#cb475-2"></a></span>
<span id="cb475-3"><a href="#cb475-3"></a><span class="kw">func</span> TestClosures(t *testing.T) {</span>
<span id="cb475-4"><a href="#cb475-4"></a>    tests := []compilerTestCase{</span>
<span id="cb475-5"><a href="#cb475-5"></a>        <span class="co">// [...]</span></span>
<span id="cb475-6"><a href="#cb475-6"></a>        {</span>
<span id="cb475-7"><a href="#cb475-7"></a>            input: <span class="st">`</span></span>
<span id="cb475-8"><a href="#cb475-8"></a><span class="st">            let global = 55;</span></span>
<span id="cb475-9"><a href="#cb475-9"></a></span>
<span id="cb475-10"><a href="#cb475-10"></a><span class="st">            fn() {</span></span>
<span id="cb475-11"><a href="#cb475-11"></a><span class="st">                let a = 66;</span></span>
<span id="cb475-12"><a href="#cb475-12"></a></span>
<span id="cb475-13"><a href="#cb475-13"></a><span class="st">                fn() {</span></span>
<span id="cb475-14"><a href="#cb475-14"></a><span class="st">                    let b = 77;</span></span>
<span id="cb475-15"><a href="#cb475-15"></a></span>
<span id="cb475-16"><a href="#cb475-16"></a><span class="st">                    fn() {</span></span>
<span id="cb475-17"><a href="#cb475-17"></a><span class="st">                        let c = 88;</span></span>
<span id="cb475-18"><a href="#cb475-18"></a></span>
<span id="cb475-19"><a href="#cb475-19"></a><span class="st">                        global + a + b + c;</span></span>
<span id="cb475-20"><a href="#cb475-20"></a><span class="st">                    }</span></span>
<span id="cb475-21"><a href="#cb475-21"></a><span class="st">                }</span></span>
<span id="cb475-22"><a href="#cb475-22"></a><span class="st">            }</span></span>
<span id="cb475-23"><a href="#cb475-23"></a><span class="st">            `</span>,</span>
<span id="cb475-24"><a href="#cb475-24"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb475-25"><a href="#cb475-25"></a>                <span class="dv">55</span>,</span>
<span id="cb475-26"><a href="#cb475-26"></a>                <span class="dv">66</span>,</span>
<span id="cb475-27"><a href="#cb475-27"></a>                <span class="dv">77</span>,</span>
<span id="cb475-28"><a href="#cb475-28"></a>                <span class="dv">88</span>,</span>
<span id="cb475-29"><a href="#cb475-29"></a>                []code.Instructions{</span>
<span id="cb475-30"><a href="#cb475-30"></a>                    code.Make(code.OpConstant, <span class="dv">3</span>),</span>
<span id="cb475-31"><a href="#cb475-31"></a>                    code.Make(code.OpSetLocal, <span class="dv">0</span>),</span>
<span id="cb475-32"><a href="#cb475-32"></a>                    code.Make(code.OpGetGlobal, <span class="dv">0</span>),</span>
<span id="cb475-33"><a href="#cb475-33"></a>                    code.Make(code.OpGetFree, <span class="dv">0</span>),</span>
<span id="cb475-34"><a href="#cb475-34"></a>                    code.Make(code.OpAdd),</span>
<span id="cb475-35"><a href="#cb475-35"></a>                    code.Make(code.OpGetFree, <span class="dv">1</span>),</span>
<span id="cb475-36"><a href="#cb475-36"></a>                    code.Make(code.OpAdd),</span>
<span id="cb475-37"><a href="#cb475-37"></a>                    code.Make(code.OpGetLocal, <span class="dv">0</span>),</span>
<span id="cb475-38"><a href="#cb475-38"></a>                    code.Make(code.OpAdd),</span>
<span id="cb475-39"><a href="#cb475-39"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb475-40"><a href="#cb475-40"></a>                },</span>
<span id="cb475-41"><a href="#cb475-41"></a>                []code.Instructions{</span>
<span id="cb475-42"><a href="#cb475-42"></a>                    code.Make(code.OpConstant, <span class="dv">2</span>),</span>
<span id="cb475-43"><a href="#cb475-43"></a>                    code.Make(code.OpSetLocal, <span class="dv">0</span>),</span>
<span id="cb475-44"><a href="#cb475-44"></a>                    code.Make(code.OpGetFree, <span class="dv">0</span>),</span>
<span id="cb475-45"><a href="#cb475-45"></a>                    code.Make(code.OpGetLocal, <span class="dv">0</span>),</span>
<span id="cb475-46"><a href="#cb475-46"></a>                    code.Make(code.OpClosure, <span class="dv">4</span>, <span class="dv">2</span>),</span>
<span id="cb475-47"><a href="#cb475-47"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb475-48"><a href="#cb475-48"></a>                },</span>
<span id="cb475-49"><a href="#cb475-49"></a>                []code.Instructions{</span>
<span id="cb475-50"><a href="#cb475-50"></a>                    code.Make(code.OpConstant, <span class="dv">1</span>),</span>
<span id="cb475-51"><a href="#cb475-51"></a>                    code.Make(code.OpSetLocal, <span class="dv">0</span>),</span>
<span id="cb475-52"><a href="#cb475-52"></a>                    code.Make(code.OpGetLocal, <span class="dv">0</span>),</span>
<span id="cb475-53"><a href="#cb475-53"></a>                    code.Make(code.OpClosure, <span class="dv">5</span>, <span class="dv">1</span>),</span>
<span id="cb475-54"><a href="#cb475-54"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb475-55"><a href="#cb475-55"></a>                },</span>
<span id="cb475-56"><a href="#cb475-56"></a>            },</span>
<span id="cb475-57"><a href="#cb475-57"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb475-58"><a href="#cb475-58"></a>                code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb475-59"><a href="#cb475-59"></a>                code.Make(code.OpSetGlobal, <span class="dv">0</span>),</span>
<span id="cb475-60"><a href="#cb475-60"></a>                code.Make(code.OpClosure, <span class="dv">6</span>, <span class="dv">0</span>),</span>
<span id="cb475-61"><a href="#cb475-61"></a>                code.Make(code.OpPop),</span>
<span id="cb475-62"><a href="#cb475-62"></a>            },</span>
<span id="cb475-63"><a href="#cb475-63"></a>        },</span>
<span id="cb475-64"><a href="#cb475-64"></a>    }</span>
<span id="cb475-65"><a href="#cb475-65"></a></span>
<span id="cb475-66"><a href="#cb475-66"></a>    runCompilerTests(t, tests)</span>
<span id="cb475-67"><a href="#cb475-67"></a>}</span></code></pre></div>
<p>Don’t be put off by the number of instructions here and concentrate on the ones that make up the innermost function. That’s the first <code>[]code.Instructions</code> slice. It references all available bindings and makes use of three different opcodes to get values on to the stack: <code>OpGetLocal</code>, <code>OpGetFree</code> and now also <code>OpGetGlobal</code>.</p>
<p>References to global bindings won’t be turned into <code>OpGetFree</code> instructions, because global bindings are just that: global. They’re visible and reachable from every scope. There’s no need to treat them as free variables too, even though they technically are.</p>
<p>The rest of the test case makes sure that a reference to a local binding created with a let statement in an outer scope results in the same instructions as a reference to a parameter of an outer function.</p>
<p>Since we implemented parameters as local bindings, this is more of a sanity check than anything else, because it <em>should</em> work without any additional changes once we have the first test case passing. And it makes our intent of treating local bindings of outer scopes as free variables much clearer.</p>
<p>Now we have multiple test cases and the first one already tells us that our compiler knows nothing about free variables yet:</p>
<div class="sourceCode" id="cb476"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb476-1"><a href="#cb476-1"></a>$ go test ./compiler</span>
<span id="cb476-2"><a href="#cb476-2"></a>--- FAIL: TestClosures (0.00s)</span>
<span id="cb476-3"><a href="#cb476-3"></a> compiler_test.go:1212: testConstants failed: constant 0 -\</span>
<span id="cb476-4"><a href="#cb476-4"></a>   testInstructions failed: wrong instruction at 0.</span>
<span id="cb476-5"><a href="#cb476-5"></a>  want=&quot;0000 OpGetFree 0\n0002 OpGetLocal 0\n0004 OpAdd\n0005 OpReturnValue\n&quot;</span>
<span id="cb476-6"><a href="#cb476-6"></a>  got =&quot;0000 OpGetLocal 0\n0002 OpGetLocal 0\n0004 OpAdd\n0005 OpReturnValue\n&quot;</span>
<span id="cb476-7"><a href="#cb476-7"></a>FAIL</span>
<span id="cb476-8"><a href="#cb476-8"></a>FAIL    monkey/compiler 0.008s</span></code></pre></div>
<p>Instead of the expected <code>OpGetFree</code> we get an <code>OpGetLocal</code> instruction. Not surprising, really, since the compiler currently treats every non-global binding as local. That’s wrong. Instead, the compiler must detect free variables when it resolves references and emit an <code>OpGetFree</code> instruction.</p>
<p>Detecting and resolving free variables sounds daunting, but once it’s sliced it into tiny problems, you’ll see that we can solve them one by one. It gets even easier if we ask our symbol table for help, since it was built for tasks like these.</p>
<p>So, let’s start with the easiest possible change and introduce a new scope:</p>
<div class="sourceCode" id="cb477"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb477-1"><a href="#cb477-1"></a><span class="co">// compiler/symbol_table.go</span></span>
<span id="cb477-2"><a href="#cb477-2"></a></span>
<span id="cb477-3"><a href="#cb477-3"></a><span class="kw">const</span> (</span>
<span id="cb477-4"><a href="#cb477-4"></a>    <span class="co">// [...]</span></span>
<span id="cb477-5"><a href="#cb477-5"></a>    FreeScope    SymbolScope = <span class="st">&quot;FREE&quot;</span></span>
<span id="cb477-6"><a href="#cb477-6"></a>)</span></code></pre></div>
<p>With that, we can now write a test for the symbol table to make sure that it can handle free variables. Specifically, we want it to correctly resolve every symbol in this snippet of Monkey code:</p>
<div class="sourceCode" id="cb478"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb478-1"><a href="#cb478-1"></a><span class="kw">let</span> a <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb478-2"><a href="#cb478-2"></a><span class="kw">let</span> b <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb478-3"><a href="#cb478-3"></a></span>
<span id="cb478-4"><a href="#cb478-4"></a><span class="kw">let</span> firstLocal <span class="op">=</span> fn() {</span>
<span id="cb478-5"><a href="#cb478-5"></a>  <span class="kw">let</span> c <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb478-6"><a href="#cb478-6"></a>  <span class="kw">let</span> d <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb478-7"><a href="#cb478-7"></a>  a <span class="op">+</span> b <span class="op">+</span> c <span class="op">+</span> d<span class="op">;</span></span>
<span id="cb478-8"><a href="#cb478-8"></a></span>
<span id="cb478-9"><a href="#cb478-9"></a>  <span class="kw">let</span> secondLocal <span class="op">=</span> fn() {</span>
<span id="cb478-10"><a href="#cb478-10"></a>    <span class="kw">let</span> e <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb478-11"><a href="#cb478-11"></a>    <span class="kw">let</span> f <span class="op">=</span> <span class="dv">6</span><span class="op">;</span></span>
<span id="cb478-12"><a href="#cb478-12"></a>    a <span class="op">+</span> b <span class="op">+</span> c <span class="op">+</span> d <span class="op">+</span> e <span class="op">+</span> f<span class="op">;</span></span>
<span id="cb478-13"><a href="#cb478-13"></a>  }<span class="op">;</span></span>
<span id="cb478-14"><a href="#cb478-14"></a>}<span class="op">;</span></span></code></pre></div>
<p>We can take this Monkey code and turn it into a test by looking at it from the symbol table’s perspective:</p>
<div class="sourceCode" id="cb479"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb479-1"><a href="#cb479-1"></a><span class="co">// compiler/symbol_table_test.go</span></span>
<span id="cb479-2"><a href="#cb479-2"></a></span>
<span id="cb479-3"><a href="#cb479-3"></a><span class="kw">func</span> TestResolveFree(t *testing.T) {</span>
<span id="cb479-4"><a href="#cb479-4"></a>    global := NewSymbolTable()</span>
<span id="cb479-5"><a href="#cb479-5"></a>    global.Define(<span class="st">&quot;a&quot;</span>)</span>
<span id="cb479-6"><a href="#cb479-6"></a>    global.Define(<span class="st">&quot;b&quot;</span>)</span>
<span id="cb479-7"><a href="#cb479-7"></a></span>
<span id="cb479-8"><a href="#cb479-8"></a>    firstLocal := NewEnclosedSymbolTable(global)</span>
<span id="cb479-9"><a href="#cb479-9"></a>    firstLocal.Define(<span class="st">&quot;c&quot;</span>)</span>
<span id="cb479-10"><a href="#cb479-10"></a>    firstLocal.Define(<span class="st">&quot;d&quot;</span>)</span>
<span id="cb479-11"><a href="#cb479-11"></a></span>
<span id="cb479-12"><a href="#cb479-12"></a>    secondLocal := NewEnclosedSymbolTable(firstLocal)</span>
<span id="cb479-13"><a href="#cb479-13"></a>    secondLocal.Define(<span class="st">&quot;e&quot;</span>)</span>
<span id="cb479-14"><a href="#cb479-14"></a>    secondLocal.Define(<span class="st">&quot;f&quot;</span>)</span>
<span id="cb479-15"><a href="#cb479-15"></a></span>
<span id="cb479-16"><a href="#cb479-16"></a>    tests := []<span class="kw">struct</span> {</span>
<span id="cb479-17"><a href="#cb479-17"></a>        table               *SymbolTable</span>
<span id="cb479-18"><a href="#cb479-18"></a>        expectedSymbols     []Symbol</span>
<span id="cb479-19"><a href="#cb479-19"></a>        expectedFreeSymbols []Symbol</span>
<span id="cb479-20"><a href="#cb479-20"></a>    }{</span>
<span id="cb479-21"><a href="#cb479-21"></a>        {</span>
<span id="cb479-22"><a href="#cb479-22"></a>            firstLocal,</span>
<span id="cb479-23"><a href="#cb479-23"></a>            []Symbol{</span>
<span id="cb479-24"><a href="#cb479-24"></a>                Symbol{Name: <span class="st">&quot;a&quot;</span>, Scope: GlobalScope, Index: <span class="dv">0</span>},</span>
<span id="cb479-25"><a href="#cb479-25"></a>                Symbol{Name: <span class="st">&quot;b&quot;</span>, Scope: GlobalScope, Index: <span class="dv">1</span>},</span>
<span id="cb479-26"><a href="#cb479-26"></a>                Symbol{Name: <span class="st">&quot;c&quot;</span>, Scope: LocalScope, Index: <span class="dv">0</span>},</span>
<span id="cb479-27"><a href="#cb479-27"></a>                Symbol{Name: <span class="st">&quot;d&quot;</span>, Scope: LocalScope, Index: <span class="dv">1</span>},</span>
<span id="cb479-28"><a href="#cb479-28"></a>            },</span>
<span id="cb479-29"><a href="#cb479-29"></a>            []Symbol{},</span>
<span id="cb479-30"><a href="#cb479-30"></a>        },</span>
<span id="cb479-31"><a href="#cb479-31"></a>        {</span>
<span id="cb479-32"><a href="#cb479-32"></a>            secondLocal,</span>
<span id="cb479-33"><a href="#cb479-33"></a>            []Symbol{</span>
<span id="cb479-34"><a href="#cb479-34"></a>                Symbol{Name: <span class="st">&quot;a&quot;</span>, Scope: GlobalScope, Index: <span class="dv">0</span>},</span>
<span id="cb479-35"><a href="#cb479-35"></a>                Symbol{Name: <span class="st">&quot;b&quot;</span>, Scope: GlobalScope, Index: <span class="dv">1</span>},</span>
<span id="cb479-36"><a href="#cb479-36"></a>                Symbol{Name: <span class="st">&quot;c&quot;</span>, Scope: FreeScope, Index: <span class="dv">0</span>},</span>
<span id="cb479-37"><a href="#cb479-37"></a>                Symbol{Name: <span class="st">&quot;d&quot;</span>, Scope: FreeScope, Index: <span class="dv">1</span>},</span>
<span id="cb479-38"><a href="#cb479-38"></a>                Symbol{Name: <span class="st">&quot;e&quot;</span>, Scope: LocalScope, Index: <span class="dv">0</span>},</span>
<span id="cb479-39"><a href="#cb479-39"></a>                Symbol{Name: <span class="st">&quot;f&quot;</span>, Scope: LocalScope, Index: <span class="dv">1</span>},</span>
<span id="cb479-40"><a href="#cb479-40"></a>            },</span>
<span id="cb479-41"><a href="#cb479-41"></a>            []Symbol{</span>
<span id="cb479-42"><a href="#cb479-42"></a>                Symbol{Name: <span class="st">&quot;c&quot;</span>, Scope: LocalScope, Index: <span class="dv">0</span>},</span>
<span id="cb479-43"><a href="#cb479-43"></a>                Symbol{Name: <span class="st">&quot;d&quot;</span>, Scope: LocalScope, Index: <span class="dv">1</span>},</span>
<span id="cb479-44"><a href="#cb479-44"></a>            },</span>
<span id="cb479-45"><a href="#cb479-45"></a>        },</span>
<span id="cb479-46"><a href="#cb479-46"></a>    }</span>
<span id="cb479-47"><a href="#cb479-47"></a></span>
<span id="cb479-48"><a href="#cb479-48"></a>    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</span>
<span id="cb479-49"><a href="#cb479-49"></a>        <span class="kw">for</span> _, sym := <span class="kw">range</span> tt.expectedSymbols {</span>
<span id="cb479-50"><a href="#cb479-50"></a>            result, ok := tt.table.Resolve(sym.Name)</span>
<span id="cb479-51"><a href="#cb479-51"></a>            <span class="kw">if</span> !ok {</span>
<span id="cb479-52"><a href="#cb479-52"></a>                t.Errorf(<span class="st">&quot;name %s not resolvable&quot;</span>, sym.Name)</span>
<span id="cb479-53"><a href="#cb479-53"></a>                <span class="kw">continue</span></span>
<span id="cb479-54"><a href="#cb479-54"></a>            }</span>
<span id="cb479-55"><a href="#cb479-55"></a>            <span class="kw">if</span> result != sym {</span>
<span id="cb479-56"><a href="#cb479-56"></a>                t.Errorf(<span class="st">&quot;expected %s to resolve to %+v, got=%+v&quot;</span>,</span>
<span id="cb479-57"><a href="#cb479-57"></a>                    sym.Name, sym, result)</span>
<span id="cb479-58"><a href="#cb479-58"></a>            }</span>
<span id="cb479-59"><a href="#cb479-59"></a>        }</span>
<span id="cb479-60"><a href="#cb479-60"></a></span>
<span id="cb479-61"><a href="#cb479-61"></a>        <span class="kw">if</span> <span class="bu">len</span>(tt.table.FreeSymbols) != <span class="bu">len</span>(tt.expectedFreeSymbols) {</span>
<span id="cb479-62"><a href="#cb479-62"></a>            t.Errorf(<span class="st">&quot;wrong number of free symbols. got=%d, want=%d&quot;</span>,</span>
<span id="cb479-63"><a href="#cb479-63"></a>                <span class="bu">len</span>(tt.table.FreeSymbols), <span class="bu">len</span>(tt.expectedFreeSymbols))</span>
<span id="cb479-64"><a href="#cb479-64"></a>            <span class="kw">continue</span></span>
<span id="cb479-65"><a href="#cb479-65"></a>        }</span>
<span id="cb479-66"><a href="#cb479-66"></a></span>
<span id="cb479-67"><a href="#cb479-67"></a>        <span class="kw">for</span> i, sym := <span class="kw">range</span> tt.expectedFreeSymbols {</span>
<span id="cb479-68"><a href="#cb479-68"></a>            result := tt.table.FreeSymbols[i]</span>
<span id="cb479-69"><a href="#cb479-69"></a>            <span class="kw">if</span> result != sym {</span>
<span id="cb479-70"><a href="#cb479-70"></a>                t.Errorf(<span class="st">&quot;wrong free symbol. got=%+v, want=%+v&quot;</span>,</span>
<span id="cb479-71"><a href="#cb479-71"></a>                    result, sym)</span>
<span id="cb479-72"><a href="#cb479-72"></a>            }</span>
<span id="cb479-73"><a href="#cb479-73"></a>        }</span>
<span id="cb479-74"><a href="#cb479-74"></a>    }</span>
<span id="cb479-75"><a href="#cb479-75"></a>}</span></code></pre></div>
<p>Just like in the Monkey snippet, we define three scopes: the <code>global</code> scope, a <code>firstLocal</code> scope and a <code>secondLocal</code> scope, all nested within each other, with <code>secondLocal</code> being the innermost one. In the setup part of the test, we define two symbols per scope, which matches the let statements in the snippet.</p>
<p>The first part of the test then expects that all the identifiers used in the arithmetic expressions can be resolved correctly. It does so by going through each scope and asking the symbol table to resolve every previously-defined symbol.</p>
<p>It can already do some of that, but now it should also recognize free variables as such and set their scope to <code>FreeScope</code>. And not only that. It also needs to keep track of which symbols were resolved as free variables. That’s what the second part of the test is about.</p>
<p>We iterate through the <code>expectedFreeSymbols</code> and make sure they match the symbol table’s <code>FreeSymbols</code>. The field doesn’t exist yet, but when it does, <code>FreeSymbols</code> should contain the <em>original</em> symbols of the <em>enclosing</em> scope. For example, when we ask the symbol table to resolve <code>c</code> and <code>d</code> while we’re in <code>secondLocal</code>, we want to get back symbols with <code>FreeScope</code>. But at the same time, the <em>original</em> symbols, which were created when the names were defined, should be added to <code>FreeSymbols</code>.</p>
<p>We need to do that because “free variable” is a relative term. A free variable in the current scope could be a local binding in the enclosing scope. And since we want to put free variables on to the stack <em>after</em> a function has been compiled, which is when we emit the <code>OpClosure</code> instruction and have left the scope of the function, we need to know how to reach these symbols while inside of the enclosing scope.</p>
<p>The input in this test is pretty close to our compiler test, isn’t it? That means we’re on the right track, but we still have something to do. We have to make sure that the symbol table doesn’t automatically mark every symbol as a free variable if it can’t resolve it:</p>
<div class="sourceCode" id="cb480"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb480-1"><a href="#cb480-1"></a><span class="co">// compiler/symbol_table_test.go</span></span>
<span id="cb480-2"><a href="#cb480-2"></a></span>
<span id="cb480-3"><a href="#cb480-3"></a><span class="kw">func</span> TestResolveUnresolvableFree(t *testing.T) {</span>
<span id="cb480-4"><a href="#cb480-4"></a>    global := NewSymbolTable()</span>
<span id="cb480-5"><a href="#cb480-5"></a>    global.Define(<span class="st">&quot;a&quot;</span>)</span>
<span id="cb480-6"><a href="#cb480-6"></a></span>
<span id="cb480-7"><a href="#cb480-7"></a>    firstLocal := NewEnclosedSymbolTable(global)</span>
<span id="cb480-8"><a href="#cb480-8"></a>    firstLocal.Define(<span class="st">&quot;c&quot;</span>)</span>
<span id="cb480-9"><a href="#cb480-9"></a></span>
<span id="cb480-10"><a href="#cb480-10"></a>    secondLocal := NewEnclosedSymbolTable(firstLocal)</span>
<span id="cb480-11"><a href="#cb480-11"></a>    secondLocal.Define(<span class="st">&quot;e&quot;</span>)</span>
<span id="cb480-12"><a href="#cb480-12"></a>    secondLocal.Define(<span class="st">&quot;f&quot;</span>)</span>
<span id="cb480-13"><a href="#cb480-13"></a></span>
<span id="cb480-14"><a href="#cb480-14"></a>    expected := []Symbol{</span>
<span id="cb480-15"><a href="#cb480-15"></a>        Symbol{Name: <span class="st">&quot;a&quot;</span>, Scope: GlobalScope, Index: <span class="dv">0</span>},</span>
<span id="cb480-16"><a href="#cb480-16"></a>        Symbol{Name: <span class="st">&quot;c&quot;</span>, Scope: FreeScope, Index: <span class="dv">0</span>},</span>
<span id="cb480-17"><a href="#cb480-17"></a>        Symbol{Name: <span class="st">&quot;e&quot;</span>, Scope: LocalScope, Index: <span class="dv">0</span>},</span>
<span id="cb480-18"><a href="#cb480-18"></a>        Symbol{Name: <span class="st">&quot;f&quot;</span>, Scope: LocalScope, Index: <span class="dv">1</span>},</span>
<span id="cb480-19"><a href="#cb480-19"></a>    }</span>
<span id="cb480-20"><a href="#cb480-20"></a></span>
<span id="cb480-21"><a href="#cb480-21"></a>    <span class="kw">for</span> _, sym := <span class="kw">range</span> expected {</span>
<span id="cb480-22"><a href="#cb480-22"></a>        result, ok := secondLocal.Resolve(sym.Name)</span>
<span id="cb480-23"><a href="#cb480-23"></a>        <span class="kw">if</span> !ok {</span>
<span id="cb480-24"><a href="#cb480-24"></a>            t.Errorf(<span class="st">&quot;name %s not resolvable&quot;</span>, sym.Name)</span>
<span id="cb480-25"><a href="#cb480-25"></a>            <span class="kw">continue</span></span>
<span id="cb480-26"><a href="#cb480-26"></a>        }</span>
<span id="cb480-27"><a href="#cb480-27"></a>        <span class="kw">if</span> result != sym {</span>
<span id="cb480-28"><a href="#cb480-28"></a>            t.Errorf(<span class="st">&quot;expected %s to resolve to %+v, got=%+v&quot;</span>,</span>
<span id="cb480-29"><a href="#cb480-29"></a>                sym.Name, sym, result)</span>
<span id="cb480-30"><a href="#cb480-30"></a>        }</span>
<span id="cb480-31"><a href="#cb480-31"></a>    }</span>
<span id="cb480-32"><a href="#cb480-32"></a></span>
<span id="cb480-33"><a href="#cb480-33"></a>    expectedUnresolvable := []<span class="dt">string</span>{</span>
<span id="cb480-34"><a href="#cb480-34"></a>        <span class="st">&quot;b&quot;</span>,</span>
<span id="cb480-35"><a href="#cb480-35"></a>        <span class="st">&quot;d&quot;</span>,</span>
<span id="cb480-36"><a href="#cb480-36"></a>    }</span>
<span id="cb480-37"><a href="#cb480-37"></a></span>
<span id="cb480-38"><a href="#cb480-38"></a>    <span class="kw">for</span> _, name := <span class="kw">range</span> expectedUnresolvable {</span>
<span id="cb480-39"><a href="#cb480-39"></a>        _, ok := secondLocal.Resolve(name)</span>
<span id="cb480-40"><a href="#cb480-40"></a>        <span class="kw">if</span> ok {</span>
<span id="cb480-41"><a href="#cb480-41"></a>            t.Errorf(<span class="st">&quot;name %s resolved, but was expected not to&quot;</span>, name)</span>
<span id="cb480-42"><a href="#cb480-42"></a>        }</span>
<span id="cb480-43"><a href="#cb480-43"></a>    }</span>
<span id="cb480-44"><a href="#cb480-44"></a>}</span></code></pre></div>
<p>Before we can get feedback from the tests, we need to define the <code>FreeSymbols</code> field on the <code>SymbolTable</code>. Otherwise they won’t compile:</p>
<div class="sourceCode" id="cb481"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb481-1"><a href="#cb481-1"></a><span class="co">// compiler/symbol_table.go</span></span>
<span id="cb481-2"><a href="#cb481-2"></a></span>
<span id="cb481-3"><a href="#cb481-3"></a><span class="kw">type</span> SymbolTable <span class="kw">struct</span> {</span>
<span id="cb481-4"><a href="#cb481-4"></a>    <span class="co">// [...]</span></span>
<span id="cb481-5"><a href="#cb481-5"></a></span>
<span id="cb481-6"><a href="#cb481-6"></a>    FreeSymbols []Symbol</span>
<span id="cb481-7"><a href="#cb481-7"></a>}</span>
<span id="cb481-8"><a href="#cb481-8"></a></span>
<span id="cb481-9"><a href="#cb481-9"></a><span class="kw">func</span> NewSymbolTable() *SymbolTable {</span>
<span id="cb481-10"><a href="#cb481-10"></a>    s := <span class="bu">make</span>(<span class="kw">map</span>[<span class="dt">string</span>]Symbol)</span>
<span id="cb481-11"><a href="#cb481-11"></a>    free := []Symbol{}</span>
<span id="cb481-12"><a href="#cb481-12"></a>    <span class="kw">return</span> &amp;SymbolTable{store: s, FreeSymbols: free}</span>
<span id="cb481-13"><a href="#cb481-13"></a>}</span></code></pre></div>
<p>Now we can run our new tests and see that they do fail as expected:</p>
<div class="sourceCode" id="cb482"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb482-1"><a href="#cb482-1"></a>$ go test -run &#39;TestResolve*&#39; ./compiler</span>
<span id="cb482-2"><a href="#cb482-2"></a>--- FAIL: TestResolveFree (0.00s)</span>
<span id="cb482-3"><a href="#cb482-3"></a> symbol_table_test.go:240: expected c to resolve to\</span>
<span id="cb482-4"><a href="#cb482-4"></a>   {Name:c Scope:FREE Index:0}, got={Name:c Scope:LOCAL Index:0}</span>
<span id="cb482-5"><a href="#cb482-5"></a> symbol_table_test.go:240: expected d to resolve to\</span>
<span id="cb482-6"><a href="#cb482-6"></a>   {Name:d Scope:FREE Index:1}, got={Name:d Scope:LOCAL Index:1}</span>
<span id="cb482-7"><a href="#cb482-7"></a> symbol_table_test.go:246: wrong number of free symbols. got=0, want=2</span>
<span id="cb482-8"><a href="#cb482-8"></a>--- FAIL: TestResolveUnresolvableFree (0.00s)</span>
<span id="cb482-9"><a href="#cb482-9"></a> symbol_table_test.go:286: expected c to resolve to\</span>
<span id="cb482-10"><a href="#cb482-10"></a>   {Name:c Scope:FREE Index:0}, got={Name:c Scope:LOCAL Index:0}</span>
<span id="cb482-11"><a href="#cb482-11"></a>FAIL</span>
<span id="cb482-12"><a href="#cb482-12"></a>FAIL    monkey/compiler 0.008s</span></code></pre></div>
<p>We expect <code>FREE</code>, but get <code>LOCAL</code> instead. Perfect. Let’s go.</p>
<p>The first thing we do is add a helper method that adds a <code>Symbol</code> to <code>FreeSymbols</code> and returns a <code>FreeScope</code> version of it:</p>
<div class="sourceCode" id="cb483"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb483-1"><a href="#cb483-1"></a><span class="co">// compiler/symbol_table.go</span></span>
<span id="cb483-2"><a href="#cb483-2"></a></span>
<span id="cb483-3"><a href="#cb483-3"></a><span class="kw">func</span> (s *SymbolTable) defineFree(original Symbol) Symbol {</span>
<span id="cb483-4"><a href="#cb483-4"></a>    s.FreeSymbols = <span class="bu">append</span>(s.FreeSymbols, original)</span>
<span id="cb483-5"><a href="#cb483-5"></a></span>
<span id="cb483-6"><a href="#cb483-6"></a>    symbol := Symbol{Name: original.Name, Index: <span class="bu">len</span>(s.FreeSymbols) - <span class="dv">1</span>}</span>
<span id="cb483-7"><a href="#cb483-7"></a>    symbol.Scope = FreeScope</span>
<span id="cb483-8"><a href="#cb483-8"></a></span>
<span id="cb483-9"><a href="#cb483-9"></a>    s.store[original.Name] = symbol</span>
<span id="cb483-10"><a href="#cb483-10"></a>    <span class="kw">return</span> symbol</span>
<span id="cb483-11"><a href="#cb483-11"></a>}</span></code></pre></div>
<p>Now we can take this method and make both tests for the symbol table pass by using it in the <code>Resolve</code> method.</p>
<p>What <code>Resolve</code> needs to do comes down to a few checks. Has the name been defined in this scope, this symbol table? No? Well, is it a global binding, or a built-in function? No again? That means it was defined as a local in an enclosing scope. In that case, from this scope’s point of view, it’s a free variable and should be resolved as such.</p>
<p>The last point means using the <code>defineFree</code> method returning a symbol with <code>Scope</code> set to <code>FreeScope</code>.</p>
<p>It’s a lot easier to express in code actually:</p>
<div class="sourceCode" id="cb484"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb484-1"><a href="#cb484-1"></a><span class="co">// compiler/symbol_table.go</span></span>
<span id="cb484-2"><a href="#cb484-2"></a></span>
<span id="cb484-3"><a href="#cb484-3"></a><span class="kw">func</span> (s *SymbolTable) Resolve(name <span class="dt">string</span>) (Symbol, <span class="dt">bool</span>) {</span>
<span id="cb484-4"><a href="#cb484-4"></a>    obj, ok := s.store[name]</span>
<span id="cb484-5"><a href="#cb484-5"></a>    <span class="kw">if</span> !ok &amp;&amp; s.Outer != <span class="ot">nil</span> {</span>
<span id="cb484-6"><a href="#cb484-6"></a>        obj, ok = s.Outer.Resolve(name)</span>
<span id="cb484-7"><a href="#cb484-7"></a>        <span class="kw">if</span> !ok {</span>
<span id="cb484-8"><a href="#cb484-8"></a>            <span class="kw">return</span> obj, ok</span>
<span id="cb484-9"><a href="#cb484-9"></a>        }</span>
<span id="cb484-10"><a href="#cb484-10"></a></span>
<span id="cb484-11"><a href="#cb484-11"></a>        <span class="kw">if</span> obj.Scope == GlobalScope || obj.Scope == BuiltinScope {</span>
<span id="cb484-12"><a href="#cb484-12"></a>            <span class="kw">return</span> obj, ok</span>
<span id="cb484-13"><a href="#cb484-13"></a>        }</span>
<span id="cb484-14"><a href="#cb484-14"></a></span>
<span id="cb484-15"><a href="#cb484-15"></a>        free := s.defineFree(obj)</span>
<span id="cb484-16"><a href="#cb484-16"></a>        <span class="kw">return</span> free, <span class="ot">true</span></span>
<span id="cb484-17"><a href="#cb484-17"></a>    }</span>
<span id="cb484-18"><a href="#cb484-18"></a>    <span class="kw">return</span> obj, ok</span>
<span id="cb484-19"><a href="#cb484-19"></a>}</span></code></pre></div>
<p>What’s new is the check whether the <code>Symbol</code>’s <code>Scope</code> is <code>GlobalScope</code> or <code>BuiltinScope</code> and the call to the new helper method <code>defineFree</code>. The rest is the recursive walk up the enclosing symbol tables we already had in place.</p>
<p>But that’s enough. We’ve reached the first destination on our way to closures: a fully-functioning symbol table that knows about free variables!</p>
<div class="sourceCode" id="cb485"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb485-1"><a href="#cb485-1"></a>$ go test -run &#39;TestResolve*&#39; ./compiler</span>
<span id="cb485-2"><a href="#cb485-2"></a>ok      monkey/compiler 0.010s</span></code></pre></div>
<p>We can head back to our failing compiler test:</p>
<div class="sourceCode" id="cb486"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb486-1"><a href="#cb486-1"></a>$ go test ./compiler</span>
<span id="cb486-2"><a href="#cb486-2"></a>--- FAIL: TestClosures (0.00s)</span>
<span id="cb486-3"><a href="#cb486-3"></a> compiler_test.go:927: testConstants failed: constant 0 -\</span>
<span id="cb486-4"><a href="#cb486-4"></a>   testInstructions failed: wrong instructions length.</span>
<span id="cb486-5"><a href="#cb486-5"></a>  want=&quot;0000 OpGetFree 0\n0002 OpGetLocal 0\n0004 OpAdd\n0005 OpReturnValue\n&quot;</span>
<span id="cb486-6"><a href="#cb486-6"></a>  got =&quot;0000 OpGetLocal 0\n0002 OpAdd\n0003 OpReturnValue\n&quot;</span>
<span id="cb486-7"><a href="#cb486-7"></a>FAIL</span>
<span id="cb486-8"><a href="#cb486-8"></a>FAIL    monkey/compiler 0.008s</span></code></pre></div>
<p>Now that the symbol table knows about free variables, we only need to add two lines to the compilers <code>loadSymbol</code> method to fix this particular test:</p>
<div class="sourceCode" id="cb487"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb487-1"><a href="#cb487-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb487-2"><a href="#cb487-2"></a></span>
<span id="cb487-3"><a href="#cb487-3"></a><span class="kw">func</span> (c *Compiler) loadSymbol(s Symbol) {</span>
<span id="cb487-4"><a href="#cb487-4"></a>    <span class="kw">switch</span> s.Scope {</span>
<span id="cb487-5"><a href="#cb487-5"></a>    <span class="kw">case</span> GlobalScope:</span>
<span id="cb487-6"><a href="#cb487-6"></a>        c.emit(code.OpGetGlobal, s.Index)</span>
<span id="cb487-7"><a href="#cb487-7"></a>    <span class="kw">case</span> LocalScope:</span>
<span id="cb487-8"><a href="#cb487-8"></a>        c.emit(code.OpGetLocal, s.Index)</span>
<span id="cb487-9"><a href="#cb487-9"></a>    <span class="kw">case</span> BuiltinScope:</span>
<span id="cb487-10"><a href="#cb487-10"></a>        c.emit(code.OpGetBuiltin, s.Index)</span>
<span id="cb487-11"><a href="#cb487-11"></a>    <span class="kw">case</span> FreeScope:</span>
<span id="cb487-12"><a href="#cb487-12"></a>        c.emit(code.OpGetFree, s.Index)</span>
<span id="cb487-13"><a href="#cb487-13"></a>    }</span>
<span id="cb487-14"><a href="#cb487-14"></a>}</span></code></pre></div>
<p>That gives us the correct <code>OpGetFree</code> instructions <em>inside a closure</em>. But outside, things still don’t work as expected:</p>
<div class="sourceCode" id="cb488"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb488-1"><a href="#cb488-1"></a>$ go test ./compiler</span>
<span id="cb488-2"><a href="#cb488-2"></a>--- FAIL: TestClosures (0.00s)</span>
<span id="cb488-3"><a href="#cb488-3"></a> compiler_test.go:900: testConstants failed: constant 1 -\</span>
<span id="cb488-4"><a href="#cb488-4"></a>   testInstructions failed: wrong instructions length.</span>
<span id="cb488-5"><a href="#cb488-5"></a>  want=&quot;0000 OpGetLocal 0\n0002 OpClosure 0 1\n0006 OpReturnValue\n&quot;</span>
<span id="cb488-6"><a href="#cb488-6"></a>  got =&quot;0000 OpClosure 0 0\n0004 OpReturnValue\n&quot;</span>
<span id="cb488-7"><a href="#cb488-7"></a>FAIL</span>
<span id="cb488-8"><a href="#cb488-8"></a>FAIL    monkey/compiler 0.009s</span></code></pre></div>
<p>This tells us that we’re not loading the free variables on to the stack after we compiled a function and that the second operand for the <code>OpClosure</code> instruction is still the hardcoded <code>0</code>.</p>
<p>What we have to do, right after we compiled a function’s body, is iterate through the <code>FreeSymbols</code> of the <code>SymbolTable</code> we just “left” and <code>loadSymbol</code> them. That should result in instructions in the enclosing scope that put the free variables on to the stack.</p>
<p>Here, too, the code explains things much more concisely than I can in prose:</p>
<div class="sourceCode" id="cb489"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb489-1"><a href="#cb489-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb489-2"><a href="#cb489-2"></a></span>
<span id="cb489-3"><a href="#cb489-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb489-4"><a href="#cb489-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb489-5"><a href="#cb489-5"></a>    <span class="co">// [...]</span></span>
<span id="cb489-6"><a href="#cb489-6"></a></span>
<span id="cb489-7"><a href="#cb489-7"></a>    <span class="kw">case</span> *ast.FunctionLiteral:</span>
<span id="cb489-8"><a href="#cb489-8"></a>        <span class="co">// [...]</span></span>
<span id="cb489-9"><a href="#cb489-9"></a>        <span class="kw">if</span> !c.lastInstructionIs(code.OpReturnValue) {</span>
<span id="cb489-10"><a href="#cb489-10"></a>            c.emit(code.OpReturn)</span>
<span id="cb489-11"><a href="#cb489-11"></a>        }</span>
<span id="cb489-12"><a href="#cb489-12"></a></span>
<span id="cb489-13"><a href="#cb489-13"></a>        freeSymbols := c.symbolTable.FreeSymbols</span>
<span id="cb489-14"><a href="#cb489-14"></a>        numLocals := c.symbolTable.numDefinitions</span>
<span id="cb489-15"><a href="#cb489-15"></a>        instructions := c.leaveScope()</span>
<span id="cb489-16"><a href="#cb489-16"></a></span>
<span id="cb489-17"><a href="#cb489-17"></a>        <span class="kw">for</span> _, s := <span class="kw">range</span> freeSymbols {</span>
<span id="cb489-18"><a href="#cb489-18"></a>            c.loadSymbol(s)</span>
<span id="cb489-19"><a href="#cb489-19"></a>        }</span>
<span id="cb489-20"><a href="#cb489-20"></a></span>
<span id="cb489-21"><a href="#cb489-21"></a>        compiledFn := &amp;object.CompiledFunction{</span>
<span id="cb489-22"><a href="#cb489-22"></a>            Instructions:  instructions,</span>
<span id="cb489-23"><a href="#cb489-23"></a>            NumLocals:     numLocals,</span>
<span id="cb489-24"><a href="#cb489-24"></a>            NumParameters: <span class="bu">len</span>(node.Parameters),</span>
<span id="cb489-25"><a href="#cb489-25"></a>        }</span>
<span id="cb489-26"><a href="#cb489-26"></a></span>
<span id="cb489-27"><a href="#cb489-27"></a>        fnIndex := c.addConstant(compiledFn)</span>
<span id="cb489-28"><a href="#cb489-28"></a>        c.emit(code.OpClosure, fnIndex, <span class="bu">len</span>(freeSymbols))</span>
<span id="cb489-29"><a href="#cb489-29"></a></span>
<span id="cb489-30"><a href="#cb489-30"></a>    <span class="co">// [...]</span></span>
<span id="cb489-31"><a href="#cb489-31"></a>    }</span>
<span id="cb489-32"><a href="#cb489-32"></a></span>
<span id="cb489-33"><a href="#cb489-33"></a>    <span class="co">// [...]</span></span>
<span id="cb489-34"><a href="#cb489-34"></a>}</span></code></pre></div>
<p>A lot of this is just presented here to give you context for the changes, which are only five lines of code.</p>
<p>The first new line is the assignment of <code>freeSymbols</code>. It’s important that this happens <em>before</em> we call <code>c.leaveScope()</code>. Then, <em>after</em> we left the scope, we iterate through the <code>freeSymbols</code> in a loop and <code>c.loadSymbol</code> each.</p>
<p>The <code>len(freeSymbols)</code> is then used as the second operand to the <code>OpClosure</code> instruction. After the <code>c.loadSymbol</code> calls, the free variables sit on the stack waiting to be merged with an <code>*object.CompiledFunction</code> into an <code>*object.Closure</code>.</p>
<p>Five lines that give us a lot:</p>
<div class="sourceCode" id="cb490"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb490-1"><a href="#cb490-1"></a>$ go test ./compiler</span>
<span id="cb490-2"><a href="#cb490-2"></a>ok      monkey/compiler 0.008s</span></code></pre></div>
<p>Would you look at that! We are successfully compiling closures! Compile time, check. Now we need to take care of the run time, which is when the magic of closures emerges.</p>
<h2 id="creating-real-closures-at-run-time">Creating real closures at run time</h2>
<p>Our VM is already running on closures. It doesn’t execute <code>*object.CompiledFunction</code>s anymore, but wraps them in <code>*object.Closure</code>s when it executes an <code>OpClosure</code> instruction and then calls and executes those.</p>
<p>What’s missing is the part that creates “real” closures: the transfer of free variables to these closures and executing the <code>OpGetFree</code> instructions that load them on to the stack. Since we were so diligent about the preparation we can reach this goal with ease, taking tiny, easy to understand steps.</p>
<p>We start with a test that expects the VM to handle the simplest possible version of a real closure:</p>
<div class="sourceCode" id="cb491"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb491-1"><a href="#cb491-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb491-2"><a href="#cb491-2"></a></span>
<span id="cb491-3"><a href="#cb491-3"></a><span class="kw">func</span> TestClosures(t *testing.T) {</span>
<span id="cb491-4"><a href="#cb491-4"></a>    tests := []vmTestCase{</span>
<span id="cb491-5"><a href="#cb491-5"></a>        {</span>
<span id="cb491-6"><a href="#cb491-6"></a>            input: <span class="st">`</span></span>
<span id="cb491-7"><a href="#cb491-7"></a><span class="st">        let newClosure = fn(a) {</span></span>
<span id="cb491-8"><a href="#cb491-8"></a><span class="st">            fn() { a; };</span></span>
<span id="cb491-9"><a href="#cb491-9"></a><span class="st">        };</span></span>
<span id="cb491-10"><a href="#cb491-10"></a><span class="st">        let closure = newClosure(99);</span></span>
<span id="cb491-11"><a href="#cb491-11"></a><span class="st">        closure();</span></span>
<span id="cb491-12"><a href="#cb491-12"></a><span class="st">        `</span>,</span>
<span id="cb491-13"><a href="#cb491-13"></a>            expected: <span class="dv">99</span>,</span>
<span id="cb491-14"><a href="#cb491-14"></a>        },</span>
<span id="cb491-15"><a href="#cb491-15"></a>    }</span>
<span id="cb491-16"><a href="#cb491-16"></a></span>
<span id="cb491-17"><a href="#cb491-17"></a>    runVmTests(t, tests)</span>
<span id="cb491-18"><a href="#cb491-18"></a>}</span></code></pre></div>
<p>In the test input <code>newClosure</code> returns a closure that closes over one free variable, the <code>a</code> parameter of <code>newClosure</code>. When the returned closure is called it should return this <code>a</code>. One closure, one free variable, one enclosing scope. We can do this.</p>
<p>The first thing we have to do is make use of the <code>OpClosure</code>’s second operand, which tells the VM how many free variables should be transferred to the specified closure. We’re already decoding but ignoring it, because we didn’t have free variables in place. Now we do and we have to use it to get them to work:</p>
<div class="sourceCode" id="cb492"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb492-1"><a href="#cb492-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb492-2"><a href="#cb492-2"></a></span>
<span id="cb492-3"><a href="#cb492-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb492-4"><a href="#cb492-4"></a>    <span class="co">// [...]</span></span>
<span id="cb492-5"><a href="#cb492-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb492-6"><a href="#cb492-6"></a>        <span class="co">// [...]</span></span>
<span id="cb492-7"><a href="#cb492-7"></a></span>
<span id="cb492-8"><a href="#cb492-8"></a>        <span class="kw">case</span> code.OpClosure:</span>
<span id="cb492-9"><a href="#cb492-9"></a>            constIndex := code.ReadUint16(ins[ip+<span class="dv">1</span>:])</span>
<span id="cb492-10"><a href="#cb492-10"></a>            numFree := code.ReadUint8(ins[ip+<span class="dv">3</span>:])</span>
<span id="cb492-11"><a href="#cb492-11"></a>            vm.currentFrame().ip += <span class="dv">3</span></span>
<span id="cb492-12"><a href="#cb492-12"></a></span>
<span id="cb492-13"><a href="#cb492-13"></a>            err := vm.pushClosure(<span class="dt">int</span>(constIndex), <span class="dt">int</span>(numFree))</span>
<span id="cb492-14"><a href="#cb492-14"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb492-15"><a href="#cb492-15"></a>                <span class="kw">return</span> err</span>
<span id="cb492-16"><a href="#cb492-16"></a>            }</span>
<span id="cb492-17"><a href="#cb492-17"></a></span>
<span id="cb492-18"><a href="#cb492-18"></a>        <span class="co">// [...]</span></span>
<span id="cb492-19"><a href="#cb492-19"></a>        }</span>
<span id="cb492-20"><a href="#cb492-20"></a>    <span class="co">// [...]</span></span>
<span id="cb492-21"><a href="#cb492-21"></a>}</span></code></pre></div>
<p>We now pass two arguments to <code>pushClosure</code>: the index of the compiled function in the constant pool and the number of free variables waiting on the stack. Here it is:</p>
<div class="sourceCode" id="cb493"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb493-1"><a href="#cb493-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb493-2"><a href="#cb493-2"></a></span>
<span id="cb493-3"><a href="#cb493-3"></a><span class="kw">func</span> (vm *VM) pushClosure(constIndex, numFree <span class="dt">int</span>) <span class="dt">error</span> {</span>
<span id="cb493-4"><a href="#cb493-4"></a>    constant := vm.constants[constIndex]</span>
<span id="cb493-5"><a href="#cb493-5"></a>    function, ok := constant.(*object.CompiledFunction)</span>
<span id="cb493-6"><a href="#cb493-6"></a>    <span class="kw">if</span> !ok {</span>
<span id="cb493-7"><a href="#cb493-7"></a>        <span class="kw">return</span> fmt.Errorf(<span class="st">&quot;not a function: %+v&quot;</span>, constant)</span>
<span id="cb493-8"><a href="#cb493-8"></a>    }</span>
<span id="cb493-9"><a href="#cb493-9"></a></span>
<span id="cb493-10"><a href="#cb493-10"></a>    free := <span class="bu">make</span>([]object.Object, numFree)</span>
<span id="cb493-11"><a href="#cb493-11"></a>    <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; numFree; i++ {</span>
<span id="cb493-12"><a href="#cb493-12"></a>        free[i] = vm.stack[vm.sp-numFree+i]</span>
<span id="cb493-13"><a href="#cb493-13"></a>    }</span>
<span id="cb493-14"><a href="#cb493-14"></a>    vm.sp = vm.sp - numFree</span>
<span id="cb493-15"><a href="#cb493-15"></a></span>
<span id="cb493-16"><a href="#cb493-16"></a>    closure := &amp;object.Closure{Fn: function, Free: free}</span>
<span id="cb493-17"><a href="#cb493-17"></a>    <span class="kw">return</span> vm.push(closure)</span>
<span id="cb493-18"><a href="#cb493-18"></a>}</span></code></pre></div>
<p>New is the middle part. Here we take the second parameter, <code>numFree</code>, to construct a slice, <code>free</code>. Then, starting with the one that’s lowest on the stack, we take each free variable and copy it to <code>free</code>. Afterwards we clean up the stack by decrementing <code>vm.sp</code> manually.</p>
<p>The order of the copying is important, because that’s the same order in which the free variables were referenced inside the closure’s body and with which we put them on to the stack. If we were to reverse the order, the operands of the <code>GetFree</code> instructions would be wrong. That brings us to our next point: our VM doesn’t know about <code>OpGetFree</code> yet.</p>
<p>Implementing <code>OpGetFree</code> is not markedly different from implementing the other <code>OpGet*</code> instructions, except for the place from which the values are retrieved. This time it’s the <code>Free</code> slice of the <code>*object.Closure</code> the VM is currently executing:</p>
<div class="sourceCode" id="cb494"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb494-1"><a href="#cb494-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb494-2"><a href="#cb494-2"></a></span>
<span id="cb494-3"><a href="#cb494-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb494-4"><a href="#cb494-4"></a>    <span class="co">// [...]</span></span>
<span id="cb494-5"><a href="#cb494-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb494-6"><a href="#cb494-6"></a>        <span class="co">// [...]</span></span>
<span id="cb494-7"><a href="#cb494-7"></a></span>
<span id="cb494-8"><a href="#cb494-8"></a>        <span class="kw">case</span> code.OpGetFree:</span>
<span id="cb494-9"><a href="#cb494-9"></a>            freeIndex := code.ReadUint8(ins[ip+<span class="dv">1</span>:])</span>
<span id="cb494-10"><a href="#cb494-10"></a>            vm.currentFrame().ip += <span class="dv">1</span></span>
<span id="cb494-11"><a href="#cb494-11"></a></span>
<span id="cb494-12"><a href="#cb494-12"></a>            currentClosure := vm.currentFrame().cl</span>
<span id="cb494-13"><a href="#cb494-13"></a>            err := vm.push(currentClosure.Free[freeIndex])</span>
<span id="cb494-14"><a href="#cb494-14"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb494-15"><a href="#cb494-15"></a>                <span class="kw">return</span> err</span>
<span id="cb494-16"><a href="#cb494-16"></a>            }</span>
<span id="cb494-17"><a href="#cb494-17"></a></span>
<span id="cb494-18"><a href="#cb494-18"></a>        <span class="co">// [...]</span></span>
<span id="cb494-19"><a href="#cb494-19"></a>        }</span>
<span id="cb494-20"><a href="#cb494-20"></a>    <span class="co">// [...]</span></span>
<span id="cb494-21"><a href="#cb494-21"></a>}</span></code></pre></div>
<p>As I said, only the place has changed. We decode the operand and use it as an index into the <code>Free</code> slice to retrieve the value and push it on to the stack. That’s all there is to it.</p>
<p>Now, in case you have a standing desk, you might want to sit down for this one. Take a look:</p>
<div class="sourceCode" id="cb495"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb495-1"><a href="#cb495-1"></a>$ go test ./vm</span>
<span id="cb495-2"><a href="#cb495-2"></a>ok      monkey/vm   0.036s</span></code></pre></div>
<p>Yes, really. We implemented real closures! Fully! We’re done! Don’t believe me? Let’s throw some more tests at our VM and see what it does:</p>
<div class="sourceCode" id="cb496"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb496-1"><a href="#cb496-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb496-2"><a href="#cb496-2"></a></span>
<span id="cb496-3"><a href="#cb496-3"></a><span class="kw">func</span> TestClosures(t *testing.T) {</span>
<span id="cb496-4"><a href="#cb496-4"></a>    tests := []vmTestCase{</span>
<span id="cb496-5"><a href="#cb496-5"></a>        <span class="co">// [...]</span></span>
<span id="cb496-6"><a href="#cb496-6"></a>        {</span>
<span id="cb496-7"><a href="#cb496-7"></a>            input: <span class="st">`</span></span>
<span id="cb496-8"><a href="#cb496-8"></a><span class="st">        let newAdder = fn(a, b) {</span></span>
<span id="cb496-9"><a href="#cb496-9"></a><span class="st">            fn(c) { a + b + c };</span></span>
<span id="cb496-10"><a href="#cb496-10"></a><span class="st">        };</span></span>
<span id="cb496-11"><a href="#cb496-11"></a><span class="st">        let adder = newAdder(1, 2);</span></span>
<span id="cb496-12"><a href="#cb496-12"></a><span class="st">        adder(8);</span></span>
<span id="cb496-13"><a href="#cb496-13"></a><span class="st">        `</span>,</span>
<span id="cb496-14"><a href="#cb496-14"></a>            expected: <span class="dv">11</span>,</span>
<span id="cb496-15"><a href="#cb496-15"></a>        },</span>
<span id="cb496-16"><a href="#cb496-16"></a>        {</span>
<span id="cb496-17"><a href="#cb496-17"></a>            input: <span class="st">`</span></span>
<span id="cb496-18"><a href="#cb496-18"></a><span class="st">        let newAdder = fn(a, b) {</span></span>
<span id="cb496-19"><a href="#cb496-19"></a><span class="st">            let c = a + b;</span></span>
<span id="cb496-20"><a href="#cb496-20"></a><span class="st">            fn(d) { c + d };</span></span>
<span id="cb496-21"><a href="#cb496-21"></a><span class="st">        };</span></span>
<span id="cb496-22"><a href="#cb496-22"></a><span class="st">        let adder = newAdder(1, 2);</span></span>
<span id="cb496-23"><a href="#cb496-23"></a><span class="st">        adder(8);</span></span>
<span id="cb496-24"><a href="#cb496-24"></a><span class="st">        `</span>,</span>
<span id="cb496-25"><a href="#cb496-25"></a>            expected: <span class="dv">11</span>,</span>
<span id="cb496-26"><a href="#cb496-26"></a>        },</span>
<span id="cb496-27"><a href="#cb496-27"></a>    }</span>
<span id="cb496-28"><a href="#cb496-28"></a></span>
<span id="cb496-29"><a href="#cb496-29"></a>    runVmTests(t, tests)</span>
<span id="cb496-30"><a href="#cb496-30"></a>}</span></code></pre></div>
<p>Here we have closures that reference multiple free variables, some defined as parameters in the enclosing function, some as local variables. Cross your fingers:</p>
<div class="sourceCode" id="cb497"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb497-1"><a href="#cb497-1"></a>$ go test ./vm</span>
<span id="cb497-2"><a href="#cb497-2"></a>ok      monkey/vm   0.035s</span></code></pre></div>
<p>Sweet! Let’s take it up a notch:</p>
<div class="sourceCode" id="cb498"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb498-1"><a href="#cb498-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb498-2"><a href="#cb498-2"></a></span>
<span id="cb498-3"><a href="#cb498-3"></a><span class="kw">func</span> TestClosures(t *testing.T) {</span>
<span id="cb498-4"><a href="#cb498-4"></a>    tests := []vmTestCase{</span>
<span id="cb498-5"><a href="#cb498-5"></a>        <span class="co">// [...]</span></span>
<span id="cb498-6"><a href="#cb498-6"></a>        {</span>
<span id="cb498-7"><a href="#cb498-7"></a>            input: <span class="st">`</span></span>
<span id="cb498-8"><a href="#cb498-8"></a><span class="st">        let newAdderOuter = fn(a, b) {</span></span>
<span id="cb498-9"><a href="#cb498-9"></a><span class="st">            let c = a + b;</span></span>
<span id="cb498-10"><a href="#cb498-10"></a><span class="st">            fn(d) {</span></span>
<span id="cb498-11"><a href="#cb498-11"></a><span class="st">                let e = d + c;</span></span>
<span id="cb498-12"><a href="#cb498-12"></a><span class="st">                fn(f) { e + f; };</span></span>
<span id="cb498-13"><a href="#cb498-13"></a><span class="st">            };</span></span>
<span id="cb498-14"><a href="#cb498-14"></a><span class="st">        };</span></span>
<span id="cb498-15"><a href="#cb498-15"></a><span class="st">        let newAdderInner = newAdderOuter(1, 2)</span></span>
<span id="cb498-16"><a href="#cb498-16"></a><span class="st">        let adder = newAdderInner(3);</span></span>
<span id="cb498-17"><a href="#cb498-17"></a><span class="st">        adder(8);</span></span>
<span id="cb498-18"><a href="#cb498-18"></a><span class="st">        `</span>,</span>
<span id="cb498-19"><a href="#cb498-19"></a>            expected: <span class="dv">14</span>,</span>
<span id="cb498-20"><a href="#cb498-20"></a>        },</span>
<span id="cb498-21"><a href="#cb498-21"></a>        {</span>
<span id="cb498-22"><a href="#cb498-22"></a>            input: <span class="st">`</span></span>
<span id="cb498-23"><a href="#cb498-23"></a><span class="st">        let a = 1;</span></span>
<span id="cb498-24"><a href="#cb498-24"></a><span class="st">        let newAdderOuter = fn(b) {</span></span>
<span id="cb498-25"><a href="#cb498-25"></a><span class="st">            fn(c) {</span></span>
<span id="cb498-26"><a href="#cb498-26"></a><span class="st">                fn(d) { a + b + c + d };</span></span>
<span id="cb498-27"><a href="#cb498-27"></a><span class="st">            };</span></span>
<span id="cb498-28"><a href="#cb498-28"></a><span class="st">        };</span></span>
<span id="cb498-29"><a href="#cb498-29"></a><span class="st">        let newAdderInner = newAdderOuter(2)</span></span>
<span id="cb498-30"><a href="#cb498-30"></a><span class="st">        let adder = newAdderInner(3);</span></span>
<span id="cb498-31"><a href="#cb498-31"></a><span class="st">        adder(8);</span></span>
<span id="cb498-32"><a href="#cb498-32"></a><span class="st">        `</span>,</span>
<span id="cb498-33"><a href="#cb498-33"></a>            expected: <span class="dv">14</span>,</span>
<span id="cb498-34"><a href="#cb498-34"></a>        },</span>
<span id="cb498-35"><a href="#cb498-35"></a>        {</span>
<span id="cb498-36"><a href="#cb498-36"></a>            input: <span class="st">`</span></span>
<span id="cb498-37"><a href="#cb498-37"></a><span class="st">        let newClosure = fn(a, b) {</span></span>
<span id="cb498-38"><a href="#cb498-38"></a><span class="st">            let one = fn() { a; };</span></span>
<span id="cb498-39"><a href="#cb498-39"></a><span class="st">            let two = fn() { b; };</span></span>
<span id="cb498-40"><a href="#cb498-40"></a><span class="st">            fn() { one() + two(); };</span></span>
<span id="cb498-41"><a href="#cb498-41"></a><span class="st">        };</span></span>
<span id="cb498-42"><a href="#cb498-42"></a><span class="st">        let closure = newClosure(9, 90);</span></span>
<span id="cb498-43"><a href="#cb498-43"></a><span class="st">        closure();</span></span>
<span id="cb498-44"><a href="#cb498-44"></a><span class="st">        `</span>,</span>
<span id="cb498-45"><a href="#cb498-45"></a>            expected: <span class="dv">99</span>,</span>
<span id="cb498-46"><a href="#cb498-46"></a>        },</span>
<span id="cb498-47"><a href="#cb498-47"></a>    }</span>
<span id="cb498-48"><a href="#cb498-48"></a></span>
<span id="cb498-49"><a href="#cb498-49"></a>  runVmTests(t, tests)</span>
<span id="cb498-50"><a href="#cb498-50"></a>}</span></code></pre></div>
<p>Now we have closures that return other closures, global bindings, local bindings, multiple closures being called in other closures, all thrown together and this thing still runs:</p>
<div class="sourceCode" id="cb499"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb499-1"><a href="#cb499-1"></a>$ go test ./vm</span>
<span id="cb499-2"><a href="#cb499-2"></a>ok      monkey/vm   0.039s</span></code></pre></div>
<p>This is as close as you can get to “certified working”, but there is one last thing, a peculiar use of closures that doesn’t work yet: a closure that calls itself – a recursive closure.</p>
<h2 id="recursive-closures">Recursive Closures</h2>
<p>Here is the first problem we run into when trying to define and call a recursive closure, stated in the plainest of terms: a failing test case.</p>
<div class="sourceCode" id="cb500"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb500-1"><a href="#cb500-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb500-2"><a href="#cb500-2"></a></span>
<span id="cb500-3"><a href="#cb500-3"></a><span class="kw">func</span> TestRecursiveFunctions(t *testing.T) {</span>
<span id="cb500-4"><a href="#cb500-4"></a>    tests := []vmTestCase{</span>
<span id="cb500-5"><a href="#cb500-5"></a>        {</span>
<span id="cb500-6"><a href="#cb500-6"></a>            input: <span class="st">`</span></span>
<span id="cb500-7"><a href="#cb500-7"></a><span class="st">        let countDown = fn(x) {</span></span>
<span id="cb500-8"><a href="#cb500-8"></a><span class="st">            if (x == 0) {</span></span>
<span id="cb500-9"><a href="#cb500-9"></a><span class="st">                return 0;</span></span>
<span id="cb500-10"><a href="#cb500-10"></a><span class="st">            } else {</span></span>
<span id="cb500-11"><a href="#cb500-11"></a><span class="st">                countDown(x - 1);</span></span>
<span id="cb500-12"><a href="#cb500-12"></a><span class="st">            }</span></span>
<span id="cb500-13"><a href="#cb500-13"></a><span class="st">        };</span></span>
<span id="cb500-14"><a href="#cb500-14"></a><span class="st">        countDown(1);</span></span>
<span id="cb500-15"><a href="#cb500-15"></a><span class="st">        `</span>,</span>
<span id="cb500-16"><a href="#cb500-16"></a>            expected: <span class="dv">0</span>,</span>
<span id="cb500-17"><a href="#cb500-17"></a>        },</span>
<span id="cb500-18"><a href="#cb500-18"></a>    }</span>
<span id="cb500-19"><a href="#cb500-19"></a></span>
<span id="cb500-20"><a href="#cb500-20"></a>    runVmTests(t, tests)</span>
<span id="cb500-21"><a href="#cb500-21"></a>}</span></code></pre></div>
<p>There’s not much to explain here. We have a tiny function, called <code>countDown</code>, that calls itself and when we run the test we’re told that <code>countDown</code> can’t find itself:</p>
<div class="sourceCode" id="cb501"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb501-1"><a href="#cb501-1"></a>$ go test ./vm -run TestRecursiveFunctions</span>
<span id="cb501-2"><a href="#cb501-2"></a>--- FAIL: TestRecursiveFunctions (0.00s)</span>
<span id="cb501-3"><a href="#cb501-3"></a> vm_test.go:559: compiler error: undefined variable countDown</span>
<span id="cb501-4"><a href="#cb501-4"></a>FAIL</span>
<span id="cb501-5"><a href="#cb501-5"></a>FAIL    monkey/vm   0.006s</span></code></pre></div>
<p>But this problem is harmless and easy to fix. All we have to do is go into the compiler and take this part:</p>
<div class="sourceCode" id="cb502"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb502-1"><a href="#cb502-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb502-2"><a href="#cb502-2"></a></span>
<span id="cb502-3"><a href="#cb502-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb502-4"><a href="#cb502-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb502-5"><a href="#cb502-5"></a>    <span class="co">// [...]</span></span>
<span id="cb502-6"><a href="#cb502-6"></a></span>
<span id="cb502-7"><a href="#cb502-7"></a>    <span class="kw">case</span> *ast.LetStatement:</span>
<span id="cb502-8"><a href="#cb502-8"></a>        err := c.Compile(node.Value)</span>
<span id="cb502-9"><a href="#cb502-9"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb502-10"><a href="#cb502-10"></a>            <span class="kw">return</span> err</span>
<span id="cb502-11"><a href="#cb502-11"></a>        }</span>
<span id="cb502-12"><a href="#cb502-12"></a></span>
<span id="cb502-13"><a href="#cb502-13"></a>        symbol := c.symbolTable.Define(node.Name.Value)</span>
<span id="cb502-14"><a href="#cb502-14"></a>        <span class="kw">if</span> symbol.Scope == GlobalScope {</span>
<span id="cb502-15"><a href="#cb502-15"></a>            c.emit(code.OpSetGlobal, symbol.Index)</span>
<span id="cb502-16"><a href="#cb502-16"></a>        } <span class="kw">else</span> {</span>
<span id="cb502-17"><a href="#cb502-17"></a>            c.emit(code.OpSetLocal, symbol.Index)</span>
<span id="cb502-18"><a href="#cb502-18"></a>        }</span>
<span id="cb502-19"><a href="#cb502-19"></a></span>
<span id="cb502-20"><a href="#cb502-20"></a>    <span class="co">// [...]</span></span>
<span id="cb502-21"><a href="#cb502-21"></a>    }</span>
<span id="cb502-22"><a href="#cb502-22"></a></span>
<span id="cb502-23"><a href="#cb502-23"></a>    <span class="co">// [...]</span></span>
<span id="cb502-24"><a href="#cb502-24"></a>}</span></code></pre></div>
<p>And move one line, the <code>symbol := ...</code>, further up, to right below the <code>case *ast.LetStatement</code>:</p>
<div class="sourceCode" id="cb503"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb503-1"><a href="#cb503-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb503-2"><a href="#cb503-2"></a></span>
<span id="cb503-3"><a href="#cb503-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb503-4"><a href="#cb503-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb503-5"><a href="#cb503-5"></a>    <span class="co">// [...]</span></span>
<span id="cb503-6"><a href="#cb503-6"></a></span>
<span id="cb503-7"><a href="#cb503-7"></a>    <span class="kw">case</span> *ast.LetStatement:</span>
<span id="cb503-8"><a href="#cb503-8"></a>        symbol := c.symbolTable.Define(node.Name.Value)</span>
<span id="cb503-9"><a href="#cb503-9"></a>        err := c.Compile(node.Value)</span>
<span id="cb503-10"><a href="#cb503-10"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb503-11"><a href="#cb503-11"></a>            <span class="kw">return</span> err</span>
<span id="cb503-12"><a href="#cb503-12"></a>        }</span>
<span id="cb503-13"><a href="#cb503-13"></a></span>
<span id="cb503-14"><a href="#cb503-14"></a>        <span class="kw">if</span> symbol.Scope == GlobalScope {</span>
<span id="cb503-15"><a href="#cb503-15"></a>            c.emit(code.OpSetGlobal, symbol.Index)</span>
<span id="cb503-16"><a href="#cb503-16"></a>        } <span class="kw">else</span> {</span>
<span id="cb503-17"><a href="#cb503-17"></a>            c.emit(code.OpSetLocal, symbol.Index)</span>
<span id="cb503-18"><a href="#cb503-18"></a>        }</span>
<span id="cb503-19"><a href="#cb503-19"></a></span>
<span id="cb503-20"><a href="#cb503-20"></a>    <span class="co">// [...]</span></span>
<span id="cb503-21"><a href="#cb503-21"></a>    }</span>
<span id="cb503-22"><a href="#cb503-22"></a></span>
<span id="cb503-23"><a href="#cb503-23"></a>    <span class="co">// [...]</span></span>
<span id="cb503-24"><a href="#cb503-24"></a>}</span></code></pre></div>
<p>What the code now does is to define the name to which a function will be bound in the symbol table, right before the body is compiled, allowing the function’s body to reference the name of the function. A one-line change that gives us this:</p>
<div class="sourceCode" id="cb504"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb504-1"><a href="#cb504-1"></a>$ go test ./vm</span>
<span id="cb504-2"><a href="#cb504-2"></a>ok      monkey/vm   0.033s</span></code></pre></div>
<p>The test passes – it certainly <em>looks</em> like we’ve implemented recursive function calls. We can add another test case to make sure that this is not an edge case that only works in the global scope:</p>
<div class="sourceCode" id="cb505"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb505-1"><a href="#cb505-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb505-2"><a href="#cb505-2"></a></span>
<span id="cb505-3"><a href="#cb505-3"></a><span class="kw">func</span> TestRecursiveFunctions(t *testing.T) {</span>
<span id="cb505-4"><a href="#cb505-4"></a>    tests := []vmTestCase{</span>
<span id="cb505-5"><a href="#cb505-5"></a>        <span class="co">// [...]</span></span>
<span id="cb505-6"><a href="#cb505-6"></a>        {</span>
<span id="cb505-7"><a href="#cb505-7"></a>            input: <span class="st">`</span></span>
<span id="cb505-8"><a href="#cb505-8"></a><span class="st">        let countDown = fn(x) {</span></span>
<span id="cb505-9"><a href="#cb505-9"></a><span class="st">            if (x == 0) {</span></span>
<span id="cb505-10"><a href="#cb505-10"></a><span class="st">                return 0;</span></span>
<span id="cb505-11"><a href="#cb505-11"></a><span class="st">            } else {</span></span>
<span id="cb505-12"><a href="#cb505-12"></a><span class="st">                countDown(x - 1);</span></span>
<span id="cb505-13"><a href="#cb505-13"></a><span class="st">            }</span></span>
<span id="cb505-14"><a href="#cb505-14"></a><span class="st">        };</span></span>
<span id="cb505-15"><a href="#cb505-15"></a><span class="st">        let wrapper = fn() {</span></span>
<span id="cb505-16"><a href="#cb505-16"></a><span class="st">            countDown(1);</span></span>
<span id="cb505-17"><a href="#cb505-17"></a><span class="st">        };</span></span>
<span id="cb505-18"><a href="#cb505-18"></a><span class="st">        wrapper();</span></span>
<span id="cb505-19"><a href="#cb505-19"></a><span class="st">        `</span>,</span>
<span id="cb505-20"><a href="#cb505-20"></a>            expected: <span class="dv">0</span>,</span>
<span id="cb505-21"><a href="#cb505-21"></a>        },</span>
<span id="cb505-22"><a href="#cb505-22"></a>    }</span>
<span id="cb505-23"><a href="#cb505-23"></a></span>
<span id="cb505-24"><a href="#cb505-24"></a>    runVmTests(t, tests)</span>
<span id="cb505-25"><a href="#cb505-25"></a>}</span></code></pre></div>
<p>Let’s run it:</p>
<div class="sourceCode" id="cb506"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb506-1"><a href="#cb506-1"></a>$ go test ./vm</span>
<span id="cb506-2"><a href="#cb506-2"></a>ok      monkey/vm   0.030s</span></code></pre></div>
<p>OK, this also works. Now, what if we <em>combine</em> those two test cases and define a recursive function <em>inside</em> another function and also call it inside this other function?</p>
<div class="sourceCode" id="cb507"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb507-1"><a href="#cb507-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb507-2"><a href="#cb507-2"></a></span>
<span id="cb507-3"><a href="#cb507-3"></a><span class="kw">func</span> TestRecursiveFunctions(t *testing.T) {</span>
<span id="cb507-4"><a href="#cb507-4"></a>    tests := []vmTestCase{</span>
<span id="cb507-5"><a href="#cb507-5"></a>        <span class="co">// [...]</span></span>
<span id="cb507-6"><a href="#cb507-6"></a>        {</span>
<span id="cb507-7"><a href="#cb507-7"></a>            input: <span class="st">`</span></span>
<span id="cb507-8"><a href="#cb507-8"></a><span class="st">        let wrapper = fn() {</span></span>
<span id="cb507-9"><a href="#cb507-9"></a><span class="st">            let countDown = fn(x) {</span></span>
<span id="cb507-10"><a href="#cb507-10"></a><span class="st">                if (x == 0) {</span></span>
<span id="cb507-11"><a href="#cb507-11"></a><span class="st">                    return 0;</span></span>
<span id="cb507-12"><a href="#cb507-12"></a><span class="st">                } else {</span></span>
<span id="cb507-13"><a href="#cb507-13"></a><span class="st">                    countDown(x - 1);</span></span>
<span id="cb507-14"><a href="#cb507-14"></a><span class="st">                }</span></span>
<span id="cb507-15"><a href="#cb507-15"></a><span class="st">            };</span></span>
<span id="cb507-16"><a href="#cb507-16"></a><span class="st">            countDown(1);</span></span>
<span id="cb507-17"><a href="#cb507-17"></a><span class="st">        };</span></span>
<span id="cb507-18"><a href="#cb507-18"></a><span class="st">        wrapper();</span></span>
<span id="cb507-19"><a href="#cb507-19"></a><span class="st">        `</span>,</span>
<span id="cb507-20"><a href="#cb507-20"></a>            expected: <span class="dv">0</span>,</span>
<span id="cb507-21"><a href="#cb507-21"></a>        },</span>
<span id="cb507-22"><a href="#cb507-22"></a>    }</span>
<span id="cb507-23"><a href="#cb507-23"></a></span>
<span id="cb507-24"><a href="#cb507-24"></a>    runVmTests(t, tests)</span>
<span id="cb507-25"><a href="#cb507-25"></a>}</span></code></pre></div>
<p>The basic pieces from the other two test cases are still there but things moved around a bit. <code>countDown</code> still calls itself and <code>wrapper</code> still calls <code>countDown</code>, but now <code>countDown</code> is also defined inside <code>wrapper</code>. Since, in the end, every function in Monkey is a closure, what we have here is a recursive closure defined in another closure.</p>
<p>We know that both features already work separately. Defining and calling a function inside another function works since the last section and since a few paragraphs ago a function calling itself also works. But combined?</p>
<p>Let’s run the test:</p>
<div class="sourceCode" id="cb508"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb508-1"><a href="#cb508-1"></a>$ go test ./vm -run TestRecursiveFunctions</span>
<span id="cb508-2"><a href="#cb508-2"></a>--- FAIL: TestRecursiveFunctions (0.00s)</span>
<span id="cb508-3"><a href="#cb508-3"></a> vm_test.go:591: vm error: calling non-closure and non-builtin</span>
<span id="cb508-4"><a href="#cb508-4"></a>FAIL</span>
<span id="cb508-5"><a href="#cb508-5"></a>FAIL    monkey/vm   0.007s</span></code></pre></div>
<p>Huh.</p>
<p>No compiler error this time. The test breaks in the VM, at runtime, because apparently the VM tries to call something that’s neither a closure nor a built-in function.</p>
<p>Before we dig into why this test fails, let’s get the “can’t we sweep this under the rug?” question out of the way and make sure that we’re clear on why we want this test to work, because it <em>does</em> look contrived, doesn’t it? Who defines recursive closures in other closures anyway?</p>
<p>As it turns out: we do! The test case is a reduced form of this:</p>
<div class="sourceCode" id="cb509"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb509-1"><a href="#cb509-1"></a><span class="kw">let</span> map <span class="op">=</span> fn(arr<span class="op">,</span> f) {</span>
<span id="cb509-2"><a href="#cb509-2"></a>  <span class="kw">let</span> iter <span class="op">=</span> fn(arr<span class="op">,</span> accumulated) {</span>
<span id="cb509-3"><a href="#cb509-3"></a>    <span class="cf">if</span> (len(arr) <span class="op">==</span> <span class="dv">0</span>) {</span>
<span id="cb509-4"><a href="#cb509-4"></a>      accumulated</span>
<span id="cb509-5"><a href="#cb509-5"></a>    } <span class="cf">else</span> {</span>
<span id="cb509-6"><a href="#cb509-6"></a>      iter(rest(arr)<span class="op">,</span> push(accumulated<span class="op">,</span> f(first(arr))))<span class="op">;</span></span>
<span id="cb509-7"><a href="#cb509-7"></a>    }</span>
<span id="cb509-8"><a href="#cb509-8"></a>  }<span class="op">;</span></span>
<span id="cb509-9"><a href="#cb509-9"></a></span>
<span id="cb509-10"><a href="#cb509-10"></a>  iter(arr<span class="op">,</span> [])<span class="op">;</span></span>
<span id="cb509-11"><a href="#cb509-11"></a>}<span class="op">;</span></span></code></pre></div>
<p>The higher-order <code>map</code> function, written in Monkey, which definitely <em>is</em> something we want. So, let’s get back to our test.</p>
<p>It doesn’t fail because the compiler emitted the wrong bytecode for the <code>main</code> function. Nor does it fail because of the instructions that make up <code>countDown</code>. It fails because of innocent-looking <code>wrapper</code> function.</p>
<p>In order to see what the compiler compiled <code>wrapper</code> to, we can add something like the following to the <code>runVmTests</code> function:</p>
<div class="sourceCode" id="cb510"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb510-1"><a href="#cb510-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb510-2"><a href="#cb510-2"></a></span>
<span id="cb510-3"><a href="#cb510-3"></a><span class="kw">func</span> runVmTests(t *testing.T, tests []vmTestCase) {</span>
<span id="cb510-4"><a href="#cb510-4"></a>    <span class="co">// [...]</span></span>
<span id="cb510-5"><a href="#cb510-5"></a></span>
<span id="cb510-6"><a href="#cb510-6"></a>    <span class="kw">for</span> _, tt := <span class="kw">range</span> tests {</span>
<span id="cb510-7"><a href="#cb510-7"></a>        <span class="co">// [...]</span></span>
<span id="cb510-8"><a href="#cb510-8"></a></span>
<span id="cb510-9"><a href="#cb510-9"></a>        <span class="kw">for</span> i, constant := <span class="kw">range</span> comp.Bytecode().Constants {</span>
<span id="cb510-10"><a href="#cb510-10"></a>            fmt.Printf(<span class="st">&quot;CONSTANT %d %p (%T):</span><span class="ch">\n</span><span class="st">&quot;</span>, i, constant, constant)</span>
<span id="cb510-11"><a href="#cb510-11"></a></span>
<span id="cb510-12"><a href="#cb510-12"></a>            <span class="kw">switch</span> constant := constant.(<span class="kw">type</span>) {</span>
<span id="cb510-13"><a href="#cb510-13"></a>            <span class="kw">case</span> *object.CompiledFunction:</span>
<span id="cb510-14"><a href="#cb510-14"></a>                fmt.Printf(<span class="st">&quot; Instructions:</span><span class="ch">\n</span><span class="st">%s&quot;</span>, constant.Instructions)</span>
<span id="cb510-15"><a href="#cb510-15"></a>            <span class="kw">case</span> *object.Integer:</span>
<span id="cb510-16"><a href="#cb510-16"></a>                fmt.Printf(<span class="st">&quot; Value: %d</span><span class="ch">\n</span><span class="st">&quot;</span>, constant.Value)</span>
<span id="cb510-17"><a href="#cb510-17"></a>            }</span>
<span id="cb510-18"><a href="#cb510-18"></a></span>
<span id="cb510-19"><a href="#cb510-19"></a>            fmt.Printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb510-20"><a href="#cb510-20"></a>        }</span>
<span id="cb510-21"><a href="#cb510-21"></a></span>
<span id="cb510-22"><a href="#cb510-22"></a>        vm := New(comp.Bytecode())</span>
<span id="cb510-23"><a href="#cb510-23"></a>        <span class="co">// [...]</span></span>
<span id="cb510-24"><a href="#cb510-24"></a>    }</span>
<span id="cb510-25"><a href="#cb510-25"></a>}</span></code></pre></div>
<p>That’s a crude “bytecode dumper” and could certainly benefit from some refinement, but it helps to see which instructions make up <code>wrapper</code>:</p>
<div class="sourceCode" id="cb511"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb511-1"><a href="#cb511-1"></a>$ go test ./vm -run TestRecursiveFunctions</span>
<span id="cb511-2"><a href="#cb511-2"></a>// [...]</span>
<span id="cb511-3"><a href="#cb511-3"></a></span>
<span id="cb511-4"><a href="#cb511-4"></a>CONSTANT 5 0xc0000c8660 (*object.CompiledFunction):</span>
<span id="cb511-5"><a href="#cb511-5"></a> Instructions:</span>
<span id="cb511-6"><a href="#cb511-6"></a>0000 OpGetLocal 0</span>
<span id="cb511-7"><a href="#cb511-7"></a>0002 OpClosure 3 1</span>
<span id="cb511-8"><a href="#cb511-8"></a>0006 OpSetLocal 0</span>
<span id="cb511-9"><a href="#cb511-9"></a>0008 OpGetLocal 0</span>
<span id="cb511-10"><a href="#cb511-10"></a>0010 OpConstant 4</span>
<span id="cb511-11"><a href="#cb511-11"></a>0013 OpCall 1</span>
<span id="cb511-12"><a href="#cb511-12"></a>0015 OpReturnValue</span>
<span id="cb511-13"><a href="#cb511-13"></a></span>
<span id="cb511-14"><a href="#cb511-14"></a>--- FAIL: TestRecursiveFunctions (0.00s)</span>
<span id="cb511-15"><a href="#cb511-15"></a> vm_test.go:591: vm error: calling non-closure and non-builtin</span>
<span id="cb511-16"><a href="#cb511-16"></a>FAIL</span>
<span id="cb511-17"><a href="#cb511-17"></a>FAIL    monkey/vm   0.005s</span></code></pre></div>
<p>At first glance nothing seems to be missing and even when looking at it a second or third time, yes, everything that needs to be there <em>is</em> there. The problem lies in the <em>order</em> of the instructions: <code>OpGetLocal 0</code>, the first instruction in <code>wrapper</code>, comes <strong>before</strong> <code>OpSetLocal 0</code>.</p>
<p>Here’s what happened: while compiling the body of <code>countDown</code>, the compiler came across the reference to <code>countDown</code> and asked the symbol table to resolve it. The symbol table noticed that no symbol with the name <code>countDown</code> has been defined in the current scope and marked it as a free variable.</p>
<p>Then, after compiling the body of <code>countDown</code> and right before emitting the <code>OpClosure</code> instruction to turn <code>countDown</code> into a closure, the compiler iterates the symbols that were marked as free and emits the necessary load instructions to get them on to the stack.</p>
<p>That’s where they’re supposed to end up, so that the VM, when executing the <code>OpClosure</code> instruction that comes after these load instructions, can access them and transfer them on to the <code>*object.Closure</code> it creates.</p>
<p>Exactly as designed and implemented in this chapter, yes.</p>
<p>What breaks the VM is the fact that the local with index <code>0</code> has not been saved yet. When it attempts to load it, it ends up with a Go <code>nil</code> on the stack instead. That’s what’s causing the <code>vm error: calling non-closure and non-builtin</code> message: the VM tells us that it can’t call a <code>nil</code>.</p>
<p>But why wasn’t the local saved yet? Because the slot with index <code>0</code> is where the <em>closure itself is supposed to end up</em>.</p>
<p>Or, in other words: in order to load the single free variable that <code>countDown</code> references — itself! — on to the stack, we emit the correct <code>OpGetLocal 0</code> instruction, but we do it before <code>countDown</code> has been turned into a closure and saved with <code>OpSetLocal 0</code>. In short: we try to create a reference to <code>countDown</code> and save it on <code>countDown</code> itself before <code>countDown</code> exists.</p>
<p>Now, read through the last few paragraphs again until you’re confident you’ve grasped the issue. But make sure to stop before your vision gets blurry and you find yourself repeatedly whispering “wait, what?”. Then read on and concentrate on the next sentence for 30 seconds and slowly breathe in and out:</p>
<p>The fix is straightforward.</p>
<p>Here’s what we’re going to do: we’re going to detect these self-references in the compiler and instead of marking the symbols as “free” and emitting <code>OpGetFree</code> instructions to load them, we instead emit a new opcode.</p>
<p>It’s called <code>OpCurrentClosure</code> and instructs the VM to load the closure it’s currently executing on to the stack. In the VM we’ll then implement <code>OpCurrentClosure</code> to do just that and, boom, mic drop, applause, music, we’re done, that’s it – problem solved.</p>
<p>The first thing we have to do is define the new opcode:</p>
<div class="sourceCode" id="cb512"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb512-1"><a href="#cb512-1"></a><span class="co">// code/code.go</span></span>
<span id="cb512-2"><a href="#cb512-2"></a></span>
<span id="cb512-3"><a href="#cb512-3"></a><span class="kw">const</span> (</span>
<span id="cb512-4"><a href="#cb512-4"></a>    <span class="co">// [...]</span></span>
<span id="cb512-5"><a href="#cb512-5"></a></span>
<span id="cb512-6"><a href="#cb512-6"></a>    OpCurrentClosure</span>
<span id="cb512-7"><a href="#cb512-7"></a>)</span>
<span id="cb512-8"><a href="#cb512-8"></a></span>
<span id="cb512-9"><a href="#cb512-9"></a><span class="kw">var</span> definitions = <span class="kw">map</span>[Opcode]*Definition{</span>
<span id="cb512-10"><a href="#cb512-10"></a>    <span class="co">// [...]</span></span>
<span id="cb512-11"><a href="#cb512-11"></a></span>
<span id="cb512-12"><a href="#cb512-12"></a>    OpCurrentClosure: {<span class="st">&quot;OpCurrentClosure&quot;</span>, []<span class="dt">int</span>{}},</span>
<span id="cb512-13"><a href="#cb512-13"></a>}</span></code></pre></div>
<p>With that, we’re ready to write compiler tests to assert that <code>OpCurrentClosure</code> does get emitted at the right places.</p>
<p>The first of these tests makes sure that a recursive function that’s <em>not</em> defined inside another function makes use of <code>OpCurrentClosure</code> to reference itself:</p>
<div class="sourceCode" id="cb513"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb513-1"><a href="#cb513-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb513-2"><a href="#cb513-2"></a></span>
<span id="cb513-3"><a href="#cb513-3"></a><span class="kw">func</span> TestRecursiveFunctions(t *testing.T) {</span>
<span id="cb513-4"><a href="#cb513-4"></a>    tests := []compilerTestCase{</span>
<span id="cb513-5"><a href="#cb513-5"></a>        {</span>
<span id="cb513-6"><a href="#cb513-6"></a>            input: <span class="st">`</span></span>
<span id="cb513-7"><a href="#cb513-7"></a><span class="st">            let countDown = fn(x) { countDown(x - 1); };</span></span>
<span id="cb513-8"><a href="#cb513-8"></a><span class="st">            countDown(1);</span></span>
<span id="cb513-9"><a href="#cb513-9"></a><span class="st">            `</span>,</span>
<span id="cb513-10"><a href="#cb513-10"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb513-11"><a href="#cb513-11"></a>                <span class="dv">1</span>,</span>
<span id="cb513-12"><a href="#cb513-12"></a>                []code.Instructions{</span>
<span id="cb513-13"><a href="#cb513-13"></a>                    code.Make(code.OpCurrentClosure),</span>
<span id="cb513-14"><a href="#cb513-14"></a>                    code.Make(code.OpGetLocal, <span class="dv">0</span>),</span>
<span id="cb513-15"><a href="#cb513-15"></a>                    code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb513-16"><a href="#cb513-16"></a>                    code.Make(code.OpSub),</span>
<span id="cb513-17"><a href="#cb513-17"></a>                    code.Make(code.OpCall, <span class="dv">1</span>),</span>
<span id="cb513-18"><a href="#cb513-18"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb513-19"><a href="#cb513-19"></a>                },</span>
<span id="cb513-20"><a href="#cb513-20"></a>                <span class="dv">1</span>,</span>
<span id="cb513-21"><a href="#cb513-21"></a>            },</span>
<span id="cb513-22"><a href="#cb513-22"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb513-23"><a href="#cb513-23"></a>                code.Make(code.OpClosure, <span class="dv">1</span>, <span class="dv">0</span>),</span>
<span id="cb513-24"><a href="#cb513-24"></a>                code.Make(code.OpSetGlobal, <span class="dv">0</span>),</span>
<span id="cb513-25"><a href="#cb513-25"></a>                code.Make(code.OpGetGlobal, <span class="dv">0</span>),</span>
<span id="cb513-26"><a href="#cb513-26"></a>                code.Make(code.OpConstant, <span class="dv">2</span>),</span>
<span id="cb513-27"><a href="#cb513-27"></a>                code.Make(code.OpCall, <span class="dv">1</span>),</span>
<span id="cb513-28"><a href="#cb513-28"></a>                code.Make(code.OpPop),</span>
<span id="cb513-29"><a href="#cb513-29"></a>            },</span>
<span id="cb513-30"><a href="#cb513-30"></a>        },</span>
<span id="cb513-31"><a href="#cb513-31"></a>    }</span>
<span id="cb513-32"><a href="#cb513-32"></a></span>
<span id="cb513-33"><a href="#cb513-33"></a>    runCompilerTests(t, tests)</span>
<span id="cb513-34"><a href="#cb513-34"></a>}</span></code></pre></div>
<p>Just like every call expression, the <code>countDown(x - 1)</code> we have here should be compiled to instructions that follow our calling convention: first load the callee on to the stack, then the arguments of the call, and then the <code>OpCall</code> instruction.</p>
<p>What’s special here, besides the fact that <code>countDown</code> so simplified that it never stops, is that the callee is <code>countDown</code> itself, which is why we expect an <code>OpCurrentClosure</code> to put the callee on the stack.</p>
<p>We’ll also add another test case for the thing that brought us here: a recursive function defined in another function.</p>
<div class="sourceCode" id="cb514"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb514-1"><a href="#cb514-1"></a><span class="co">// compiler/compiler_test.go</span></span>
<span id="cb514-2"><a href="#cb514-2"></a></span>
<span id="cb514-3"><a href="#cb514-3"></a><span class="kw">func</span> TestRecursiveFunctions(t *testing.T) {</span>
<span id="cb514-4"><a href="#cb514-4"></a>    tests := []compilerTestCase{</span>
<span id="cb514-5"><a href="#cb514-5"></a>        <span class="co">// [...]</span></span>
<span id="cb514-6"><a href="#cb514-6"></a>        {</span>
<span id="cb514-7"><a href="#cb514-7"></a>            input: <span class="st">`</span></span>
<span id="cb514-8"><a href="#cb514-8"></a><span class="st">            let wrapper = fn() {</span></span>
<span id="cb514-9"><a href="#cb514-9"></a><span class="st">                let countDown = fn(x) { countDown(x - 1); };</span></span>
<span id="cb514-10"><a href="#cb514-10"></a><span class="st">                countDown(1);</span></span>
<span id="cb514-11"><a href="#cb514-11"></a><span class="st">            };</span></span>
<span id="cb514-12"><a href="#cb514-12"></a><span class="st">            wrapper();</span></span>
<span id="cb514-13"><a href="#cb514-13"></a><span class="st">            `</span>,</span>
<span id="cb514-14"><a href="#cb514-14"></a>            expectedConstants: []<span class="kw">interface</span>{}{</span>
<span id="cb514-15"><a href="#cb514-15"></a>                <span class="dv">1</span>,</span>
<span id="cb514-16"><a href="#cb514-16"></a>                []code.Instructions{</span>
<span id="cb514-17"><a href="#cb514-17"></a>                    code.Make(code.OpCurrentClosure),</span>
<span id="cb514-18"><a href="#cb514-18"></a>                    code.Make(code.OpGetLocal, <span class="dv">0</span>),</span>
<span id="cb514-19"><a href="#cb514-19"></a>                    code.Make(code.OpConstant, <span class="dv">0</span>),</span>
<span id="cb514-20"><a href="#cb514-20"></a>                    code.Make(code.OpSub),</span>
<span id="cb514-21"><a href="#cb514-21"></a>                    code.Make(code.OpCall, <span class="dv">1</span>),</span>
<span id="cb514-22"><a href="#cb514-22"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb514-23"><a href="#cb514-23"></a>                },</span>
<span id="cb514-24"><a href="#cb514-24"></a>                <span class="dv">1</span>,</span>
<span id="cb514-25"><a href="#cb514-25"></a>                []code.Instructions{</span>
<span id="cb514-26"><a href="#cb514-26"></a>                    code.Make(code.OpClosure, <span class="dv">1</span>, <span class="dv">0</span>),</span>
<span id="cb514-27"><a href="#cb514-27"></a>                    code.Make(code.OpSetLocal, <span class="dv">0</span>),</span>
<span id="cb514-28"><a href="#cb514-28"></a>                    code.Make(code.OpGetLocal, <span class="dv">0</span>),</span>
<span id="cb514-29"><a href="#cb514-29"></a>                    code.Make(code.OpConstant, <span class="dv">2</span>),</span>
<span id="cb514-30"><a href="#cb514-30"></a>                    code.Make(code.OpCall, <span class="dv">1</span>),</span>
<span id="cb514-31"><a href="#cb514-31"></a>                    code.Make(code.OpReturnValue),</span>
<span id="cb514-32"><a href="#cb514-32"></a>                },</span>
<span id="cb514-33"><a href="#cb514-33"></a>            },</span>
<span id="cb514-34"><a href="#cb514-34"></a>            expectedInstructions: []code.Instructions{</span>
<span id="cb514-35"><a href="#cb514-35"></a>                code.Make(code.OpClosure, <span class="dv">3</span>, <span class="dv">0</span>),</span>
<span id="cb514-36"><a href="#cb514-36"></a>                code.Make(code.OpSetGlobal, <span class="dv">0</span>),</span>
<span id="cb514-37"><a href="#cb514-37"></a>                code.Make(code.OpGetGlobal, <span class="dv">0</span>),</span>
<span id="cb514-38"><a href="#cb514-38"></a>                code.Make(code.OpCall, <span class="dv">0</span>),</span>
<span id="cb514-39"><a href="#cb514-39"></a>                code.Make(code.OpPop),</span>
<span id="cb514-40"><a href="#cb514-40"></a>            },</span>
<span id="cb514-41"><a href="#cb514-41"></a>        },</span>
<span id="cb514-42"><a href="#cb514-42"></a>    }</span>
<span id="cb514-43"><a href="#cb514-43"></a></span>
<span id="cb514-44"><a href="#cb514-44"></a>    runCompilerTests(t, tests)</span>
<span id="cb514-45"><a href="#cb514-45"></a>}</span></code></pre></div>
<p>If we run these tests, they confirm two things: our analysis of the problem was correct and, yes, we didn’t do anything yet.</p>
<div class="sourceCode" id="cb515"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb515-1"><a href="#cb515-1"></a>$ go test ./compiler</span>
<span id="cb515-2"><a href="#cb515-2"></a>--- FAIL: TestRecursiveFunctions (0.00s)</span>
<span id="cb515-3"><a href="#cb515-3"></a> compiler_test.go:996: testConstants failed:\</span>
<span id="cb515-4"><a href="#cb515-4"></a>   constant 1 - testInstructions failed: wrong instructions length.</span>
<span id="cb515-5"><a href="#cb515-5"></a>  want=&quot;0000 OpCurrentClosure\n0001 OpGetLocal 0\n0003 OpConstant 0\n\</span>
<span id="cb515-6"><a href="#cb515-6"></a>    0006 OpSub\n0007 OpCall 1\n0009 OpReturnValue\n&quot;</span>
<span id="cb515-7"><a href="#cb515-7"></a>  got =&quot;0000 OpGetGlobal 0\n0003 OpGetLocal 0\n0005 OpConstant 0\n\</span>
<span id="cb515-8"><a href="#cb515-8"></a>    0008 OpSub\n0009 OpCall 1\n0011 OpReturnValue\n&quot;</span>
<span id="cb515-9"><a href="#cb515-9"></a>FAIL</span>
<span id="cb515-10"><a href="#cb515-10"></a>FAIL    monkey/compiler 0.006s</span></code></pre></div>
<p>Beautiful! Now, let’s do something.</p>
<p>In order to make the tests pass by detecting self-references in the compiler, we need one crucial piece of information: the name of the function we’re currently compiling. As things stand, we have no way of knowing whether a reference is a self-reference, since we never capture which name a function is bound to.</p>
<p>But we <em>can</em>: in the parser we can tell whether a let-statement binds a function literal to a name and if so, we can save the name of the binding on to the function literal.</p>
<p>What we have to do as the first step is to add a <code>Name</code> field to our <code>ast.FunctionLiteral</code> definition:</p>
<div class="sourceCode" id="cb516"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb516-1"><a href="#cb516-1"></a><span class="co">// ast/ast.go</span></span>
<span id="cb516-2"><a href="#cb516-2"></a></span>
<span id="cb516-3"><a href="#cb516-3"></a><span class="kw">type</span> FunctionLiteral <span class="kw">struct</span> {</span>
<span id="cb516-4"><a href="#cb516-4"></a>    <span class="co">// [...]</span></span>
<span id="cb516-5"><a href="#cb516-5"></a>    Name       <span class="dt">string</span></span>
<span id="cb516-6"><a href="#cb516-6"></a>}</span>
<span id="cb516-7"><a href="#cb516-7"></a></span>
<span id="cb516-8"><a href="#cb516-8"></a><span class="kw">func</span> (fl *FunctionLiteral) String() <span class="dt">string</span> {</span>
<span id="cb516-9"><a href="#cb516-9"></a>    <span class="co">// [...]</span></span>
<span id="cb516-10"><a href="#cb516-10"></a>    out.WriteString(fl.TokenLiteral())</span>
<span id="cb516-11"><a href="#cb516-11"></a>    <span class="kw">if</span> fl.Name != <span class="st">&quot;&quot;</span> {</span>
<span id="cb516-12"><a href="#cb516-12"></a>        out.WriteString(fmt.Sprintf(<span class="st">&quot;&lt;%s&gt;&quot;</span>, fl.Name))</span>
<span id="cb516-13"><a href="#cb516-13"></a>    }</span>
<span id="cb516-14"><a href="#cb516-14"></a>    out.WriteString(<span class="st">&quot;(&quot;</span>)</span>
<span id="cb516-15"><a href="#cb516-15"></a>    <span class="co">// [...]</span></span>
<span id="cb516-16"><a href="#cb516-16"></a>}</span></code></pre></div>
<p>Now we can write a test for the parser that makes sure the <code>Name</code> field is filled out when possible:</p>
<div class="sourceCode" id="cb517"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb517-1"><a href="#cb517-1"></a><span class="co">// parser/parser_test.go</span></span>
<span id="cb517-2"><a href="#cb517-2"></a></span>
<span id="cb517-3"><a href="#cb517-3"></a><span class="kw">func</span> TestFunctionLiteralWithName(t *testing.T) {</span>
<span id="cb517-4"><a href="#cb517-4"></a>    input := <span class="st">`let myFunction = fn() { };`</span></span>
<span id="cb517-5"><a href="#cb517-5"></a></span>
<span id="cb517-6"><a href="#cb517-6"></a>    l := lexer.New(input)</span>
<span id="cb517-7"><a href="#cb517-7"></a>    p := New(l)</span>
<span id="cb517-8"><a href="#cb517-8"></a>    program := p.ParseProgram()</span>
<span id="cb517-9"><a href="#cb517-9"></a>    checkParserErrors(t, p)</span>
<span id="cb517-10"><a href="#cb517-10"></a></span>
<span id="cb517-11"><a href="#cb517-11"></a>    <span class="kw">if</span> <span class="bu">len</span>(program.Statements) != <span class="dv">1</span> {</span>
<span id="cb517-12"><a href="#cb517-12"></a>        t.Fatalf(<span class="st">&quot;program.Body does not contain %d statements. got=%d</span><span class="ch">\n</span><span class="st">&quot;</span>,</span>
<span id="cb517-13"><a href="#cb517-13"></a>            <span class="dv">1</span>, <span class="bu">len</span>(program.Statements))</span>
<span id="cb517-14"><a href="#cb517-14"></a>    }</span>
<span id="cb517-15"><a href="#cb517-15"></a></span>
<span id="cb517-16"><a href="#cb517-16"></a>    stmt, ok := program.Statements[<span class="dv">0</span>].(*ast.LetStatement)</span>
<span id="cb517-17"><a href="#cb517-17"></a>    <span class="kw">if</span> !ok {</span>
<span id="cb517-18"><a href="#cb517-18"></a>        t.Fatalf(<span class="st">&quot;program.Statements[0] is not ast.LetStatement. got=%T&quot;</span>,</span>
<span id="cb517-19"><a href="#cb517-19"></a>            program.Statements[<span class="dv">0</span>])</span>
<span id="cb517-20"><a href="#cb517-20"></a>    }</span>
<span id="cb517-21"><a href="#cb517-21"></a></span>
<span id="cb517-22"><a href="#cb517-22"></a>    function, ok := stmt.Value.(*ast.FunctionLiteral)</span>
<span id="cb517-23"><a href="#cb517-23"></a>    <span class="kw">if</span> !ok {</span>
<span id="cb517-24"><a href="#cb517-24"></a>        t.Fatalf(<span class="st">&quot;stmt.Value is not ast.FunctionLiteral. got=%T&quot;</span>,</span>
<span id="cb517-25"><a href="#cb517-25"></a>            stmt.Value)</span>
<span id="cb517-26"><a href="#cb517-26"></a>    }</span>
<span id="cb517-27"><a href="#cb517-27"></a></span>
<span id="cb517-28"><a href="#cb517-28"></a>    <span class="kw">if</span> function.Name != <span class="st">&quot;myFunction&quot;</span> {</span>
<span id="cb517-29"><a href="#cb517-29"></a>        t.Fatalf(<span class="st">&quot;function literal name wrong. want &#39;myFunction&#39;, got=%q</span><span class="ch">\n</span><span class="st">&quot;</span>,</span>
<span id="cb517-30"><a href="#cb517-30"></a>            function.Name)</span>
<span id="cb517-31"><a href="#cb517-31"></a>    }</span>
<span id="cb517-32"><a href="#cb517-32"></a>}</span></code></pre></div>
<p>Let’s make sure that we didn’t make a mistake and it fails as it should:</p>
<div class="sourceCode" id="cb518"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb518-1"><a href="#cb518-1"></a>$ go test ./parser</span>
<span id="cb518-2"><a href="#cb518-2"></a>--- FAIL: TestFunctionLiteralWithName (0.00s)</span>
<span id="cb518-3"><a href="#cb518-3"></a> parser_test.go:965: function literal name wrong. want &#39;myFunction&#39;, got=&quot;&quot;</span>
<span id="cb518-4"><a href="#cb518-4"></a>FAIL</span>
<span id="cb518-5"><a href="#cb518-5"></a>FAIL    monkey/parser   0.005s</span></code></pre></div>
<p>In order to fix it, we need to change the <code>parseLetStatement</code> method in the parser:</p>
<div class="sourceCode" id="cb519"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb519-1"><a href="#cb519-1"></a><span class="co">// parser/parser.go</span></span>
<span id="cb519-2"><a href="#cb519-2"></a></span>
<span id="cb519-3"><a href="#cb519-3"></a><span class="kw">func</span> (p *Parser) parseLetStatement() *ast.LetStatement {</span>
<span id="cb519-4"><a href="#cb519-4"></a>    <span class="co">// [...]</span></span>
<span id="cb519-5"><a href="#cb519-5"></a></span>
<span id="cb519-6"><a href="#cb519-6"></a>    stmt.Value = p.parseExpression(LOWEST)</span>
<span id="cb519-7"><a href="#cb519-7"></a></span>
<span id="cb519-8"><a href="#cb519-8"></a>    <span class="kw">if</span> fl, ok := stmt.Value.(*ast.FunctionLiteral); ok {</span>
<span id="cb519-9"><a href="#cb519-9"></a>        fl.Name = stmt.Name.Value</span>
<span id="cb519-10"><a href="#cb519-10"></a>    }</span>
<span id="cb519-11"><a href="#cb519-11"></a></span>
<span id="cb519-12"><a href="#cb519-12"></a>    <span class="co">// [...]</span></span>
<span id="cb519-13"><a href="#cb519-13"></a>}</span></code></pre></div>
<p>After both sides of the <code>=</code> in a let statement have been parsed, we check whether the right side, <code>stmt.Value</code>, is a <code>*ast.FunctionLiteral</code>. If it is, we save the name of binding, <code>stmt.Name</code>, on to it. Yes, that’s it:</p>
<div class="sourceCode" id="cb520"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb520-1"><a href="#cb520-1"></a>$ go test ./parser</span>
<span id="cb520-2"><a href="#cb520-2"></a>ok      monkey/parser   0.005s</span></code></pre></div>
<p>Now we have everything in place to detect self-references! But instead of rushing into it and ending up with ugly checks for edge cases in our compiler, we go to the place that manages names and references for us: the symbol table.</p>
<p>What we’ll do in the symbol table is to add a new scope, called <code>FunctionScope</code>. We’ll only define one symbol with that scope per symbol table: the name of the function we’re currently compiling. When we then resolve a name and get back a symbol with <code>FunctionScope</code> we know that it’s the name of the current function, ergo a self-reference.</p>
<p>Let’s start by defining the new scope:</p>
<div class="sourceCode" id="cb521"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb521-1"><a href="#cb521-1"></a><span class="co">// compiler/symbol_table.go</span></span>
<span id="cb521-2"><a href="#cb521-2"></a></span>
<span id="cb521-3"><a href="#cb521-3"></a><span class="kw">const</span> (</span>
<span id="cb521-4"><a href="#cb521-4"></a>    <span class="co">// [...]</span></span>
<span id="cb521-5"><a href="#cb521-5"></a>    FunctionScope SymbolScope = <span class="st">&quot;FUNCTION&quot;</span></span>
<span id="cb521-6"><a href="#cb521-6"></a>)</span></code></pre></div>
<p>With that, we’re ready to add a test:</p>
<div class="sourceCode" id="cb522"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb522-1"><a href="#cb522-1"></a><span class="co">// compiler/symbol_table_test.go</span></span>
<span id="cb522-2"><a href="#cb522-2"></a></span>
<span id="cb522-3"><a href="#cb522-3"></a><span class="kw">func</span> TestDefineAndResolveFunctionName(t *testing.T) {</span>
<span id="cb522-4"><a href="#cb522-4"></a>    global := NewSymbolTable()</span>
<span id="cb522-5"><a href="#cb522-5"></a>    global.DefineFunctionName(<span class="st">&quot;a&quot;</span>)</span>
<span id="cb522-6"><a href="#cb522-6"></a></span>
<span id="cb522-7"><a href="#cb522-7"></a>    expected := Symbol{Name: <span class="st">&quot;a&quot;</span>, Scope: FunctionScope, Index: <span class="dv">0</span>}</span>
<span id="cb522-8"><a href="#cb522-8"></a></span>
<span id="cb522-9"><a href="#cb522-9"></a>    result, ok := global.Resolve(expected.Name)</span>
<span id="cb522-10"><a href="#cb522-10"></a>    <span class="kw">if</span> !ok {</span>
<span id="cb522-11"><a href="#cb522-11"></a>        t.Fatalf(<span class="st">&quot;function name %s not resolvable&quot;</span>, expected.Name)</span>
<span id="cb522-12"><a href="#cb522-12"></a>    }</span>
<span id="cb522-13"><a href="#cb522-13"></a></span>
<span id="cb522-14"><a href="#cb522-14"></a>    <span class="kw">if</span> result != expected {</span>
<span id="cb522-15"><a href="#cb522-15"></a>        t.Errorf(<span class="st">&quot;expected %s to resolve to %+v, got=%+v&quot;</span>,</span>
<span id="cb522-16"><a href="#cb522-16"></a>            expected.Name, expected, result)</span>
<span id="cb522-17"><a href="#cb522-17"></a>    }</span>
<span id="cb522-18"><a href="#cb522-18"></a>}</span></code></pre></div>
<p>In this test we call <code>DefineFunctionName</code>, which we’ll have to write next, and then call <code>Resolve</code> with the function’s name in the hope that we’ll get back a <code>Symbol</code> with <code>Scope</code> set to <code>FunctionScope</code>.</p>
<p>In addition to that we also want to make sure that shadowing the current function’s name still works, like this:</p>
<div class="sourceCode" id="cb523"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb523-1"><a href="#cb523-1"></a><span class="kw">let</span> foobar <span class="op">=</span> fn() {</span>
<span id="cb523-2"><a href="#cb523-2"></a>  <span class="kw">let</span> foobar <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb523-3"><a href="#cb523-3"></a>  foobar<span class="op">;</span></span>
<span id="cb523-4"><a href="#cb523-4"></a>}<span class="op">;</span></span></code></pre></div>
<p>To ensure that we add a second test that’s similar to our first one, except that it contains an additional call to <code>Define</code> after the call to <code>DefineFunctionName</code>:</p>
<div class="sourceCode" id="cb524"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb524-1"><a href="#cb524-1"></a><span class="co">// compiler/symbol_table_test.go</span></span>
<span id="cb524-2"><a href="#cb524-2"></a></span>
<span id="cb524-3"><a href="#cb524-3"></a><span class="kw">func</span> TestShadowingFunctionName(t *testing.T) {</span>
<span id="cb524-4"><a href="#cb524-4"></a>    global := NewSymbolTable()</span>
<span id="cb524-5"><a href="#cb524-5"></a>    global.DefineFunctionName(<span class="st">&quot;a&quot;</span>)</span>
<span id="cb524-6"><a href="#cb524-6"></a>    global.Define(<span class="st">&quot;a&quot;</span>)</span>
<span id="cb524-7"><a href="#cb524-7"></a></span>
<span id="cb524-8"><a href="#cb524-8"></a>    expected := Symbol{Name: <span class="st">&quot;a&quot;</span>, Scope: GlobalScope, Index: <span class="dv">0</span>}</span>
<span id="cb524-9"><a href="#cb524-9"></a></span>
<span id="cb524-10"><a href="#cb524-10"></a>    result, ok := global.Resolve(expected.Name)</span>
<span id="cb524-11"><a href="#cb524-11"></a>    <span class="kw">if</span> !ok {</span>
<span id="cb524-12"><a href="#cb524-12"></a>        t.Fatalf(<span class="st">&quot;function name %s not resolvable&quot;</span>, expected.Name)</span>
<span id="cb524-13"><a href="#cb524-13"></a>    }</span>
<span id="cb524-14"><a href="#cb524-14"></a></span>
<span id="cb524-15"><a href="#cb524-15"></a>    <span class="kw">if</span> result != expected {</span>
<span id="cb524-16"><a href="#cb524-16"></a>        t.Errorf(<span class="st">&quot;expected %s to resolve to %+v, got=%+v&quot;</span>,</span>
<span id="cb524-17"><a href="#cb524-17"></a>            expected.Name, expected, result)</span>
<span id="cb524-18"><a href="#cb524-18"></a>    }</span>
<span id="cb524-19"><a href="#cb524-19"></a>}</span></code></pre></div>
<p>Alright, let’s run them:</p>
<div class="sourceCode" id="cb525"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb525-1"><a href="#cb525-1"></a>$ go test -run FunctionName ./compiler</span>
<span id="cb525-2"><a href="#cb525-2"></a># monkey/compiler [monkey/compiler.test]</span>
<span id="cb525-3"><a href="#cb525-3"></a>compiler/symbol_table_test.go:306:8: global.DefineFunctionName undefined \</span>
<span id="cb525-4"><a href="#cb525-4"></a>  (type *SymbolTable has no field or method DefineFunctionName)</span>
<span id="cb525-5"><a href="#cb525-5"></a>compiler/symbol_table_test.go:323:8: global.DefineFunctionName undefined \</span>
<span id="cb525-6"><a href="#cb525-6"></a>  (type *SymbolTable has no field or method DefineFunctionName)</span>
<span id="cb525-7"><a href="#cb525-7"></a>FAIL    monkey/compiler [build failed]</span></code></pre></div>
<p>Hard to misinterpret. Let’s implement <code>DefineFunctionName</code>, which is easy enough, since it’s really similar to the <code>DefineBuiltin</code> method we already have:</p>
<div class="sourceCode" id="cb526"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb526-1"><a href="#cb526-1"></a><span class="co">// compiler/symbol_table.go</span></span>
<span id="cb526-2"><a href="#cb526-2"></a></span>
<span id="cb526-3"><a href="#cb526-3"></a><span class="kw">func</span> (s *SymbolTable) DefineFunctionName(name <span class="dt">string</span>) Symbol {</span>
<span id="cb526-4"><a href="#cb526-4"></a>    symbol := Symbol{Name: name, Index: <span class="dv">0</span>, Scope: FunctionScope}</span>
<span id="cb526-5"><a href="#cb526-5"></a>    s.store[name] = symbol</span>
<span id="cb526-6"><a href="#cb526-6"></a>    <span class="kw">return</span> symbol</span>
<span id="cb526-7"><a href="#cb526-7"></a>}</span></code></pre></div>
<p>We create a new <code>Symbol</code> with <code>FunctionScope</code> and add it to the <code>s.store</code>. The <code>Index</code> is an arbitrary choice, since it doesn’t matter. Feel free to set it to your favorite number. And then, run the tests again:</p>
<div class="sourceCode" id="cb527"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb527-1"><a href="#cb527-1"></a>$ go test -run FunctionName ./compiler</span>
<span id="cb527-2"><a href="#cb527-2"></a>ok      monkey/compiler 0.005s</span></code></pre></div>
<p>Now we can move on to the compiler where, as it turns out, we don’t have to do very much to make the failing tests pass.</p>
<p>When compiling a <code>*ast.FunctionLiteral</code> that has a <code>.Name</code>, right after we entered the new compilation scope, we need to add the function’s name to the symbol table by making use of the new <code>DefineFunctionName</code> method:</p>
<div class="sourceCode" id="cb528"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb528-1"><a href="#cb528-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb528-2"><a href="#cb528-2"></a></span>
<span id="cb528-3"><a href="#cb528-3"></a><span class="kw">func</span> (c *Compiler) Compile(node ast.Node) <span class="dt">error</span> {</span>
<span id="cb528-4"><a href="#cb528-4"></a>    <span class="kw">switch</span> node := node.(<span class="kw">type</span>) {</span>
<span id="cb528-5"><a href="#cb528-5"></a>    <span class="co">// [...]</span></span>
<span id="cb528-6"><a href="#cb528-6"></a></span>
<span id="cb528-7"><a href="#cb528-7"></a>    <span class="kw">case</span> *ast.FunctionLiteral:</span>
<span id="cb528-8"><a href="#cb528-8"></a>        c.enterScope()</span>
<span id="cb528-9"><a href="#cb528-9"></a></span>
<span id="cb528-10"><a href="#cb528-10"></a>        <span class="kw">if</span> node.Name != <span class="st">&quot;&quot;</span> {</span>
<span id="cb528-11"><a href="#cb528-11"></a>            c.symbolTable.DefineFunctionName(node.Name)</span>
<span id="cb528-12"><a href="#cb528-12"></a>        }</span>
<span id="cb528-13"><a href="#cb528-13"></a>        <span class="co">// [...]</span></span>
<span id="cb528-14"><a href="#cb528-14"></a></span>
<span id="cb528-15"><a href="#cb528-15"></a>    <span class="co">// [...]</span></span>
<span id="cb528-16"><a href="#cb528-16"></a>    }</span>
<span id="cb528-17"><a href="#cb528-17"></a></span>
<span id="cb528-18"><a href="#cb528-18"></a>    <span class="co">// [...]</span></span>
<span id="cb528-19"><a href="#cb528-19"></a>}</span></code></pre></div>
<p>Then we need to make sure that loading a <code>FunctionScope</code> symbol results in an <code>OpCurrentClosure</code> opcode being emitted. And that’s easy to do with the code we already have:</p>
<div class="sourceCode" id="cb529"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb529-1"><a href="#cb529-1"></a><span class="co">// compiler/compiler.go</span></span>
<span id="cb529-2"><a href="#cb529-2"></a></span>
<span id="cb529-3"><a href="#cb529-3"></a><span class="kw">func</span> (c *Compiler) loadSymbol(s Symbol) {</span>
<span id="cb529-4"><a href="#cb529-4"></a>    <span class="kw">switch</span> s.Scope {</span>
<span id="cb529-5"><a href="#cb529-5"></a>    <span class="co">// [...]</span></span>
<span id="cb529-6"><a href="#cb529-6"></a>    <span class="kw">case</span> FunctionScope:</span>
<span id="cb529-7"><a href="#cb529-7"></a>        c.emit(code.OpCurrentClosure)</span>
<span id="cb529-8"><a href="#cb529-8"></a>    }</span>
<span id="cb529-9"><a href="#cb529-9"></a>}</span></code></pre></div>
<p>In total, we’ve now added five new lines to the compiler – enough to fix the tests:</p>
<div class="sourceCode" id="cb530"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb530-1"><a href="#cb530-1"></a>$ go test ./compiler</span>
<span id="cb530-2"><a href="#cb530-2"></a>ok      monkey/compiler 0.006s</span></code></pre></div>
<p>Great! You know what that means, right? We can now finally take care of the failing VM tests we started with:</p>
<div class="sourceCode" id="cb531"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb531-1"><a href="#cb531-1"></a>$ go test ./vm -run TestRecursiveFunctions</span>
<span id="cb531-2"><a href="#cb531-2"></a>--- FAIL: TestRecursiveFunctions (0.00s)</span>
<span id="cb531-3"><a href="#cb531-3"></a> vm_test.go:591: vm error: calling non-closure and non-builtin</span>
<span id="cb531-4"><a href="#cb531-4"></a>FAIL</span>
<span id="cb531-5"><a href="#cb531-5"></a>FAIL    monkey/vm   0.005s</span></code></pre></div>
<p>And the best part? We already did most of the work — in the parser, in the symbol table and in the compiler. All that’s left to do is to implement <code>OpCurrentClosure</code> in the VM:</p>
<div class="sourceCode" id="cb532"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb532-1"><a href="#cb532-1"></a><span class="co">// vm/vm.go</span></span>
<span id="cb532-2"><a href="#cb532-2"></a></span>
<span id="cb532-3"><a href="#cb532-3"></a><span class="kw">func</span> (vm *VM) Run() <span class="dt">error</span> {</span>
<span id="cb532-4"><a href="#cb532-4"></a>    <span class="co">// [...]</span></span>
<span id="cb532-5"><a href="#cb532-5"></a>        <span class="kw">switch</span> op {</span>
<span id="cb532-6"><a href="#cb532-6"></a>        <span class="co">// [...]</span></span>
<span id="cb532-7"><a href="#cb532-7"></a></span>
<span id="cb532-8"><a href="#cb532-8"></a>        <span class="kw">case</span> code.OpCurrentClosure:</span>
<span id="cb532-9"><a href="#cb532-9"></a>            currentClosure := vm.currentFrame().cl</span>
<span id="cb532-10"><a href="#cb532-10"></a>            err := vm.push(currentClosure)</span>
<span id="cb532-11"><a href="#cb532-11"></a>            <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb532-12"><a href="#cb532-12"></a>                <span class="kw">return</span> err</span>
<span id="cb532-13"><a href="#cb532-13"></a>            }</span>
<span id="cb532-14"><a href="#cb532-14"></a></span>
<span id="cb532-15"><a href="#cb532-15"></a>        <span class="co">// [...]</span></span>
<span id="cb532-16"><a href="#cb532-16"></a>        }</span>
<span id="cb532-17"><a href="#cb532-17"></a>    <span class="co">// [...]</span></span>
<span id="cb532-18"><a href="#cb532-18"></a>}</span></code></pre></div>
<p>We take the closure of the <code>vm.currentFrame()</code> and push it on to the stack. That’s it:</p>
<div class="sourceCode" id="cb533"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb533-1"><a href="#cb533-1"></a>$ go test ./vm</span>
<span id="cb533-2"><a href="#cb533-2"></a>ok      monkey/vm   0.033s</span></code></pre></div>
<p>We’re done! We’ve added the last missing piece and with great confidence we can now say: we’ve successfully implemented closures in a bytecode compiler and a bytecode VM! We’ve added the crown jewel to our shiniest Monkey implementation. Time to celebrate.</p>
<h1 id="taking-time">Taking Time</h1>
<p>We’re at the end of our journey. We did it. We successfully built a bytecode compiler and a virtual machine.</p>
<p>We’ve implemented binary and prefix operators, conditionals with jump instructions, global and local bindings, strings, arrays, hashes, first-class functions, higher-order functions, built-in functions and now even closures, the most prestigious of all the features.</p>
<p>It’s time we give ourselves a little pat on the back. With great contentment, with the fulfillment that comes after having put in the work, we can now watch as our compiler compiles and our VM executes the following piece of Monkey code.</p>
<p>This is <em>the</em> go-to example to showcase a programming language. Yes, it might be a cliché, but nevertheless, it’s a milestone and always brings a smile to my face. I’m talking about the recursive function for computing a Fibonacci number:</p>
<div class="sourceCode" id="cb534"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb534-1"><a href="#cb534-1"></a><span class="co">// vm/vm_test.go</span></span>
<span id="cb534-2"><a href="#cb534-2"></a></span>
<span id="cb534-3"><a href="#cb534-3"></a><span class="kw">func</span> TestRecursiveFibonacci(t *testing.T) {</span>
<span id="cb534-4"><a href="#cb534-4"></a>    tests := []vmTestCase{</span>
<span id="cb534-5"><a href="#cb534-5"></a>        {</span>
<span id="cb534-6"><a href="#cb534-6"></a>            input: <span class="st">`</span></span>
<span id="cb534-7"><a href="#cb534-7"></a><span class="st">        let fibonacci = fn(x) {</span></span>
<span id="cb534-8"><a href="#cb534-8"></a><span class="st">            if (x == 0) {</span></span>
<span id="cb534-9"><a href="#cb534-9"></a><span class="st">                return 0;</span></span>
<span id="cb534-10"><a href="#cb534-10"></a><span class="st">            } else {</span></span>
<span id="cb534-11"><a href="#cb534-11"></a><span class="st">                if (x == 1) {</span></span>
<span id="cb534-12"><a href="#cb534-12"></a><span class="st">                    return 1;</span></span>
<span id="cb534-13"><a href="#cb534-13"></a><span class="st">                } else {</span></span>
<span id="cb534-14"><a href="#cb534-14"></a><span class="st">                    fibonacci(x - 1) + fibonacci(x - 2);</span></span>
<span id="cb534-15"><a href="#cb534-15"></a><span class="st">                }</span></span>
<span id="cb534-16"><a href="#cb534-16"></a><span class="st">            }</span></span>
<span id="cb534-17"><a href="#cb534-17"></a><span class="st">        };</span></span>
<span id="cb534-18"><a href="#cb534-18"></a><span class="st">        fibonacci(15);</span></span>
<span id="cb534-19"><a href="#cb534-19"></a><span class="st">        `</span>,</span>
<span id="cb534-20"><a href="#cb534-20"></a>            expected: <span class="dv">610</span>,</span>
<span id="cb534-21"><a href="#cb534-21"></a>        },</span>
<span id="cb534-22"><a href="#cb534-22"></a>    }</span>
<span id="cb534-23"><a href="#cb534-23"></a></span>
<span id="cb534-24"><a href="#cb534-24"></a>    runVmTests(t, tests)</span>
<span id="cb534-25"><a href="#cb534-25"></a>}</span></code></pre></div>
<p>Ah, recursion! Beautiful, isn’t it? Here we go, cross your fingers, knock on wood:</p>
<div class="sourceCode" id="cb535"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb535-1"><a href="#cb535-1"></a>$ go test ./vm</span>
<span id="cb535-2"><a href="#cb535-2"></a>ok      monkey/vm   0.034s</span></code></pre></div>
<p>Beautiful! Now, using a recursive Fibonacci function to showcase a language’s ability is not exactly what created this aura of cliché – using it as a benchmark for a language’s performance is.</p>
<p>Knowing how fast a language can execute such a function tells us nothing about how it performs in a production setting, with <em>real</em> code and a <em>real</em> workload. But we also know that Monkey was never built for that anyway and that benchmarks and numbers are fun. And you also might remember that, in the first chapter, I promised that this new implementation of Monkey will be three times as fast as the old one. It’s time for me to deliver on that promise.</p>
<p>Let’s create a little utility that allows us to compare our evaluator from the first book against our new bytecode interpreter and see how fast they can calculate a Fibonacci number.</p>
<p>In a new folder, <code>benchmark</code>, we create a new <code>main.go</code> file:</p>
<div class="sourceCode" id="cb536"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb536-1"><a href="#cb536-1"></a><span class="co">// benchmark/main.go</span></span>
<span id="cb536-2"><a href="#cb536-2"></a></span>
<span id="cb536-3"><a href="#cb536-3"></a><span class="kw">package</span> main</span>
<span id="cb536-4"><a href="#cb536-4"></a></span>
<span id="cb536-5"><a href="#cb536-5"></a><span class="kw">import</span> (</span>
<span id="cb536-6"><a href="#cb536-6"></a>    <span class="st">&quot;flag&quot;</span></span>
<span id="cb536-7"><a href="#cb536-7"></a>    <span class="st">&quot;fmt&quot;</span></span>
<span id="cb536-8"><a href="#cb536-8"></a>    <span class="st">&quot;time&quot;</span></span>
<span id="cb536-9"><a href="#cb536-9"></a></span>
<span id="cb536-10"><a href="#cb536-10"></a>    <span class="st">&quot;monkey/compiler&quot;</span></span>
<span id="cb536-11"><a href="#cb536-11"></a>    <span class="st">&quot;monkey/evaluator&quot;</span></span>
<span id="cb536-12"><a href="#cb536-12"></a>    <span class="st">&quot;monkey/lexer&quot;</span></span>
<span id="cb536-13"><a href="#cb536-13"></a>    <span class="st">&quot;monkey/object&quot;</span></span>
<span id="cb536-14"><a href="#cb536-14"></a>    <span class="st">&quot;monkey/parser&quot;</span></span>
<span id="cb536-15"><a href="#cb536-15"></a>    <span class="st">&quot;monkey/vm&quot;</span></span>
<span id="cb536-16"><a href="#cb536-16"></a>)</span>
<span id="cb536-17"><a href="#cb536-17"></a></span>
<span id="cb536-18"><a href="#cb536-18"></a><span class="kw">var</span> engine = flag.String(<span class="st">&quot;engine&quot;</span>, <span class="st">&quot;vm&quot;</span>, <span class="st">&quot;use &#39;vm&#39; or &#39;eval&#39;&quot;</span>)</span>
<span id="cb536-19"><a href="#cb536-19"></a></span>
<span id="cb536-20"><a href="#cb536-20"></a><span class="kw">var</span> input = <span class="st">`</span></span>
<span id="cb536-21"><a href="#cb536-21"></a><span class="st">let fibonacci = fn(x) {</span></span>
<span id="cb536-22"><a href="#cb536-22"></a><span class="st">  if (x == 0) {</span></span>
<span id="cb536-23"><a href="#cb536-23"></a><span class="st">    0</span></span>
<span id="cb536-24"><a href="#cb536-24"></a><span class="st">  } else {</span></span>
<span id="cb536-25"><a href="#cb536-25"></a><span class="st">    if (x == 1) {</span></span>
<span id="cb536-26"><a href="#cb536-26"></a><span class="st">      return 1;</span></span>
<span id="cb536-27"><a href="#cb536-27"></a><span class="st">    } else {</span></span>
<span id="cb536-28"><a href="#cb536-28"></a><span class="st">      fibonacci(x - 1) + fibonacci(x - 2);</span></span>
<span id="cb536-29"><a href="#cb536-29"></a><span class="st">    }</span></span>
<span id="cb536-30"><a href="#cb536-30"></a><span class="st">  }</span></span>
<span id="cb536-31"><a href="#cb536-31"></a><span class="st">};</span></span>
<span id="cb536-32"><a href="#cb536-32"></a><span class="st">fibonacci(35);</span></span>
<span id="cb536-33"><a href="#cb536-33"></a><span class="st">`</span></span>
<span id="cb536-34"><a href="#cb536-34"></a></span>
<span id="cb536-35"><a href="#cb536-35"></a><span class="kw">func</span> main() {</span>
<span id="cb536-36"><a href="#cb536-36"></a>    flag.Parse()</span>
<span id="cb536-37"><a href="#cb536-37"></a></span>
<span id="cb536-38"><a href="#cb536-38"></a>    <span class="kw">var</span> duration time.Duration</span>
<span id="cb536-39"><a href="#cb536-39"></a>    <span class="kw">var</span> result object.Object</span>
<span id="cb536-40"><a href="#cb536-40"></a></span>
<span id="cb536-41"><a href="#cb536-41"></a>    l := lexer.New(input)</span>
<span id="cb536-42"><a href="#cb536-42"></a>    p := parser.New(l)</span>
<span id="cb536-43"><a href="#cb536-43"></a>    program := p.ParseProgram()</span>
<span id="cb536-44"><a href="#cb536-44"></a></span>
<span id="cb536-45"><a href="#cb536-45"></a>    <span class="kw">if</span> *engine == <span class="st">&quot;vm&quot;</span> {</span>
<span id="cb536-46"><a href="#cb536-46"></a>        comp := compiler.New()</span>
<span id="cb536-47"><a href="#cb536-47"></a>        err := comp.Compile(program)</span>
<span id="cb536-48"><a href="#cb536-48"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb536-49"><a href="#cb536-49"></a>            fmt.Printf(<span class="st">&quot;compiler error: %s&quot;</span>, err)</span>
<span id="cb536-50"><a href="#cb536-50"></a>            <span class="kw">return</span></span>
<span id="cb536-51"><a href="#cb536-51"></a>        }</span>
<span id="cb536-52"><a href="#cb536-52"></a></span>
<span id="cb536-53"><a href="#cb536-53"></a>        machine := vm.New(comp.Bytecode())</span>
<span id="cb536-54"><a href="#cb536-54"></a></span>
<span id="cb536-55"><a href="#cb536-55"></a>        start := time.Now()</span>
<span id="cb536-56"><a href="#cb536-56"></a></span>
<span id="cb536-57"><a href="#cb536-57"></a>        err = machine.Run()</span>
<span id="cb536-58"><a href="#cb536-58"></a>        <span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb536-59"><a href="#cb536-59"></a>            fmt.Printf(<span class="st">&quot;vm error: %s&quot;</span>, err)</span>
<span id="cb536-60"><a href="#cb536-60"></a>            <span class="kw">return</span></span>
<span id="cb536-61"><a href="#cb536-61"></a>        }</span>
<span id="cb536-62"><a href="#cb536-62"></a></span>
<span id="cb536-63"><a href="#cb536-63"></a>        duration = time.Since(start)</span>
<span id="cb536-64"><a href="#cb536-64"></a>        result = machine.LastPoppedStackElem()</span>
<span id="cb536-65"><a href="#cb536-65"></a>    } <span class="kw">else</span> {</span>
<span id="cb536-66"><a href="#cb536-66"></a>        env := object.NewEnvironment()</span>
<span id="cb536-67"><a href="#cb536-67"></a>        start := time.Now()</span>
<span id="cb536-68"><a href="#cb536-68"></a>        result = evaluator.Eval(program, env)</span>
<span id="cb536-69"><a href="#cb536-69"></a>        duration = time.Since(start)</span>
<span id="cb536-70"><a href="#cb536-70"></a>    }</span>
<span id="cb536-71"><a href="#cb536-71"></a></span>
<span id="cb536-72"><a href="#cb536-72"></a>    fmt.Printf(</span>
<span id="cb536-73"><a href="#cb536-73"></a>        <span class="st">&quot;engine=%s, result=%s, duration=%s</span><span class="ch">\n</span><span class="st">&quot;</span>,</span>
<span id="cb536-74"><a href="#cb536-74"></a>        *engine,</span>
<span id="cb536-75"><a href="#cb536-75"></a>        result.Inspect(),</span>
<span id="cb536-76"><a href="#cb536-76"></a>        duration)</span>
<span id="cb536-77"><a href="#cb536-77"></a>}</span></code></pre></div>
<p>There’s nothing here we haven’t seen before. The input is the same fibonacci function we already know we can compile and execute, except that this time, the input is <code>35</code>, which gives our interpreters something to chew on.</p>
<p>In the <code>main</code> function we parse the command-line flag <code>engine</code> and, depending on its value, either execute the <code>fibonacci</code> snippet in the evaluator from the first book or compile it for and execute it in our new, shiny VM. Either way, we measure the time it takes to execute it and then print a summary of the benchmark.</p>
<p>Running it will tell us how much performance we gained by switching from a tree-walking interpreter to a compiler and a virtual machine – without focusing on performance at all and a lot of optimization opportunities left unused.</p>
<p>We build it into its own executable:</p>
<div class="sourceCode" id="cb537"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb537-1"><a href="#cb537-1"></a>$ go build -o fibonacci ./benchmark</span></code></pre></div>
<p>And now, welcome, first on the stage, the evaluator:</p>
<div class="sourceCode" id="cb538"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb538-1"><a href="#cb538-1"></a>$ ./fibonacci -engine=eval</span>
<span id="cb538-2"><a href="#cb538-2"></a>engine=eval, result=9227465, duration=27.204277379s</span></code></pre></div>
<p>27 seconds. Time for our final pat on the back:</p>
<div class="sourceCode" id="cb539"><pre class="sourceCode changelog"><code class="sourceCode changelog"><span id="cb539-1"><a href="#cb539-1"></a>$ ./fibonacci -engine=vm</span>
<span id="cb539-2"><a href="#cb539-2"></a>engine=vm, result=9227465, duration=8.876222455s</span></code></pre></div>
<p>8 seconds. 3.3 times faster.</p>
<h1 class="unnumbered" id="resources">Resources</h1>
<h4 id="books">Books</h4>
<ul>
<li>Abelson, Harold and Sussman, Gerald Jay with Sussman, Julie. 1996. <strong>Structure and Interpretation of Computer Programs, Second Edition</strong>. MIT Press.</li>
<li>Appel, Andrew W.. 2004. <strong>Modern Compiler Implementation in C</strong>. Cambridge University Press.</li>
<li>Appel, Andrew W.. 2004. <strong>Modern Compiler Implementation in ML</strong>. Cambridge University Press.</li>
<li>Cooper, Keith D. and Torczon Linda. 2011. <strong>Engineering a Compiler, Second Edition</strong>. Morgan Kaufmann.</li>
<li>Grune, Dick and Jacobs, Ceriel. 1990. <strong>Parsing Techniques. A Practical Guide.</strong>. Ellis Horwood Limited.</li>
<li>Grune, Dick and van Reeuwijk, Kees and Bal Henri E. and Jacobs, Ceriel J.H. Jacobs and Langendoen, Koen. 2012. <strong>Modern Compiler Design, Second Edition</strong>. Springer</li>
<li>Nisan, Noam and Schocken, Shimon. 2008. <strong>The Elements Of Computing Systems</strong>. MIT Press.</li>
<li>Parr, Terrence. 2010. <strong>Language Implementation Patterns: Create Your Own Domain-Specific and General Programming Languages</strong>. Pragmatic Programmers.</li>
<li>Queinnec, Christian. 2003. <strong>Lisp in Small Pieces</strong>. Cambridge University Press.</li>
</ul>
<h4 id="papers">Papers</h4>
<ul>
<li>Ayock, John. 2003. <strong>A Brief History of Just-In-Time</strong>. In <strong>ACM Computing Surveys, Vol. 35, No. 2, June 2003</strong></li>
<li>Dybvig, R. Kent. 2006. <strong>The Development of Chez Scheme</strong>. In <strong>ACM ICFP ’06</strong></li>
<li>Dybvig, R. Kent. 1987. <strong>Three Implementation Models for Scheme</strong>. Dissertation, University of North Carolina at Chapel Hill</li>
<li>Ertl, M. Anton and Gregg, David. 2003. <strong>The Structure and Performance of Efficient Interpreters</strong>. In <strong>Journal Of Instruction-Level Parallelism 5 (2003)</strong></li>
<li>Ghuloum, Abdulaziz. 2006. <strong>An Incremental Approach To Compiler Construction</strong>. In <strong>Proceedings of the 2006 Scheme and Functional Programming Workshop</strong>.</li>
<li>Ierusalimschy, Robert and de Figueiredo, Luiz Henrique and Celes Waldemar. <strong>The Implementation of Lua 5.0</strong>. <a href="https://www.lua.org/doc/jucs05.pdf">https://www.lua.org/doc/jucs05.pdf</a></li>
<li>Pratt, Vaughan R. 1973. <strong>Top Down Operator Precedence</strong>. Massachusetts Institute of Technology.</li>
<li>Romer, Theodore H. and Lee, Dennis and Voelker, Geoffrey M. and Wolman, Alec and Wong, Wayne A. and Baer, Jean-Loup and Bershad, Brian N. and Levy, Henry M.. 1996. <strong>The Structure and Performance of Interpreters</strong>. In <strong>ASPLOS VII Proceedings of the seventh international conference on Architectural support for programming languages and operating systems</strong>.</li>
<li>Fang, Ruijie and Liu. <strong>A Performance Survey on Stack-based and Register-based Virtual Machines</strong>.</li>
</ul>
<h4 id="web">Web</h4>
<ul>
<li>Aaron Patterson - Reducing Memory Usage In Ruby: <a href="https://tenderlovemaking.com/2018/01/23/reducing-memory-usage-in-ruby.html">https://tenderlovemaking.com/2018/01/23/reducing-memory-usage-in-ruby.html</a></li>
<li>Allison Kaptur - A Python Interpreter Written in Python: <a href="http://aosabook.org/en/500L/a-python-interpreter-written-in-python.html">http://aosabook.org/en/500L/a-python-interpreter-written-in-python.html</a></li>
<li>Andy Wingo - a lambda is not (necessarily) a closure: <a href="https://wingolog.org/archives/2016/02/08/a-lambda-is-not-necessarily-a-closure">https://wingolog.org/archives/2016/02/08/a-lambda-is-not-necessarily-a-closure</a></li>
<li>Andy Wingo - a register vm for guile: <a href="https://wingolog.org/archives/2013/11/26/a-register-vm-for-guile">https://wingolog.org/archives/2013/11/26/a-register-vm-for-guile</a></li>
<li>Andy Wingo - the half strap: self-hosting and guile: <a href="https://wingolog.org/archives/2016/01/11/the-half-strap-self-hosting-and-guile">https://wingolog.org/archives/2016/01/11/the-half-strap-self-hosting-and-guile</a></li>
<li>Eli Bendersky - Adventures in JIT compilation: Part 2 - an x64 JIT: <a href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-2-an-x64-jit/">https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-2-an-x64-jit/</a></li>
<li>GNU Guile Documentation - About Closures - <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure">https://www.gnu.org/software/guile/manual/guile.html#About-Closure</a></li>
<li>Jack W. Crenshaw - Let’s Build a Compiler! - <a href="http://compilers.iecc.com/crenshaw/tutorfinal.pdf">http://compilers.iecc.com/crenshaw/tutorfinal.pdf</a></li>
<li>Kein-Hong Man - A No-Frills Introduction to Lua 5.1 VM Instructions: <a href="http://luaforge.net/docman/83/98/ANoFrillsIntroToLua51VMInstructions.pdf">http://luaforge.net/docman/83/98/ANoFrillsIntroToLua51VMInstructions.pdf</a></li>
<li>Lua 5.3 Bytecode Reference: <a href="http://the-ravi-programming-language.readthedocs.io/en/latest/lua_bytecode_reference.html">http://the-ravi-programming-language.readthedocs.io/en/latest/lua_bytecode_reference.html</a></li>
<li>LuaJIT 2.0 Bytecode Instructions: <a href="http://wiki.luajit.org/Bytecode-2.0">http://wiki.luajit.org/Bytecode-2.0</a></li>
<li>Mathew Zaleski - Dispatch Techniques: <a href="http://www.cs.toronto.edu/~matz/dissertation/matzDissertation-latex2html/node6.html">http://www.cs.toronto.edu/~matz/dissertation/matzDissertation-latex2html/node6.html</a></li>
<li>Matt Might - Closure Conversion - “Flat Closures”: <a href="http://matt.might.net/articles/closure-conversion/">http://matt.might.net/articles/closure-conversion/</a></li>
<li>Matt Might - Compiling Scheme to C with closure conversion: <a href="http://matt.might.net/articles/compiling-scheme-to-c/">http://matt.might.net/articles/compiling-scheme-to-c/</a></li>
<li>Mozilla SpiderMonkey Internals: <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Internals">https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Internals</a></li>
<li>Stack Overflow - Implementation of closures in Lua?: <a href="https://stackoverflow.com/questions/7781432/implementation-of-closures-in-lua">https://stackoverflow.com/questions/7781432/implementation-of-closures-in-lua</a></li>
<li>The Cliffs of Inanity - Emacs JIT Calling Convention: <a href="http://tromey.com/blog/?p=999">http://tromey.com/blog/?p=999</a></li>
<li>Vyacheslav Egorov - Explaining JavaScript VMs in JavaScript - Inline Caches: <a href="https://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html">https://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html</a></li>
<li>Peter Michaux - Scheme from Scratch - Introduction: <a href="http://peter.michaux.ca/articles/scheme-from-scratch-introduction">http://peter.michaux.ca/articles/scheme-from-scratch-introduction</a></li>
</ul>
<h4 id="source-code">Source Code</h4>
<ul>
<li>8cc - A Small C Compiler - <a href="https://github.com/rui314/8cc">https://github.com/rui314/8cc</a></li>
<li>GNU Guile 2.2 - <a href="https://www.gnu.org/software/guile/download/">https://www.gnu.org/software/guile/download/</a></li>
<li>MoarVM - A modern VM built for Rakudo Perl 6 - <a href="https://github.com/MoarVM/MoarVM">https://github.com/MoarVM/MoarVM</a></li>
<li>The Lua Programming Language (1.1, 3.1, 5.3.2) - <a href="https://www.lua.org/versions.html">https://www.lua.org/versions.html</a></li>
<li>The Ruby Programming Language - <a href="https://github.com/ruby/ruby">https://github.com/ruby/ruby</a></li>
<li>The Wren Programming Language - <a href="https://github.com/munificent/wren">https://github.com/munificent/wren</a></li>
<li>c4 - C in four functions - <a href="https://github.com/rswier/c4">https://github.com/rswier/c4</a></li>
<li>tcc - Tiny C Compiler - <a href="https://github.com/LuaDist/tcc">https://github.com/LuaDist/tcc</a></li>
</ul>
<h1 class="unnumbered" id="feedback">Feedback</h1>
<p>If you spot a typo, find something wrong with the code, have a suggestion to make or just a question, feel free to send me an email:</p>
<p><strong>me@thorstenball.com</strong></p>
<h1 class="unnumbered" id="changelog">Changelog</h1>
<h4 id="may-2019---1.2">7 May 2019 - 1.2</h4>
<ul>
<li>Code
<ul>
<li>Added <code>go.mod</code> files to the code folder so that users with Go &gt;= 1.13 can easily run it without having to set <code>$GOPATH</code></li>
</ul></li>
<li>Introduction and following chapters
<ul>
<li>Changed REPL code from <code>fmt.Printf</code> to correctly use <code>fmt.Fprintf</code> to make use of <code>out</code> parameter</li>
</ul></li>
<li>Chapter 1 - Real Machines
<ul>
<li>Fixed a typo where it said “We’re going the” instead of “We’re going to”</li>
</ul></li>
<li>Chapter 2 - Starting With Bytes
<ul>
<li>Removed a comma that disrupted flow</li>
</ul></li>
<li>Chapter 3 - Booleans
<ul>
<li>Fixed a typo where it said “There are also has” instead of “There are also”</li>
</ul></li>
<li>Chapter 3 - Comparison Operators
<ul>
<li>Changed the conditional in <code>executeComparison</code> that checks that both operands are integers from a <code>||</code> to the correct <code>&amp;&amp;</code></li>
</ul></li>
<li>Chapter 4
<ul>
<li>Fixed a typo where it said “We need put” instead of “We need to put”</li>
</ul></li>
<li>Chapter 7
<ul>
<li>Fixed the wrong function names in the code snippet: <code>minsOne</code> and <code>minsTwo</code> to <code>minusOne</code> and <code>minusTwo</code></li>
</ul></li>
<li>Chapter 9 - Recursive Closures
<ul>
<li>Removed duplicate word “fail”</li>
</ul></li>
</ul>
<h4 id="march-2019---1.1">20 March 2019 - 1.1</h4>
<p>Besides fixes for various typos and spelling errors:</p>
<ul>
<li>Chapter 3 - Infix Expressions:
<ul>
<li>Remove duplicated test case</li>
</ul></li>
<li>Chapter 6 - Array:
<ul>
<li>Fix broken link to Wikipedia entry for “Composite Data Type”</li>
</ul></li>
<li>Chapter 9 - Recursive Closures:
<ul>
<li>Add a completely new section that addresses a bug in the previous implementation that prevented recursive closures defined in other closures from working correctly</li>
</ul></li>
<li>Chapter 10 - Taking Time:
<ul>
<li>Chapter shortened after reworking Chapter 9 to include the proper for recursive closures</li>
</ul></li>
</ul>
<h4 id="july-2018---1.0">31 July 2018 - 1.0</h4>
<p>Initial Release</p>
</body>
</html>
